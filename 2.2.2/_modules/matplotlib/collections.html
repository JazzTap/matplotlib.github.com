<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>matplotlib.collections — Matplotlib 2.2.2 documentation</title>
<link href="../../_static/mpl.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/gallery.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<link href="../../_static/opensearch.xml" rel="search" title="Search within Matplotlib 2.2.2 documentation" type="application/opensearchdescription+xml"/>
<link href="../../_static/favicon.ico" rel="shortcut icon"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="../../index.html" rel="top" title="Matplotlib 2.2.2 documentation"/>
<link href="../matplotlib.html" rel="up" title="matplotlib"/>
<link href="https://matplotlib.org/_modules/matplotlib/collections.html" rel="canonical"/>
<link href="https://matplotlib.org/_modules/matplotlib/collections.html" rel="canonical"/></head>
<body><div id="old-version-banner">
            You are reading documentation for a static version of Matplotlib.
            <a href="https://matplotlib.org/_modules/matplotlib/collections.html">This page may have been updated.</a>
</div>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../../index.html">
<div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 2.2.2</span></div>
<img alt="matplotlib" border="0" height="125px" src="../../_static/logo2.png"/></a>
<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li><a href="../../index.html">home</a>| </li>
<li><a href="../../gallery/index.html">examples</a>| </li>
<li><a href="../../tutorials/index.html">tutorials</a>| </li>
<li><a href="../../api/pyplot_summary.html">pyplot</a>| </li>
<li><a href="../../contents.html">docs</a> »</li>
<li><a href="../index.html">Module code</a> »</li>
<li><a accesskey="U" href="../matplotlib.html">matplotlib</a> »</li>
</ul>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div id="searchbox" role="search" style="display: none">
<h3>Quick search</h3>
<div class="searchformwrapper">
<form action="../../search.html" class="search" method="get">
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="../../contents.html">Documentation overview</a><ul>
<li><a href="../index.html">Module code</a><ul>
<li><a href="../matplotlib.html">matplotlib</a><ul>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<h1>Source code for matplotlib.collections</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">Classes for the efficient drawing of large collections of objects that</span>
<span class="sd">share most properties, e.g., a large number of line segments or</span>
<span class="sd">polygons.</span>

<span class="sd">The classes are not meant to be as flexible as their single element</span>
<span class="sd">counterparts (e.g., you may not be able to select all line styles) but</span>
<span class="sd">they are meant to be fast for common use cases (e.g., a large set of solid</span>
<span class="sd">line segemnts)</span>
<span class="sd">"""</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">zip</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># LPy workaround</span>
    <span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="p">(</span><span class="n">_path</span><span class="p">,</span> <span class="n">artist</span><span class="p">,</span> <span class="n">cbook</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span> <span class="n">colors</span> <span class="k">as</span> <span class="n">mcolors</span><span class="p">,</span> <span class="n">docstring</span><span class="p">,</span>
               <span class="n">lines</span> <span class="k">as</span> <span class="n">mlines</span><span class="p">,</span> <span class="n">path</span> <span class="k">as</span> <span class="n">mpath</span><span class="p">,</span> <span class="n">transforms</span><span class="p">)</span>

<span class="n">CIRCLE_AREA_FACTOR</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>


<span class="n">_color_aliases</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'facecolors'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'facecolor'</span><span class="p">],</span>
                  <span class="s1">'edgecolors'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'edgecolor'</span><span class="p">]}</span>


<div class="viewcode-block" id="Collection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection">[docs]</a><span class="k">class</span> <span class="nc">Collection</span><span class="p">(</span><span class="n">artist</span><span class="o">.</span><span class="n">Artist</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Base class for Collections.  Must be subclassed to be usable.</span>

<span class="sd">    All properties in a collection must be sequences or scalars;</span>
<span class="sd">    if scalars, they will be converted to sequences.  The</span>
<span class="sd">    property of the ith element of the collection is::</span>

<span class="sd">      prop[i % len(props)]</span>

<span class="sd">    Exceptions are *capstyle* and *joinstyle* properties, these can</span>
<span class="sd">    only be set globally for the whole collection.</span>

<span class="sd">    Keyword arguments and default values:</span>

<span class="sd">        * *edgecolors*: None</span>
<span class="sd">        * *facecolors*: None</span>
<span class="sd">        * *linewidths*: None</span>
<span class="sd">        * *capstyle*:   None</span>
<span class="sd">        * *joinstyle*:  None</span>
<span class="sd">        * *antialiaseds*: None</span>
<span class="sd">        * *offsets*: None</span>
<span class="sd">        * *transOffset*: transforms.IdentityTransform()</span>
<span class="sd">        * *offset_position*: 'screen' (default) or 'data'</span>
<span class="sd">        * *norm*: None (optional for</span>
<span class="sd">          :class:`matplotlib.cm.ScalarMappable`)</span>
<span class="sd">        * *cmap*: None (optional for</span>
<span class="sd">          :class:`matplotlib.cm.ScalarMappable`)</span>
<span class="sd">        * *hatch*: None</span>
<span class="sd">        * *zorder*: 1</span>


<span class="sd">    *offsets* and *transOffset* are used to translate the patch after</span>
<span class="sd">    rendering (default no offsets).  If offset_position is 'screen'</span>
<span class="sd">    (default) the offset is applied after the master transform has</span>
<span class="sd">    been applied, that is, the offsets are in screen coordinates.  If</span>
<span class="sd">    offset_position is 'data', the offset is applied before the master</span>
<span class="sd">    transform, i.e., the offsets are in data coordinates.</span>

<span class="sd">    If any of *edgecolors*, *facecolors*, *linewidths*, *antialiaseds*</span>
<span class="sd">    are None, they default to their :data:`matplotlib.rcParams` patch</span>
<span class="sd">    setting, in sequence form.</span>

<span class="sd">    The use of :class:`~matplotlib.cm.ScalarMappable` is optional.  If</span>
<span class="sd">    the :class:`~matplotlib.cm.ScalarMappable` matrix _A is not None</span>
<span class="sd">    (i.e., a call to set_array has been made), at draw time a call to</span>
<span class="sd">    scalar mappable will be made to set the face colors.</span>
<span class="sd">    """</span>
    <span class="n">_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">_transOffset</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">()</span>
    <span class="c1">#: Either a list of 3x3 arrays or an Nx3x3 array of transforms, suitable</span>
    <span class="c1">#: for the `all_transforms` argument to</span>
    <span class="c1">#: :meth:`~matplotlib.backend_bases.RendererBase.draw_path_collection`;</span>
    <span class="c1">#: each 3x3 array is used to initialize an</span>
    <span class="c1">#: :class:`~matplotlib.transforms.Affine2D` object.</span>
    <span class="c1">#: Each kind of collection defines this based on its arguments.</span>
    <span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Whether to draw an edge by default.  Set on a</span>
    <span class="c1"># subclass-by-subclass basis.</span>
    <span class="n">_edge_default</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">edgecolors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">facecolors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">linestyles</span><span class="o">=</span><span class="s1">'solid'</span><span class="p">,</span>
                 <span class="n">capstyle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">joinstyle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">antialiaseds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transOffset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># optional for ScalarMappable</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># ditto</span>
                 <span class="n">pickradius</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
                 <span class="n">hatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">urls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">offset_position</span><span class="o">=</span><span class="s1">'screen'</span><span class="p">,</span>
                 <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a Collection</span>

<span class="sd">        %(Collection)s</span>
<span class="sd">        """</span>
        <span class="n">artist</span><span class="o">.</span><span class="n">Artist</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="p">)</span>
        <span class="c1"># list of un-scaled dash patterns</span>
        <span class="c1"># this is needed scaling the dash pattern by linewidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="c1"># list of dash patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="c1"># list of unbroadcast/scaled linewidths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_lw</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># May be modified by set_facecolor().</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_hatch_color</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'hatch.color'</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">facecolors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">edgecolors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_linestyle</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_antialiased</span><span class="p">(</span><span class="n">antialiaseds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pickradius</span><span class="p">(</span><span class="n">pickradius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_urls</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_hatch</span><span class="p">(</span><span class="n">hatch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_offset_position</span><span class="p">(</span><span class="n">offset_position</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="n">zorder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">capstyle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_capstyle</span><span class="p">(</span><span class="n">capstyle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">joinstyle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_joinstyle</span><span class="p">(</span><span class="n">joinstyle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Broadcast (2,) -&gt; (1, 2) but nothing else.</span>
            <span class="k">if</span> <span class="n">offsets</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">transOffset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span> <span class="o">=</span> <span class="n">offsets</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transOffset</span> <span class="o">=</span> <span class="n">transOffset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="o">=</span> <span class="n">offsets</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_path_effects</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Collection.get_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span></div>

<div class="viewcode-block" id="Collection.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Collection.get_transforms"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_transforms">[docs]</a>    <span class="k">def</span> <span class="nf">get_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span></div>

<div class="viewcode-block" id="Collection.get_offset_transform"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_offset_transform">[docs]</a>    <span class="k">def</span> <span class="nf">get_offset_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transOffset</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">'_as_mpl_transform'</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span></div>

<div class="viewcode-block" id="Collection.get_datalim"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_datalim">[docs]</a>    <span class="k">def</span> <span class="nf">get_datalim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transData</span><span class="p">):</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="n">transOffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset_transform</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transform</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">]</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
            <span class="n">transOffset</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="c1"># get_path_collection_extents handles nan but not masked arrays</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">get_path_collection_extents</span><span class="p">(</span>
                <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="n">paths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transforms</span><span class="p">(),</span>
                <span class="n">offsets</span><span class="p">,</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inverse_transformed</span><span class="p">(</span><span class="n">transData</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">null</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Collection.get_window_extent"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_window_extent">[docs]</a>    <span class="k">def</span> <span class="nf">get_window_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="c1"># TODO:check to ensure that this does not fail for</span>
        <span class="c1"># cases other than scatter plot legend</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datalim</span><span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_prepare_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Point prep for drawing and hit testing"""</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="n">transOffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset_transform</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">have_units</span><span class="p">():</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_paths</span><span class="p">():</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">vertices</span>
                <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]),</span> <span class="n">path</span><span class="o">.</span><span class="n">codes</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">offsets</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transform</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">]</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
            <span class="c1"># This might have changed an ndarray into a masked array.</span>
            <span class="n">transOffset</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="c1"># Changing from a masked array to nan-filled ndarray</span>
            <span class="c1"># is probably most efficient at this point.</span>

        <span class="k">return</span> <span class="n">transform</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">paths</span>

<div class="viewcode-block" id="Collection.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gid</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_scalarmappable</span><span class="p">()</span>

        <span class="n">transform</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_points</span><span class="p">()</span>

        <span class="n">gc</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">new_gc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_gc_clip</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_snap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_snap</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_hatch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">gc</span><span class="o">.</span><span class="n">set_hatch_color</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hatch_color</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># if we end up with a GC that does not have this method</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"Your backend does not support setting the "</span>
                              <span class="s2">"hatch color."</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sketch_params</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_sketch_params</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sketch_params</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_effects</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">matplotlib.patheffects</span> <span class="k">import</span> <span class="n">PathEffectRenderer</span>
            <span class="n">renderer</span> <span class="o">=</span> <span class="n">PathEffectRenderer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_effects</span><span class="p">(),</span> <span class="n">renderer</span><span class="p">)</span>

        <span class="c1"># If the collection is made up of a single shape/color/stroke,</span>
        <span class="c1"># it can be rendered once and blitted multiple times, using</span>
        <span class="c1"># `draw_markers` rather than `draw_path_collection`.  This is</span>
        <span class="c1"># *much* faster for Agg, and results in smaller file sizes in</span>
        <span class="c1"># PDF/SVG/PS.</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transforms</span><span class="p">()</span>
        <span class="n">facecolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span>
        <span class="n">edgecolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edgecolor</span><span class="p">()</span>
        <span class="n">do_single_path_optimization</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">facecolors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgecolors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">==</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_urls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_hatch</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="p">):</span>
                <span class="n">combined_transform</span> <span class="o">=</span> <span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">Affine2D</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                                      <span class="n">transform</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">combined_transform</span> <span class="o">=</span> <span class="n">transform</span>
            <span class="n">extents</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_extents</span><span class="p">(</span><span class="n">combined_transform</span><span class="p">)</span>
            <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">get_canvas_width_height</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">extents</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="ow">and</span>
                <span class="n">extents</span><span class="o">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">):</span>
                <span class="n">do_single_path_optimization</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_joinstyle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_capstyle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">do_single_path_optimization</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_foreground</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">edgecolors</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_dashes</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_antialiased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_urls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">renderer</span><span class="o">.</span><span class="n">draw_markers</span><span class="p">(</span>
                <span class="n">gc</span><span class="p">,</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combined_transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span>
                <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">offsets</span><span class="p">),</span> <span class="n">transOffset</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">facecolors</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">renderer</span><span class="o">.</span><span class="n">draw_path_collection</span><span class="p">(</span>
                <span class="n">gc</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="n">paths</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_transforms</span><span class="p">(),</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edgecolor</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_urls</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offset_position</span><span class="p">)</span>

        <span class="n">gc</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">close_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Collection.set_pickradius"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_pickradius">[docs]</a>    <span class="k">def</span> <span class="nf">set_pickradius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pr</span><span class="p">):</span>
        <span class="sd">"""Set the pick radius used for containment tests.</span>

<span class="sd">        .. ACCEPTS: float distance in points</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : float</span>
<span class="sd">            Pick radius, in points.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pickradius</span> <span class="o">=</span> <span class="n">pr</span></div>

<div class="viewcode-block" id="Collection.get_pickradius"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_pickradius">[docs]</a>    <span class="k">def</span> <span class="nf">get_pickradius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pickradius</span></div>

<div class="viewcode-block" id="Collection.contains"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouseevent</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Test whether the mouse event occurred in the collection.</span>

<span class="sd">        Returns True | False, ``dict(ind=itemlist)``, where every</span>
<span class="sd">        item in itemlist contains the event.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contains</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouseevent</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">{}</span>

        <span class="n">pickradius</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_picker</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_picker</span><span class="p">)</span> <span class="ow">and</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">_picker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span>  <span class="c1"># the bool, not just nonzero or 1</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pickradius</span><span class="p">)</span>

        <span class="n">transform</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_points</span><span class="p">()</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">_path</span><span class="o">.</span><span class="n">point_in_path_collection</span><span class="p">(</span>
            <span class="n">mouseevent</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mouseevent</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pickradius</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="n">paths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transforms</span><span class="p">(),</span>
            <span class="n">offsets</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="n">pickradius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_offset_position</span><span class="p">())</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_urls"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_urls">[docs]</a>    <span class="k">def</span> <span class="nf">set_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">urls</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        urls : List[str] or None</span>
<span class="sd">            .. ACCEPTS: List[str] or None</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_urls</span> <span class="o">=</span> <span class="n">urls</span> <span class="k">if</span> <span class="n">urls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_urls"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_urls">[docs]</a>    <span class="k">def</span> <span class="nf">get_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_urls</span></div>

<div class="viewcode-block" id="Collection.set_hatch"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_hatch">[docs]</a>    <span class="k">def</span> <span class="nf">set_hatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hatch</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Set the hatching pattern</span>

<span class="sd">        *hatch* can be one of::</span>

<span class="sd">          /   - diagonal hatching</span>
<span class="sd">          \   - back diagonal</span>
<span class="sd">          |   - vertical</span>
<span class="sd">          -   - horizontal</span>
<span class="sd">          +   - crossed</span>
<span class="sd">          x   - crossed diagonal</span>
<span class="sd">          o   - small circle</span>
<span class="sd">          O   - large circle</span>
<span class="sd">          .   - dots</span>
<span class="sd">          *   - stars</span>

<span class="sd">        Letters can be combined, in which case all the specified</span>
<span class="sd">        hatchings are done.  If same letter repeats, it increases the</span>
<span class="sd">        density of hatching of that pattern.</span>

<span class="sd">        Hatching is supported in the PostScript, PDF, SVG and Agg</span>
<span class="sd">        backends only.</span>

<span class="sd">        Unlike other properties such as linewidth and colors, hatching</span>
<span class="sd">        can only be specified for the collection as a whole, not separately</span>
<span class="sd">        for each member.</span>

<span class="sd">        ACCEPTS: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span> <span class="o">=</span> <span class="n">hatch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_hatch"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_hatch">[docs]</a>    <span class="k">def</span> <span class="nf">get_hatch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the current hatching pattern."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span></div>

<div class="viewcode-block" id="Collection.set_offsets"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_offsets">[docs]</a>    <span class="k">def</span> <span class="nf">set_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offsets</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the offsets for the collection.  *offsets* can be a scalar</span>
<span class="sd">        or a sequence.</span>

<span class="sd">        ACCEPTS: float or sequence of floats</span>
<span class="sd">        """</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offsets</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>  <span class="c1"># Broadcast (2,) -&gt; (1, 2) but nothing else.</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># This decision is based on how they are initialized above in __init__.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span> <span class="o">=</span> <span class="n">offsets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="o">=</span> <span class="n">offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_offsets"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_offsets">[docs]</a>    <span class="k">def</span> <span class="nf">get_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the offsets for the collection."""</span>
        <span class="c1"># This decision is based on how they are initialized above in __init__.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span></div>

<div class="viewcode-block" id="Collection.set_offset_position"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_offset_position">[docs]</a>    <span class="k">def</span> <span class="nf">set_offset_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_position</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set how offsets are applied.  If *offset_position* is 'screen'</span>
<span class="sd">        (default) the offset is applied after the master transform has</span>
<span class="sd">        been applied, that is, the offsets are in screen coordinates.</span>
<span class="sd">        If offset_position is 'data', the offset is applied before the</span>
<span class="sd">        master transform, i.e., the offsets are in data coordinates.</span>

<span class="sd">        .. ACCEPTS: [ 'screen' | 'data' ]</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">offset_position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'screen'</span><span class="p">,</span> <span class="s1">'data'</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"offset_position must be 'screen' or 'data'"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset_position</span> <span class="o">=</span> <span class="n">offset_position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_offset_position"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_offset_position">[docs]</a>    <span class="k">def</span> <span class="nf">get_offset_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns how offsets are applied for the collection.  If</span>
<span class="sd">        *offset_position* is 'screen', the offset is applied after the</span>
<span class="sd">        master transform has been applied, that is, the offsets are in</span>
<span class="sd">        screen coordinates.  If offset_position is 'data', the offset</span>
<span class="sd">        is applied before the master transform, i.e., the offsets are</span>
<span class="sd">        in data coordinates.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset_position</span></div>

<div class="viewcode-block" id="Collection.set_linewidth"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_linewidth">[docs]</a>    <span class="k">def</span> <span class="nf">set_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the linewidth(s) for the collection.  *lw* can be a scalar</span>
<span class="sd">        or a sequence; if it is a sequence the patches will cycle</span>
<span class="sd">        through the sequence</span>

<span class="sd">        ACCEPTS: float or sequence of floats</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">lw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'patch.linewidth'</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lw</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'lines.linewidth'</span><span class="p">]</span>
        <span class="c1"># get the un-scaled/broadcast lw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_lw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lw</span><span class="p">))</span>

        <span class="c1"># scale all of the dash patterns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bcast_lwls</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_us_lw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.set_linewidths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_linewidths">[docs]</a>    <span class="k">def</span> <span class="nf">set_linewidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="sd">"""alias for set_linewidth"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">lw</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_lw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_lw">[docs]</a>    <span class="k">def</span> <span class="nf">set_lw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="sd">"""alias for set_linewidth"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">lw</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_linestyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_linestyle">[docs]</a>    <span class="k">def</span> <span class="nf">set_linestyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the linestyle(s) for the collection.</span>

<span class="sd">        ===========================   =================</span>
<span class="sd">        linestyle                     description</span>
<span class="sd">        ===========================   =================</span>
<span class="sd">        ``'-'`` or ``'solid'``        solid line</span>
<span class="sd">        ``'--'`` or  ``'dashed'``     dashed line</span>
<span class="sd">        ``'-.'`` or  ``'dashdot'``    dash-dotted line</span>
<span class="sd">        ``':'`` or ``'dotted'``       dotted line</span>
<span class="sd">        ===========================   =================</span>

<span class="sd">        Alternatively a dash tuple of the following form can be provided::</span>

<span class="sd">            (offset, onoffseq),</span>

<span class="sd">        where ``onoffseq`` is an even length tuple of on and off ink</span>
<span class="sd">        in points.</span>

<span class="sd">        ACCEPTS: ['solid' | 'dashed', 'dashdot', 'dotted' |</span>
<span class="sd">                   (offset, on-off-dash-seq) |</span>
<span class="sd">                   ``'-'`` | ``'--'`` | ``'-.'`` | ``':'`` | ``'None'`` |</span>
<span class="sd">                   ``' '`` | ``''``]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ls : { '-',  '--', '-.', ':'} and more see description</span>
<span class="sd">            The line style.</span>
<span class="sd">        """</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">ls_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ls</span><span class="p">)</span>
                <span class="n">dashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlines</span><span class="o">.</span><span class="n">_get_dash_pattern</span><span class="p">(</span><span class="n">ls</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlines</span><span class="o">.</span><span class="n">_get_dash_pattern</span><span class="p">(</span><span class="n">ls</span><span class="p">)]</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">dashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlines</span><span class="o">.</span><span class="n">_get_dash_pattern</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">]</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">'Do not know how to convert </span><span class="si">{!r}</span><span class="s1"> to dashes'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span>

        <span class="c1"># get the list of raw 'unscaled' dash patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span> <span class="o">=</span> <span class="n">dashes</span>

        <span class="c1"># broadcast and scale the lw and dash patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bcast_lwls</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_us_lw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_capstyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_capstyle">[docs]</a>    <span class="k">def</span> <span class="nf">set_capstyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the capstyle for the collection. The capstyle can</span>
<span class="sd">        only be set globally for all elements in the collection</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cs : ['butt' | 'round' | 'projecting']</span>
<span class="sd">            The capstyle</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">cs</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'butt'</span><span class="p">,</span> <span class="s1">'round'</span><span class="p">,</span> <span class="s1">'projecting'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span> <span class="o">=</span> <span class="n">cs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Unrecognized cap style.  Found </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">cs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_capstyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_capstyle">[docs]</a>    <span class="k">def</span> <span class="nf">get_capstyle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span></div>

<div class="viewcode-block" id="Collection.set_joinstyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_joinstyle">[docs]</a>    <span class="k">def</span> <span class="nf">set_joinstyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">js</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the joinstyle for the collection. The joinstyle can only be</span>
<span class="sd">        set globally for all elements in the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        js : ['miter' | 'round' | 'bevel']</span>
<span class="sd">            The joinstyle</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">js</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'miter'</span><span class="p">,</span> <span class="s1">'round'</span><span class="p">,</span> <span class="s1">'bevel'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span> <span class="o">=</span> <span class="n">js</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Unrecognized join style.  Found </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">js</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_joinstyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_joinstyle">[docs]</a>    <span class="k">def</span> <span class="nf">get_joinstyle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bcast_lwls</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="n">dashes</span><span class="p">):</span>
        <span class="sd">'''Internal helper function to broadcast + scale ls/lw</span>

<span class="sd">        In the collection drawing code the linewidth and linestyle are</span>
<span class="sd">        cycled through as circular buffers (via v[i % len(v)]).  Thus,</span>
<span class="sd">        if we are going to scale the dash pattern at set time (not</span>
<span class="sd">        draw time) we need to do the broadcasting now and expand both</span>
<span class="sd">        lists to be the same length.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linewidths : list</span>
<span class="sd">            line widths of collection</span>

<span class="sd">        dashes : list</span>
<span class="sd">            dash specification (offset, (dash pattern tuple))</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linewidths, dashes : list</span>
<span class="sd">             Will be the same length, dashes are scaled by paired linewidth</span>

<span class="sd">        '''</span>
        <span class="k">if</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">linewidths</span><span class="p">,</span> <span class="n">dashes</span>
        <span class="c1"># make sure they are the same length so we can zip them</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dashes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
            <span class="n">l_dashes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dashes</span><span class="p">)</span>
            <span class="n">l_lw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>
            <span class="n">GCD</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">l_dashes</span><span class="p">,</span> <span class="n">l_lw</span><span class="p">)</span>
            <span class="n">dashes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dashes</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l_lw</span> <span class="o">//</span> <span class="n">GCD</span><span class="p">)</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l_dashes</span> <span class="o">//</span> <span class="n">GCD</span><span class="p">)</span>

        <span class="c1"># scale the dash patters</span>
        <span class="n">dashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlines</span><span class="o">.</span><span class="n">_scale_dashes</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">lw</span><span class="p">)</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">lw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dashes</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">linewidths</span><span class="p">,</span> <span class="n">dashes</span>

<div class="viewcode-block" id="Collection.set_linestyles"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_linestyles">[docs]</a>    <span class="k">def</span> <span class="nf">set_linestyles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls</span><span class="p">):</span>
        <span class="sd">"""alias for set_linestyle"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_linestyle</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_dashes"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_dashes">[docs]</a>    <span class="k">def</span> <span class="nf">set_dashes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls</span><span class="p">):</span>
        <span class="sd">"""alias for set_linestyle"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_linestyle</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_antialiased"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_antialiased">[docs]</a>    <span class="k">def</span> <span class="nf">set_antialiased</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aa</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the antialiasing state for rendering.</span>

<span class="sd">        ACCEPTS: Boolean or sequence of booleans</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">aa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'patch.antialiased'</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.set_antialiaseds"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_antialiaseds">[docs]</a>    <span class="k">def</span> <span class="nf">set_antialiaseds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aa</span><span class="p">):</span>
        <span class="sd">"""alias for set_antialiased"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_antialiased</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_color"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_color">[docs]</a>    <span class="k">def</span> <span class="nf">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set both the edgecolor and the facecolor.</span>

<span class="sd">        ACCEPTS: matplotlib color arg or sequence of rgba tuples</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`set_facecolor`, :meth:`set_edgecolor`</span>
<span class="sd">               For setting the edge or face color individually.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_facecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'patch.facecolor'</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'none'</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Collection.set_facecolor"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_facecolor">[docs]</a>    <span class="k">def</span> <span class="nf">set_facecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the facecolor(s) of the collection.  *c* can be a</span>
<span class="sd">        matplotlib color spec (all patches have same color), or a</span>
<span class="sd">        sequence of specs; if it is a sequence the patches will</span>
<span class="sd">        cycle through the sequence.</span>

<span class="sd">        If *c* is 'none', the patch will not be filled.</span>

<span class="sd">        ACCEPTS: matplotlib color spec or sequence of specs</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_facecolor</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_facecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_facecolors"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_facecolors">[docs]</a>    <span class="k">def</span> <span class="nf">set_facecolors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">"""alias for set_facecolor"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_facecolor"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_facecolor">[docs]</a>    <span class="k">def</span> <span class="nf">get_facecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span></div>
    <span class="n">get_facecolors</span> <span class="o">=</span> <span class="n">get_facecolor</span>

<div class="viewcode-block" id="Collection.get_edgecolor"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_edgecolor">[docs]</a>    <span class="k">def</span> <span class="nf">get_edgecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span>
                   <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="s1">'face'</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolors</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span></div>
    <span class="n">get_edgecolors</span> <span class="o">=</span> <span class="n">get_edgecolor</span>

    <span class="k">def</span> <span class="nf">_set_edgecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="n">set_hatch_color</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'patch.force_edgecolor'</span><span class="p">]</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_default</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'patch.edgecolor'</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="s1">'none'</span>
                <span class="n">set_hatch_color</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_stroked</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'none'</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_stroked</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'face'</span><span class="p">:</span>   <span class="c1"># Special case: lookup in "get" method.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">=</span> <span class="s1">'face'</span>
                <span class="k">return</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set_hatch_color</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hatch_color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Collection.set_edgecolor"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_edgecolor">[docs]</a>    <span class="k">def</span> <span class="nf">set_edgecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the edgecolor(s) of the collection. *c* can be a</span>
<span class="sd">        matplotlib color spec (all patches have same color), or a</span>
<span class="sd">        sequence of specs; if it is a sequence the patches will</span>
<span class="sd">        cycle through the sequence.</span>

<span class="sd">        If *c* is 'face', the edge color will always be the same as</span>
<span class="sd">        the face color.  If it is 'none', the patch boundary will not</span>
<span class="sd">        be drawn.</span>

<span class="sd">        ACCEPTS: matplotlib color spec or sequence of specs</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_edgecolor</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edgecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_edgecolors"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_edgecolors">[docs]</a>    <span class="k">def</span> <span class="nf">set_edgecolors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">"""alias for set_edgecolor"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_alpha"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the alpha tranparencies of the collection.  *alpha* must be</span>
<span class="sd">        a float or *None*.</span>

<span class="sd">        ACCEPTS: float or None</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'alpha must be a float or None'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_dict</span><span class="p">[</span><span class="s1">'array'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">artist</span><span class="o">.</span><span class="n">Artist</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_facecolor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_facecolor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edgecolor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_edgecolor</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_linewidths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_linewidths">[docs]</a>    <span class="k">def</span> <span class="nf">get_linewidths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span></div>
    <span class="n">get_linewidth</span> <span class="o">=</span> <span class="n">get_linewidths</span>

<div class="viewcode-block" id="Collection.get_linestyles"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_linestyles">[docs]</a>    <span class="k">def</span> <span class="nf">get_linestyles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span></div>
    <span class="n">get_dashes</span> <span class="o">=</span> <span class="n">get_linestyle</span> <span class="o">=</span> <span class="n">get_linestyles</span>

<div class="viewcode-block" id="Collection.update_scalarmappable"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.update_scalarmappable">[docs]</a>    <span class="k">def</span> <span class="nf">update_scalarmappable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        If the scalar mappable array is not none, update colors</span>
<span class="sd">        from scalar data</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Collections can only map rank 1 arrays'</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_update</span><span class="p">(</span><span class="s2">"array"</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stroked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_fill"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_fill">[docs]</a>    <span class="k">def</span> <span class="nf">get_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">'return whether fill is set'</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span></div>

<div class="viewcode-block" id="Collection.update_from"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.update_from">[docs]</a>    <span class="k">def</span> <span class="nf">update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="s1">'copy properties from other to self'</span>

        <span class="n">artist</span><span class="o">.</span><span class="n">Artist</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_antialiaseds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_edgecolor</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_original_edgecolor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_edgecolors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_facecolor</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_original_facecolor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_facecolors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_linewidths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_linestyles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_us_linestyles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pickradius</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_pickradius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_hatch</span>

        <span class="c1"># update_from for scalarmappable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">cmap</span>
        <span class="c1"># self.update_dict = other.update_dict # do we need to copy this? -JJL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div></div>

<span class="c1"># these are not available for the object inspector until after the</span>
<span class="c1"># class is built so we define an initial set here for the init</span>
<span class="c1"># function and they will be overridden after object defn</span>
<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Collection</span><span class="o">=</span><span class="s2">"""</span><span class="se">\</span>
<span class="s2">    Valid Collection keyword arguments:</span>

<span class="s2">        * *edgecolors*: None</span>
<span class="s2">        * *facecolors*: None</span>
<span class="s2">        * *linewidths*: None</span>
<span class="s2">        * *antialiaseds*: None</span>
<span class="s2">        * *offsets*: None</span>
<span class="s2">        * *transOffset*: transforms.IdentityTransform()</span>
<span class="s2">        * *norm*: None (optional for</span>
<span class="s2">          :class:`matplotlib.cm.ScalarMappable`)</span>
<span class="s2">        * *cmap*: None (optional for</span>
<span class="s2">          :class:`matplotlib.cm.ScalarMappable`)</span>

<span class="s2">    *offsets* and *transOffset* are used to translate the patch after</span>
<span class="s2">    rendering (default no offsets)</span>

<span class="s2">    If any of *edgecolors*, *facecolors*, *linewidths*, *antialiaseds*</span>
<span class="s2">    are None, they default to their :data:`matplotlib.rcParams` patch</span>
<span class="s2">    setting, in sequence form.</span>
<span class="s2">"""</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_CollectionWithSizes</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Base class for collections that have an array of sizes.</span>
<span class="sd">    """</span>
    <span class="n">_factor</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">def</span> <span class="nf">get_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the sizes of the elements in the collection.  The</span>
<span class="sd">        value represents the 'area' of the element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sizes : array</span>
<span class="sd">            The 'area' of each element.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span>

    <span class="k">def</span> <span class="nf">set_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mf">72.0</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the sizes of each member of the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sizes : ndarray or None</span>
<span class="sd">            The size to set for each element of the collection.  The</span>
<span class="sd">            value is the 'area' of the element.</span>

<span class="sd">        dpi : float</span>
<span class="sd">            The dpi of the canvas. Defaults to 72.0.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="p">)</span> <span class="o">*</span> <span class="n">dpi</span> <span class="o">/</span> <span class="mf">72.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">Collection</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span>


<div class="viewcode-block" id="PathCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PathCollection">[docs]</a><span class="k">class</span> <span class="nc">PathCollection</span><span class="p">(</span><span class="n">_CollectionWithSizes</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    This is the most basic :class:`Collection` subclass.</span>
<span class="sd">    """</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        *paths* is a sequence of :class:`matplotlib.path.Path`</span>
<span class="sd">        instances.</span>

<span class="sd">        %(Collection)s</span>
<span class="sd">        """</span>

        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_paths</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="PathCollection.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PathCollection.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="n">paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="PathCollection.get_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PathCollection.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span></div></div>


<div class="viewcode-block" id="PolyCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PolyCollection">[docs]</a><span class="k">class</span> <span class="nc">PolyCollection</span><span class="p">(</span><span class="n">_CollectionWithSizes</span><span class="p">):</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        *verts* is a sequence of ( *verts0*, *verts1*, ...) where</span>
<span class="sd">        *verts_i* is a sequence of *xy* tuples of vertices, or an</span>
<span class="sd">        equivalent :mod:`numpy` array of shape (*nv*, 2).</span>

<span class="sd">        *sizes* is *None* (default) or a sequence of floats that</span>
<span class="sd">        scale the corresponding *verts_i*.  The scaling is applied</span>
<span class="sd">        before the Artist master transform; if the latter is an identity</span>
<span class="sd">        transform, then the overall scaling is such that if</span>
<span class="sd">        *verts_i* specify a unit square, then *sizes_i* is the area</span>
<span class="sd">        of that square in points^2.</span>
<span class="sd">        If len(*sizes*) &lt; *nv*, the additional values will be</span>
<span class="sd">        taken cyclically from the array.</span>

<span class="sd">        *closed*, when *True*, will explicitly close the polygon.</span>

<span class="sd">        %(Collection)s</span>
<span class="sd">        """</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_verts</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">closed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="PolyCollection.set_verts"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PolyCollection.set_verts">[docs]</a>    <span class="k">def</span> <span class="nf">set_verts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">'''This allows one to delay initialization of the vertices.'''</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="n">verts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="c1"># This is much faster than having Path do it one at a time.</span>
        <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xy</span><span class="p">,</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
                        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xy</span><span class="p">,</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">code_type</span><span class="p">)</span>
                    <span class="n">codes</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span>
                    <span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span>
                    <span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">CLOSEPOLY</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">codes</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="n">set_paths</span> <span class="o">=</span> <span class="n">set_verts</span>

<div class="viewcode-block" id="PolyCollection.set_verts_and_codes"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PolyCollection.set_verts_and_codes">[docs]</a>    <span class="k">def</span> <span class="nf">set_verts_and_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
        <span class="sd">'''This allows one to initialize vertices with path codes.'''</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'codes' must be a 1D list or array "</span>
                             <span class="s2">"with the same length of 'verts'"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xy</span><span class="p">,</span> <span class="n">cds</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">cds</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="BrokenBarHCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.BrokenBarHCollection">[docs]</a><span class="k">class</span> <span class="nc">BrokenBarHCollection</span><span class="p">(</span><span class="n">PolyCollection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A collection of horizontal bars spanning *yrange* with a sequence of</span>
<span class="sd">    *xranges*.</span>
<span class="sd">    """</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xranges</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        *xranges*</span>
<span class="sd">            sequence of (*xmin*, *xwidth*)</span>

<span class="sd">        *yrange*</span>
<span class="sd">            *ymin*, *ywidth*</span>

<span class="sd">        %(Collection)s</span>
<span class="sd">        """</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ywidth</span> <span class="o">=</span> <span class="n">yrange</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">ymin</span> <span class="o">+</span> <span class="n">ywidth</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="n">xwidth</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="n">xwidth</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)]</span> <span class="k">for</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xwidth</span> <span class="ow">in</span> <span class="n">xranges</span><span class="p">]</span>
        <span class="n">PolyCollection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="BrokenBarHCollection.span_where"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.BrokenBarHCollection.span_where">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">span_where</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a BrokenBarHCollection to plot horizontal bars from</span>
<span class="sd">        over the regions in *x* where *where* is True.  The bars range</span>
<span class="sd">        on the y-axis from *ymin* to *ymax*</span>

<span class="sd">        A :class:`BrokenBarHCollection` is returned.  *kwargs* are</span>
<span class="sd">        passed on to the collection.</span>
<span class="sd">        """</span>
        <span class="n">xranges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">xslice</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">xranges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">xslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xslice</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">BrokenBarHCollection</span><span class="p">(</span>
            <span class="n">xranges</span><span class="p">,</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span></div></div>


<div class="viewcode-block" id="RegularPolyCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.RegularPolyCollection">[docs]</a><span class="k">class</span> <span class="nc">RegularPolyCollection</span><span class="p">(</span><span class="n">_CollectionWithSizes</span><span class="p">):</span>
    <span class="sd">"""Draw a collection of regular polygons with *numsides*."""</span>
    <span class="n">_path_generator</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_regular_polygon</span>

    <span class="n">_factor</span> <span class="o">=</span> <span class="n">CIRCLE_AREA_FACTOR</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">numsides</span><span class="p">,</span>
                 <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        *numsides*</span>
<span class="sd">            the number of sides of the polygon</span>

<span class="sd">        *rotation*</span>
<span class="sd">            the rotation of the polygon in radians</span>

<span class="sd">        *sizes*</span>
<span class="sd">            gives the area of the circle circumscribing the</span>
<span class="sd">            regular polygon in points^2</span>

<span class="sd">        %(Collection)s</span>

<span class="sd">        Example: see :file:`examples/dynamic_collection.py` for</span>
<span class="sd">        complete example::</span>

<span class="sd">            offsets = np.random.rand(20,2)</span>
<span class="sd">            facecolors = [cm.jet(x) for x in np.random.rand(20)]</span>
<span class="sd">            black = (0,0,0,1)</span>

<span class="sd">            collection = RegularPolyCollection(</span>
<span class="sd">                numsides=5, # a pentagon</span>
<span class="sd">                rotation=0, sizes=(50,),</span>
<span class="sd">                facecolors = facecolors,</span>
<span class="sd">                edgecolors = (black,),</span>
<span class="sd">                linewidths = (1,),</span>
<span class="sd">                offsets = offsets,</span>
<span class="sd">                transOffset = ax.transData,</span>
<span class="sd">                )</span>
<span class="sd">        """</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_numsides</span> <span class="o">=</span> <span class="n">numsides</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_path_generator</span><span class="p">(</span><span class="n">numsides</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="o">=</span> <span class="n">rotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>

<div class="viewcode-block" id="RegularPolyCollection.get_numsides"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.RegularPolyCollection.get_numsides">[docs]</a>    <span class="k">def</span> <span class="nf">get_numsides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_numsides</span></div>

<div class="viewcode-block" id="RegularPolyCollection.get_rotation"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.RegularPolyCollection.get_rotation">[docs]</a>    <span class="k">def</span> <span class="nf">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span></div>

<div class="viewcode-block" id="RegularPolyCollection.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.RegularPolyCollection.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">Affine2D</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="p">)</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span>
        <span class="p">]</span>
        <span class="n">Collection</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StarPolygonCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.StarPolygonCollection">[docs]</a><span class="k">class</span> <span class="nc">StarPolygonCollection</span><span class="p">(</span><span class="n">RegularPolyCollection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Draw a collection of regular stars with *numsides* points."""</span>

    <span class="n">_path_generator</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_regular_star</span></div>


<div class="viewcode-block" id="AsteriskPolygonCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.AsteriskPolygonCollection">[docs]</a><span class="k">class</span> <span class="nc">AsteriskPolygonCollection</span><span class="p">(</span><span class="n">RegularPolyCollection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Draw a collection of regular asterisks with *numsides* points."""</span>

    <span class="n">_path_generator</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_regular_asterisk</span></div>


<div class="viewcode-block" id="LineCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection">[docs]</a><span class="k">class</span> <span class="nc">LineCollection</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    All parameters must be sequences or scalars; if scalars, they will</span>
<span class="sd">    be converted to sequences.  The property of the ith line</span>
<span class="sd">    segment is::</span>

<span class="sd">       prop[i % len(props)]</span>

<span class="sd">    i.e., the properties cycle if the ``len`` of props is less than the</span>
<span class="sd">    number of segments.</span>
<span class="sd">    """</span>

    <span class="n">_edge_default</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span>     <span class="c1"># Can be None.</span>
                 <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">antialiaseds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">linestyles</span><span class="o">=</span><span class="s1">'solid'</span><span class="p">,</span>
                 <span class="n">offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transOffset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pickradius</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">facecolors</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segments :</span>
<span class="sd">            A sequence of (*line0*, *line1*, *line2*), where::</span>

<span class="sd">                linen = (x0, y0), (x1, y1), ... (xm, ym)</span>

<span class="sd">            or the equivalent numpy array with two columns. Each line</span>
<span class="sd">            can be a different length.</span>

<span class="sd">        colors : sequence, optional</span>
<span class="sd">            A sequence of RGBA tuples (e.g., arbitrary color</span>
<span class="sd">            strings, etc, not allowed).</span>

<span class="sd">        antialiaseds : sequence, optional</span>
<span class="sd">            A sequence of ones or zeros.</span>

<span class="sd">        linestyles : string, tuple, optional</span>
<span class="sd">            Either one of [ 'solid' | 'dashed' | 'dashdot' | 'dotted' ], or</span>
<span class="sd">            a dash tuple. The dash tuple is::</span>

<span class="sd">                (offset, onoffseq)</span>

<span class="sd">            where ``onoffseq`` is an even length tuple of on and off ink</span>
<span class="sd">            in points.</span>

<span class="sd">        norm : Normalize, optional</span>
<span class="sd">            `~.colors.Normalize` instance.</span>

<span class="sd">        cmap : string or Colormap, optional</span>
<span class="sd">            Colormap name or `~.colors.Colormap` instance.</span>

<span class="sd">        pickradius : float, optional</span>
<span class="sd">            The tolerance in points for mouse clicks picking a line.</span>
<span class="sd">            Default is 5 pt.</span>

<span class="sd">        zorder : int, optional</span>
<span class="sd">           zorder of the LineCollection. Default is 2.</span>

<span class="sd">        facecolors : optional</span>
<span class="sd">           The facecolors of the LineCollection. Default is 'none'.</span>
<span class="sd">           Setting to a value other than 'none' will lead to a filled</span>
<span class="sd">           polygon being drawn between points on each line.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If *linewidths*, *colors*, or *antialiaseds* is None, they</span>
<span class="sd">        default to their rcParams setting, in sequence form.</span>

<span class="sd">        If *offsets* and *transOffset* are not None, then</span>
<span class="sd">        *offsets* are transformed by *transOffset* and applied after</span>
<span class="sd">        the segments have been transformed to display coordinates.</span>

<span class="sd">        If *offsets* is not None but *transOffset* is None, then the</span>
<span class="sd">        *offsets* are added to the segments before any transformation.</span>
<span class="sd">        In this case, a single offset can be specified as::</span>

<span class="sd">            offsets=(xo,yo)</span>

<span class="sd">        and this value will be added cumulatively to each successive</span>
<span class="sd">        segment, so as to produce a set of successively offset curves.</span>

<span class="sd">        The use of :class:`~matplotlib.cm.ScalarMappable` is optional.</span>
<span class="sd">        If the :class:`~matplotlib.cm.ScalarMappable` array</span>
<span class="sd">        :attr:`~matplotlib.cm.ScalarMappable._A` is not None (i.e., a call to</span>
<span class="sd">        :meth:`~matplotlib.cm.ScalarMappable.set_array` has been made), at</span>
<span class="sd">        draw time a call to scalar mappable will be made to set the colors.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'lines.color'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'lines.linewidth'</span><span class="p">],)</span>
        <span class="k">if</span> <span class="n">antialiaseds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">antialiaseds</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'lines.antialiased'</span><span class="p">],)</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
            <span class="n">facecolors</span><span class="o">=</span><span class="n">facecolors</span><span class="p">,</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
            <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span>
            <span class="n">antialiaseds</span><span class="o">=</span><span class="n">antialiaseds</span><span class="p">,</span>
            <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
            <span class="n">transOffset</span><span class="o">=</span><span class="n">transOffset</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">pickradius</span><span class="o">=</span><span class="n">pickradius</span><span class="p">,</span>
            <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>

<div class="viewcode-block" id="LineCollection.set_segments"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection.set_segments">[docs]</a>    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">segments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">_segments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_offsets</span><span class="p">(</span><span class="n">_segments</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">_seg</span><span class="p">)</span> <span class="k">for</span> <span class="n">_seg</span> <span class="ow">in</span> <span class="n">_segments</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="n">set_verts</span> <span class="o">=</span> <span class="n">set_segments</span>  <span class="c1"># for compatibility with PolyCollection</span>
    <span class="n">set_paths</span> <span class="o">=</span> <span class="n">set_segments</span>

<div class="viewcode-block" id="LineCollection.get_segments"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        segments : list</span>
<span class="sd">            List of segments in the LineCollection. Each list item contains an</span>
<span class="sd">            array of vertices.</span>
<span class="sd">        """</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertex</span> <span class="k">for</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">iter_segments</span><span class="p">()]</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">segments</span></div>

    <span class="k">def</span> <span class="nf">_add_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segs</span><span class="p">):</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span>
        <span class="n">Nsegs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="n">Noffs</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">Noffs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsegs</span><span class="p">):</span>
                <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">offsets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsegs</span><span class="p">):</span>
                <span class="n">io</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">Noffs</span>
                <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">io</span><span class="p">:</span><span class="n">io</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">segs</span>

<div class="viewcode-block" id="LineCollection.set_color"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection.set_color">[docs]</a>    <span class="k">def</span> <span class="nf">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the color(s) of the LineCollection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c :</span>
<span class="sd">            Matplotlib color argument (all patches have same color), or a</span>
<span class="sd">            sequence or rgba tuples; if it is a sequence the patches will</span>
<span class="sd">            cycle through the sequence.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="LineCollection.get_color"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection.get_color">[docs]</a>    <span class="k">def</span> <span class="nf">get_color</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span></div>

    <span class="n">get_colors</span> <span class="o">=</span> <span class="n">get_color</span>  <span class="c1"># for compatibility with old versions</span></div>


<div class="viewcode-block" id="EventCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection">[docs]</a><span class="k">class</span> <span class="nc">EventCollection</span><span class="p">(</span><span class="n">LineCollection</span><span class="p">):</span>
    <span class="sd">'''</span>
<span class="sd">    A collection of discrete events.</span>

<span class="sd">    The events are given by a 1-dimensional array, usually the position of</span>
<span class="sd">    something along an axis, such as time or length.  They do not have an</span>
<span class="sd">    amplitude and are displayed as vertical or horizontal parallel bars.</span>
<span class="sd">    '''</span>

    <span class="n">_edge_default</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">positions</span><span class="p">,</span>     <span class="c1"># Cannot be None.</span>
                 <span class="n">orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">lineoffset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">linelength</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">linestyle</span><span class="o">=</span><span class="s1">'solid'</span><span class="p">,</span>
                 <span class="n">antialiased</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions : 1D array-like object</span>
<span class="sd">            Each value is an event.</span>

<span class="sd">        orientation : {None, 'horizontal', 'vertical'}, optional</span>
<span class="sd">            The orientation of the **collection** (the event bars are along</span>
<span class="sd">            the orthogonal direction). Defaults to 'horizontal' if not</span>
<span class="sd">            specified or None.</span>

<span class="sd">        lineoffset : scalar, optional, default: 0</span>
<span class="sd">            The offset of the center of the markers from the origin, in the</span>
<span class="sd">            direction orthogonal to *orientation*.</span>

<span class="sd">        linelength : scalar, optional, default: 1</span>
<span class="sd">            The total height of the marker (i.e. the marker stretches from</span>
<span class="sd">            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).</span>

<span class="sd">        linewidth : scalar or None, optional, default: None</span>
<span class="sd">            If it is None, defaults to its rcParams setting, in sequence form.</span>

<span class="sd">        color : color, sequence of colors or None, optional, default: None</span>
<span class="sd">            If it is None, defaults to its rcParams setting, in sequence form.</span>

<span class="sd">        linestyle : str or tuple, optional, default: 'solid'</span>
<span class="sd">            Valid strings are ['solid', 'dashed', 'dashdot', 'dotted',</span>
<span class="sd">            '-', '--', '-.', ':']. Dash tuples should be of the form::</span>

<span class="sd">                (offset, onoffseq),</span>

<span class="sd">            where *onoffseq* is an even length tuple of on and off ink</span>
<span class="sd">            in points.</span>

<span class="sd">        antialiased : {None, 1, 2}, optional</span>
<span class="sd">            If it is None, defaults to its rcParams setting, in sequence form.</span>

<span class="sd">        **kwargs : optional</span>
<span class="sd">            Other keyword arguments are line collection properties.  See</span>
<span class="sd">            :class:`~matplotlib.collections.LineCollection` for a list of</span>
<span class="sd">            the valid properties.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: gallery/lines_bars_and_markers/eventcollection_demo.py</span>
<span class="sd">        """</span>

        <span class="n">segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffset</span> <span class="o">+</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                   <span class="n">lineoffset</span> <span class="o">-</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="s1">'ndim'</span><span class="p">)</span> <span class="ow">and</span> <span class="n">positions</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'positions cannot be an array with more than '</span>
                             <span class="s1">'one dimension.'</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">orientation</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'none'</span> <span class="ow">or</span>
              <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">):</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord2</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">]</span> <span class="k">for</span>
                        <span class="n">coord1</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_horizontal</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">coord2</span><span class="p">,</span> <span class="n">coord1</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord2</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">]</span> <span class="k">for</span>
                        <span class="n">coord1</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_horizontal</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"orientation must be 'horizontal' or 'vertical'"</span><span class="p">)</span>

        <span class="n">LineCollection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">segments</span><span class="p">,</span>
                                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
                                <span class="n">colors</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                <span class="n">antialiaseds</span><span class="o">=</span><span class="n">antialiased</span><span class="p">,</span>
                                <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_linelength</span> <span class="o">=</span> <span class="n">linelength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lineoffset</span> <span class="o">=</span> <span class="n">lineoffset</span>

<div class="viewcode-block" id="EventCollection.get_positions"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_positions">[docs]</a>    <span class="k">def</span> <span class="nf">get_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        return an array containing the floating-point values of the positions</span>
<span class="sd">        '''</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">positions</span></div>

<div class="viewcode-block" id="EventCollection.set_positions"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.set_positions">[docs]</a>    <span class="k">def</span> <span class="nf">set_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        set the positions of the events to the specified value</span>
<span class="sd">        '''</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="s1">'len'</span><span class="p">)</span> <span class="ow">and</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">([])</span>
            <span class="k">return</span>

        <span class="n">lineoffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lineoffset</span><span class="p">()</span>
        <span class="n">linelength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linelength</span><span class="p">()</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffset</span> <span class="o">+</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                   <span class="n">lineoffset</span> <span class="o">-</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">positions</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">():</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord2</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">]</span> <span class="k">for</span>
                        <span class="n">coord1</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">coord2</span><span class="p">,</span> <span class="n">coord1</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord2</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">]</span> <span class="k">for</span>
                        <span class="n">coord1</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventCollection.add_positions"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.add_positions">[docs]</a>    <span class="k">def</span> <span class="nf">add_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        add one or more events at the specified positions</span>
<span class="sd">        '''</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="s1">'len'</span><span class="p">)</span> <span class="ow">and</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">positions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">position</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span></div>
    <span class="n">extend_positions</span> <span class="o">=</span> <span class="n">append_positions</span> <span class="o">=</span> <span class="n">add_positions</span>

<div class="viewcode-block" id="EventCollection.is_horizontal"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.is_horizontal">[docs]</a>    <span class="k">def</span> <span class="nf">is_horizontal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        True if the eventcollection is horizontal, False if vertical</span>
<span class="sd">        '''</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_horizontal</span></div>

<div class="viewcode-block" id="EventCollection.get_orientation"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">get_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        get the orientation of the event line, may be:</span>
<span class="sd">        [ 'horizontal' | 'vertical' ]</span>
<span class="sd">        '''</span>
        <span class="k">return</span> <span class="s1">'horizontal'</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="s1">'vertical'</span></div>

<div class="viewcode-block" id="EventCollection.switch_orientation"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.switch_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">switch_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        switch the orientation of the event line, either from vertical to</span>
<span class="sd">        horizontal or vice versus</span>
<span class="sd">        '''</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
            <span class="n">segments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_horizontal</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="EventCollection.set_orientation"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.set_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">set_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        set the orientation of the event line</span>
<span class="sd">        [ 'horizontal' | 'vertical' | None ]</span>
<span class="sd">        defaults to 'horizontal' if not specified or None</span>
<span class="sd">        '''</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">orientation</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'none'</span> <span class="ow">or</span>
                <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">):</span>
            <span class="n">is_horizontal</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
            <span class="n">is_horizontal</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"orientation must be 'horizontal' or 'vertical'"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_horizontal</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">switch_orientation</span><span class="p">()</span></div>

<div class="viewcode-block" id="EventCollection.get_linelength"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_linelength">[docs]</a>    <span class="k">def</span> <span class="nf">get_linelength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        get the length of the lines used to mark each event</span>
<span class="sd">        '''</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linelength</span></div>

<div class="viewcode-block" id="EventCollection.set_linelength"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.set_linelength">[docs]</a>    <span class="k">def</span> <span class="nf">set_linelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linelength</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        set the length of the lines used to mark each event</span>
<span class="sd">        '''</span>
        <span class="k">if</span> <span class="n">linelength</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linelength</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">lineoffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lineoffset</span><span class="p">()</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">+</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">-</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linelength</span> <span class="o">=</span> <span class="n">linelength</span></div>

<div class="viewcode-block" id="EventCollection.get_lineoffset"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_lineoffset">[docs]</a>    <span class="k">def</span> <span class="nf">get_lineoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        get the offset of the lines used to mark each event</span>
<span class="sd">        '''</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lineoffset</span></div>

<div class="viewcode-block" id="EventCollection.set_lineoffset"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.set_lineoffset">[docs]</a>    <span class="k">def</span> <span class="nf">set_lineoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lineoffset</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        set the offset of the lines used to mark each event</span>
<span class="sd">        '''</span>
        <span class="k">if</span> <span class="n">lineoffset</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lineoffset</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">linelength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linelength</span><span class="p">()</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">+</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">-</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lineoffset</span> <span class="o">=</span> <span class="n">lineoffset</span></div>

<div class="viewcode-block" id="EventCollection.get_linewidth"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_linewidth">[docs]</a>    <span class="k">def</span> <span class="nf">get_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        get the width of the lines used to mark each event</span>
<span class="sd">        '''</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linewidths</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="EventCollection.get_linestyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_linestyle">[docs]</a>    <span class="k">def</span> <span class="nf">get_linestyle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        get the style of the lines used to mark each event</span>
<span class="sd">        [ 'solid' | 'dashed' | 'dashdot' | 'dotted' ]</span>
<span class="sd">        '''</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linestyles</span><span class="p">()</span></div>

<div class="viewcode-block" id="EventCollection.get_color"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_color">[docs]</a>    <span class="k">def</span> <span class="nf">get_color</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        get the color of the lines used to mark each event</span>
<span class="sd">        '''</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_colors</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="CircleCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.CircleCollection">[docs]</a><span class="k">class</span> <span class="nc">CircleCollection</span><span class="p">(</span><span class="n">_CollectionWithSizes</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A collection of circles, drawn using splines.</span>
<span class="sd">    """</span>
    <span class="n">_factor</span> <span class="o">=</span> <span class="n">CIRCLE_AREA_FACTOR</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        *sizes*</span>
<span class="sd">            Gives the area of the circle in points^2</span>

<span class="sd">        %(Collection)s</span>
<span class="sd">        """</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_circle</span><span class="p">()]</span></div>


<div class="viewcode-block" id="EllipseCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EllipseCollection">[docs]</a><span class="k">class</span> <span class="nc">EllipseCollection</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A collection of ellipses, drawn using splines.</span>
<span class="sd">    """</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">'points'</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        *widths*: sequence</span>
<span class="sd">            lengths of first axes (e.g., major axis lengths)</span>

<span class="sd">        *heights*: sequence</span>
<span class="sd">            lengths of second axes</span>

<span class="sd">        *angles*: sequence</span>
<span class="sd">            angles of first axes, degrees CCW from the X-axis</span>

<span class="sd">        *units*: ['points' | 'inches' | 'dots' | 'width' | 'height'</span>
<span class="sd">        | 'x' | 'y' | 'xy']</span>

<span class="sd">            units in which majors and minors are given; 'width' and</span>
<span class="sd">            'height' refer to the dimensions of the axes, while 'x'</span>
<span class="sd">            and 'y' refer to the *offsets* data units. 'xy' differs</span>
<span class="sd">            from all others in that the angle as plotted varies with</span>
<span class="sd">            the aspect ratio, and equals the specified angle only when</span>
<span class="sd">            the aspect ratio is unity.  Hence it behaves the same as</span>
<span class="sd">            the :class:`~matplotlib.patches.Ellipse` with</span>
<span class="sd">            axes.transData as its transform.</span>

<span class="sd">        Additional kwargs inherited from the base :class:`Collection`:</span>

<span class="sd">        %(Collection)s</span>
<span class="sd">        """</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_heights</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_circle</span><span class="p">()]</span>

    <span class="k">def</span> <span class="nf">_set_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Calculate transforms immediately before drawing.</span>
<span class="sd">        """</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'xy'</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'x'</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">ax</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">width</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'y'</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">ax</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">height</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'inches'</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">dpi</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'points'</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">dpi</span> <span class="o">/</span> <span class="mf">72.0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'width'</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'height'</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">height</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'dots'</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'unrecognized units: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_widths</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">*</span> <span class="n">sc</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_heights</span> <span class="o">*</span> <span class="n">sc</span>
        <span class="n">sin_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span>
        <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths</span> <span class="o">*</span> <span class="n">cos_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heights</span> <span class="o">*</span> <span class="o">-</span><span class="n">sin_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths</span> <span class="o">*</span> <span class="n">sin_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heights</span> <span class="o">*</span> <span class="n">cos_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">_affine</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Affine2D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">'xy'</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">m</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">_affine</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>

<div class="viewcode-block" id="EllipseCollection.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EllipseCollection.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_transforms</span><span class="p">()</span>
        <span class="n">Collection</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PatchCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PatchCollection">[docs]</a><span class="k">class</span> <span class="nc">PatchCollection</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A generic collection of patches.</span>

<span class="sd">    This makes it easier to assign a color map to a heterogeneous</span>
<span class="sd">    collection of patches.</span>

<span class="sd">    This also may improve plotting speed, since PatchCollection will</span>
<span class="sd">    draw faster than a large number of patches.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">match_original</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        *patches*</span>
<span class="sd">            a sequence of Patch objects.  This list may include</span>
<span class="sd">            a heterogeneous assortment of different patch types.</span>

<span class="sd">        *match_original*</span>
<span class="sd">            If True, use the colors and linewidths of the original</span>
<span class="sd">            patches.  If False, new colors may be assigned by</span>
<span class="sd">            providing the standard collection arguments, facecolor,</span>
<span class="sd">            edgecolor, linewidths, norm or cmap.</span>

<span class="sd">        If any of *edgecolors*, *facecolors*, *linewidths*,</span>
<span class="sd">        *antialiaseds* are None, they default to their</span>
<span class="sd">        :data:`matplotlib.rcParams` patch setting, in sequence form.</span>

<span class="sd">        The use of :class:`~matplotlib.cm.ScalarMappable` is optional.</span>
<span class="sd">        If the :class:`~matplotlib.cm.ScalarMappable` matrix _A is not</span>
<span class="sd">        None (i.e., a call to set_array has been made), at draw time a</span>
<span class="sd">        call to scalar mappable will be made to set the face colors.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">match_original</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">determine_facecolor</span><span class="p">(</span><span class="n">patch</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">patch</span><span class="o">.</span><span class="n">get_fill</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">patch</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'facecolors'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">determine_facecolor</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'edgecolors'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_edgecolor</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'linewidths'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'linestyles'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_linestyle</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'antialiaseds'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_antialiased</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>

        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_paths</span><span class="p">(</span><span class="n">patches</span><span class="p">)</span>

<div class="viewcode-block" id="PatchCollection.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PatchCollection.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patches</span><span class="p">):</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span><span class="o">.</span><span class="n">transform_path</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">get_path</span><span class="p">())</span>
                 <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="n">paths</span></div></div>


<div class="viewcode-block" id="TriMesh"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh">[docs]</a><span class="k">class</span> <span class="nc">TriMesh</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Class for the efficient drawing of a triangular mesh using</span>
<span class="sd">    Gouraud shading.</span>

<span class="sd">    A triangular mesh is a :class:`~matplotlib.tri.Triangulation`</span>
<span class="sd">    object.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triangulation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_triangulation</span> <span class="o">=</span> <span class="n">triangulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading</span> <span class="o">=</span> <span class="s1">'gouraud'</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>

        <span class="c1"># Unfortunately this requires a copy, unless Triangulation</span>
        <span class="c1"># was rewritten.</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">triangulation</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                        <span class="n">triangulation</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>

<div class="viewcode-block" id="TriMesh.get_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_paths</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span></div>

<div class="viewcode-block" id="TriMesh.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_mesh_to_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_triangulation</span><span class="p">)</span></div>

<div class="viewcode-block" id="TriMesh.convert_mesh_to_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh.convert_mesh_to_paths">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_mesh_to_paths</span><span class="p">(</span><span class="n">tri</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Converts a given mesh into a sequence of</span>
<span class="sd">        :class:`matplotlib.path.Path` objects for easier rendering by</span>
<span class="sd">        backends that do not directly support meshes.</span>

<span class="sd">        This function is primarily of use to backend implementers.</span>
<span class="sd">        """</span>
        <span class="n">Path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">get_masked_triangles</span><span class="p">()</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tri</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">triangles</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">tri</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">triangles</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriMesh.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>

        <span class="c1"># Get a list of triangles and the color at each vertex.</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_triangulation</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">get_masked_triangles</span><span class="p">()</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tri</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">triangles</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">tri</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">triangles</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_scalarmappable</span><span class="p">()</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span><span class="p">[</span><span class="n">triangles</span><span class="p">]</span>

        <span class="n">gc</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">new_gc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_gc_clip</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">draw_gouraud_triangles</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">close_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="QuadMesh"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh">[docs]</a><span class="k">class</span> <span class="nc">QuadMesh</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Class for the efficient drawing of a quadrilateral mesh.</span>

<span class="sd">    A quadrilateral mesh consists of a grid of vertices. The</span>
<span class="sd">    dimensions of this array are (*meshWidth* + 1, *meshHeight* +</span>
<span class="sd">    1). Each vertex in the mesh has a different set of "mesh</span>
<span class="sd">    coordinates" representing its position in the topology of the</span>
<span class="sd">    mesh. For any values (*m*, *n*) such that 0 &lt;= *m* &lt;= *meshWidth*</span>
<span class="sd">    and 0 &lt;= *n* &lt;= *meshHeight*, the vertices at mesh coordinates</span>
<span class="sd">    (*m*, *n*), (*m*, *n* + 1), (*m* + 1, *n* + 1), and (*m* + 1, *n*)</span>
<span class="sd">    form one of the quadrilaterals in the mesh. There are thus</span>
<span class="sd">    (*meshWidth* * *meshHeight*) quadrilaterals in the mesh.  The mesh</span>
<span class="sd">    need not be regular and the polygons need not be convex.</span>

<span class="sd">    A quadrilateral mesh is represented by a (2 x ((*meshWidth* + 1) *</span>
<span class="sd">    (*meshHeight* + 1))) numpy array *coordinates*, where each row is</span>
<span class="sd">    the *x* and *y* coordinates of one of the vertices.  To define the</span>
<span class="sd">    function that maps from a data point to its corresponding color,</span>
<span class="sd">    use the :meth:`set_cmap` method.  Each of these arrays is indexed in</span>
<span class="sd">    row-major order by the mesh coordinates of the vertex (or the mesh</span>
<span class="sd">    coordinates of the lower left vertex, in the case of the</span>
<span class="sd">    colors).</span>

<span class="sd">    For example, the first entry in *coordinates* is the</span>
<span class="sd">    coordinates of the vertex at mesh coordinates (0, 0), then the one</span>
<span class="sd">    at (0, 1), then at (0, 2) .. (0, meshWidth), (1, 0), (1, 1), and</span>
<span class="sd">    so on.</span>

<span class="sd">    *shading* may be 'flat', or 'gouraud'</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshWidth</span><span class="p">,</span> <span class="n">meshHeight</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                 <span class="n">antialiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s1">'flat'</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meshWidth</span> <span class="o">=</span> <span class="n">meshWidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meshHeight</span> <span class="o">=</span> <span class="n">meshHeight</span>
        <span class="c1"># By converting to floats now, we can avoid that on every draw.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="n">meshHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">meshWidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antialiased</span> <span class="o">=</span> <span class="n">antialiased</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading</span> <span class="o">=</span> <span class="n">shading</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">((</span><span class="n">meshWidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">meshHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)))</span>

<div class="viewcode-block" id="QuadMesh.get_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_paths</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span></div>

<div class="viewcode-block" id="QuadMesh.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_mesh_to_paths</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meshWidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshHeight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="QuadMesh.get_datalim"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.get_datalim">[docs]</a>    <span class="k">def</span> <span class="nf">get_datalim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transData</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span> <span class="o">-</span> <span class="n">transData</span><span class="p">)</span><span class="o">.</span><span class="n">transform_bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuadMesh.convert_mesh_to_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.convert_mesh_to_paths">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_mesh_to_paths</span><span class="p">(</span><span class="n">meshWidth</span><span class="p">,</span> <span class="n">meshHeight</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Converts a given mesh into a sequence of</span>
<span class="sd">        :class:`matplotlib.path.Path` objects for easier rendering by</span>
<span class="sd">        backends that do not directly support quadmeshes.</span>

<span class="sd">        This function is primarily of use to backend implementers.</span>
<span class="sd">        """</span>
        <span class="n">Path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">coordinates</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                    <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span>
                    <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:],</span>
                    <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">meshWidth</span> <span class="o">*</span> <span class="n">meshHeight</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span></div>

<div class="viewcode-block" id="QuadMesh.convert_mesh_to_triangles"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.convert_mesh_to_triangles">[docs]</a>    <span class="k">def</span> <span class="nf">convert_mesh_to_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshWidth</span><span class="p">,</span> <span class="n">meshHeight</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Converts a given mesh into a sequence of triangles, each point</span>
<span class="sd">        with its own color.  This is useful for experiments using</span>
<span class="sd">        `draw_qouraud_triangle`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">coordinates</span>

        <span class="n">p_a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p_b</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">p_c</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">p_d</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_a</span> <span class="o">+</span> <span class="n">p_b</span> <span class="o">+</span> <span class="n">p_c</span> <span class="o">+</span> <span class="n">p_d</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>

        <span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span><span class="p">,</span> <span class="n">p_center</span><span class="p">,</span>
                <span class="n">p_b</span><span class="p">,</span> <span class="n">p_c</span><span class="p">,</span> <span class="n">p_center</span><span class="p">,</span>
                <span class="n">p_c</span><span class="p">,</span> <span class="n">p_d</span><span class="p">,</span> <span class="n">p_center</span><span class="p">,</span>
                <span class="n">p_d</span><span class="p">,</span> <span class="n">p_a</span><span class="p">,</span> <span class="n">p_center</span><span class="p">,</span>
            <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">triangles</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">meshWidth</span> <span class="o">*</span> <span class="n">meshHeight</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">meshHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">meshWidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">c_a</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c_b</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">c_c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">c_d</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_a</span> <span class="o">+</span> <span class="n">c_b</span> <span class="o">+</span> <span class="n">c_c</span> <span class="o">+</span> <span class="n">c_d</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                        <span class="n">c_a</span><span class="p">,</span> <span class="n">c_b</span><span class="p">,</span> <span class="n">c_center</span><span class="p">,</span>
                        <span class="n">c_b</span><span class="p">,</span> <span class="n">c_c</span><span class="p">,</span> <span class="n">c_center</span><span class="p">,</span>
                        <span class="n">c_c</span><span class="p">,</span> <span class="n">c_d</span><span class="p">,</span> <span class="n">c_center</span><span class="p">,</span>
                        <span class="n">c_d</span><span class="p">,</span> <span class="n">c_a</span><span class="p">,</span> <span class="n">c_center</span><span class="p">,</span>
                    <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">meshWidth</span> <span class="o">*</span> <span class="n">meshHeight</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">colors</span></div>

<div class="viewcode-block" id="QuadMesh.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gid</span><span class="p">())</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="n">transOffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset_transform</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">have_units</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="p">):</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_scalarmappable</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transform</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
            <span class="n">transOffset</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>

        <span class="n">gc</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">new_gc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_gc_clip</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading</span> <span class="o">==</span> <span class="s1">'gouraud'</span><span class="p">:</span>
            <span class="n">triangles</span><span class="p">,</span> <span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_mesh_to_triangles</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_meshWidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshHeight</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>
            <span class="n">renderer</span><span class="o">.</span><span class="n">draw_gouraud_triangles</span><span class="p">(</span>
                <span class="n">gc</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">renderer</span><span class="o">.</span><span class="n">draw_quad_mesh</span><span class="p">(</span>
                <span class="n">gc</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshWidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshHeight</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_antialiased</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edgecolors</span><span class="p">())</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">close_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">False</span></div></div>


<span class="n">patchstr</span> <span class="o">=</span> <span class="n">artist</span><span class="o">.</span><span class="n">kwdoc</span><span class="p">(</span><span class="n">Collection</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'QuadMesh'</span><span class="p">,</span> <span class="s1">'TriMesh'</span><span class="p">,</span> <span class="s1">'PolyCollection'</span><span class="p">,</span> <span class="s1">'BrokenBarHCollection'</span><span class="p">,</span>
          <span class="s1">'RegularPolyCollection'</span><span class="p">,</span> <span class="s1">'PathCollection'</span><span class="p">,</span>
          <span class="s1">'StarPolygonCollection'</span><span class="p">,</span> <span class="s1">'PatchCollection'</span><span class="p">,</span>
          <span class="s1">'CircleCollection'</span><span class="p">,</span> <span class="s1">'Collection'</span><span class="p">,):</span>
    <span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">patchstr</span><span class="p">})</span>
<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">LineCollection</span><span class="o">=</span><span class="n">artist</span><span class="o">.</span><span class="n">kwdoc</span><span class="p">(</span><span class="n">LineCollection</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="footer">
        © Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br/>
      Last updated on Jun 28, 2018.
	Created using
	<ahref>Sphinx 1.7.5.
	Doc version v2.2.2-101-g15e1eadd0.
    </ahref></div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
<!--Flipcause Integration v3.0// Flipcause Integration Instructions:
Install the following code block once in the website Header (after <head> tag) -->
<style>

.fc-black_overlay{
display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;
background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;
}

.fc-white_content {
opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;
position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;
}

.fc-main-box{
opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;
}

.fc-widget_close{
opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);
position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;
}

.floating_button{
display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;
position:fixed; z-index:999999; overflow: auto;
}

@keyframes backfadesin {
   from { opacity:0; }
   to {opacity:.5;}
}

@-moz-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-webkit-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-o-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}


@-ms-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; transform: translateY(20px);}
   100% {opacity: 1; transform: translateY(0);}
}

@-moz-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -moz-transform: translateY(20px);}
   100% {opacity: 1; -moz-transform: translateY(0);}
}

@-webkit-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -webkit-transform: translateY(20px);}
   100% {opacity: 1; -webkit-transform: translateY(0);}
}

@-o-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -o-transform: translateY(20px);}
   100% {opacity: 1; -o-transform: translateY(0);}
}

@-ms-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -ms-transform: translateY(20px);}
   100% {opacity: 1; -ms-transform: translateY(0);}
}

</style>
<div class="fc-black_overlay" id="fc-fade" onclick="close_window()"></div>
<div class="fc-white_content" id="fc-light">
<div class="fc-main-box" id="fc-main">
<div class="fc-widget_close" id="fc-close" onclick="close_window()">
</div><iframe height="580" id="fc-myFrame" iframe="" scrolling="no" src="" style="border: 0;
border-radius:5px 5px 5px 5px; box-shadow:0 0 8px rgba(0, 0, 0, 0.5);" width="925"></iframe></div>
</div>
<!--END Flipcause Main Integration Code-->
</footer>
</html>
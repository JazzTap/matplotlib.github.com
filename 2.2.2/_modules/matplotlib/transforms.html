<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>matplotlib.transforms — Matplotlib 2.2.2 documentation</title>
<link href="../../_static/mpl.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/gallery.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<link href="../../_static/opensearch.xml" rel="search" title="Search within Matplotlib 2.2.2 documentation" type="application/opensearchdescription+xml"/>
<link href="../../_static/favicon.ico" rel="shortcut icon"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="../../index.html" rel="top" title="Matplotlib 2.2.2 documentation"/>
<link href="../matplotlib.html" rel="up" title="matplotlib"/>
<link href="https://matplotlib.org/_modules/matplotlib/transforms.html" rel="canonical"/>
<link href="https://matplotlib.org/_modules/matplotlib/transforms.html" rel="canonical"/></head>
<body><div id="old-version-banner">
            You are reading documentation for a static version of Matplotlib.
            <a href="https://matplotlib.org/_modules/matplotlib/transforms.html">This page may have been updated.</a>
</div>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../../index.html">
<div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 2.2.2</span></div>
<img alt="matplotlib" border="0" height="125px" src="../../_static/logo2.png"/></a>
<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li><a href="../../index.html">home</a>| </li>
<li><a href="../../gallery/index.html">examples</a>| </li>
<li><a href="../../tutorials/index.html">tutorials</a>| </li>
<li><a href="../../api/pyplot_summary.html">pyplot</a>| </li>
<li><a href="../../contents.html">docs</a> »</li>
<li><a href="../index.html">Module code</a> »</li>
<li><a accesskey="U" href="../matplotlib.html">matplotlib</a> »</li>
</ul>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div id="searchbox" role="search" style="display: none">
<h3>Quick search</h3>
<div class="searchformwrapper">
<form action="../../search.html" class="search" method="get">
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="../../contents.html">Documentation overview</a><ul>
<li><a href="../index.html">Module code</a><ul>
<li><a href="../matplotlib.html">matplotlib</a><ul>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<h1>Source code for matplotlib.transforms</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">matplotlib includes a framework for arbitrary geometric</span>
<span class="sd">transformations that is used determine the final position of all</span>
<span class="sd">elements drawn on the canvas.</span>

<span class="sd">Transforms are composed into trees of :class:`TransformNode` objects</span>
<span class="sd">whose actual value depends on their children.  When the contents of</span>
<span class="sd">children change, their parents are automatically invalidated.  The</span>
<span class="sd">next time an invalidated transform is accessed, it is recomputed to</span>
<span class="sd">reflect those changes.  This invalidation/caching approach prevents</span>
<span class="sd">unnecessary recomputations of transforms, and contributes to better</span>
<span class="sd">interactive performance.</span>

<span class="sd">For example, here is a graph of the transform tree used to plot data</span>
<span class="sd">to the graph:</span>

<span class="sd">.. image:: ../_static/transforms.png</span>

<span class="sd">The framework can be used for both affine and non-affine</span>
<span class="sd">transformations.  However, for speed, we want use the backend</span>
<span class="sd">renderers to perform affine transformations whenever possible.</span>
<span class="sd">Therefore, it is possible to perform just the affine or non-affine</span>
<span class="sd">part of a transformation on a set of data.  The affine is always</span>
<span class="sd">assumed to occur after the non-affine.  For any transform::</span>

<span class="sd">  full transform == non-affine part + affine part</span>

<span class="sd">The backends are not expected to handle non-affine transformations</span>
<span class="sd">themselves.</span>
<span class="sd">"""</span>

<span class="c1"># Note: There are a number of places in the code where we use `np.min` or</span>
<span class="c1"># `np.minimum` instead of the builtin `min`, and likewise for `max`.  This is</span>
<span class="c1"># done so that `nan`s are propagated, instead of being silently dropped.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib._path</span> <span class="k">import</span> <span class="p">(</span><span class="n">affine_transform</span><span class="p">,</span> <span class="n">count_bboxes_overlapping_bbox</span><span class="p">,</span>
    <span class="n">update_path_extents</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">inv</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">cbook</span>
<span class="kn">from</span> <span class="nn">.path</span> <span class="k">import</span> <span class="n">Path</span>

<span class="n">DEBUG</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_indent_str</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>  <span class="c1"># textwrap.indent(str(obj), 4) on Py3.</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">"(^|</span><span class="se">\n</span><span class="s2">)"</span><span class="p">,</span> <span class="sa">r</span><span class="s2">"\1    "</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>


<div class="viewcode-block" id="TransformNode"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode">[docs]</a><span class="k">class</span> <span class="nc">TransformNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    :class:`TransformNode` is the base class for anything that</span>
<span class="sd">    participates in the transform tree and needs to invalidate its</span>
<span class="sd">    parents or be invalidated.  This includes classes that are not</span>
<span class="sd">    really transforms, such as bounding boxes, since some transforms</span>
<span class="sd">    depend on bounding boxes to compute their values.</span>
<span class="sd">    """</span>
    <span class="n">_gid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Invalidation may affect only the affine part.  If the</span>
    <span class="c1"># invalidation was "affine-only", the _invalid member is set to</span>
    <span class="c1"># INVALID_AFFINE_ONLY</span>
    <span class="n">INVALID_NON_AFFINE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">INVALID_AFFINE</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">INVALID</span> <span class="o">=</span> <span class="n">INVALID_NON_AFFINE</span> <span class="o">|</span> <span class="n">INVALID_AFFINE</span>

    <span class="c1"># Some metadata about the transform, used to determine whether an</span>
    <span class="c1"># invalidation is affine-only</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_bbox</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">"""</span>
<span class="sd">    If pass_through is True, all ancestors will always be</span>
<span class="sd">    invalidated, even if 'self' is already invalid.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shorthand_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Creates a new :class:`TransformNode`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shorthand_name : str</span>
<span class="sd">            A string representing the "name" of the transform. The name carries</span>
<span class="sd">            no significance other than to improve the readability of</span>
<span class="sd">            ``str(transform)`` when DEBUG=True.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># TransformNodes start out as invalid until their values are</span>
        <span class="c1"># computed for the first time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span> <span class="o">=</span> <span class="n">shorthand_name</span> <span class="ow">or</span> <span class="s1">''</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># either just return the name of this TransformNode, or it's repr</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span> <span class="ow">or</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># turn the dictionary with weak values into a normal dictionary</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">'_parents'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">())</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span>
                             <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">data_dict</span>
        <span class="c1"># turn the normal dictionary back into a dictionary with weak</span>
        <span class="c1"># values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span>
                             <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">"TransformNode instances can not be copied. "</span>
            <span class="s2">"Consider using frozen() instead."</span><span class="p">)</span>
    <span class="n">__deepcopy__</span> <span class="o">=</span> <span class="n">__copy__</span>

<div class="viewcode-block" id="TransformNode.invalidate"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.invalidate">[docs]</a>    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Invalidate this :class:`TransformNode` and triggers an</span>
<span class="sd">        invalidation of its ancestors.  Should be called any</span>
<span class="sd">        time the transform changes.</span>
<span class="sd">        """</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_AFFINE</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Called by :meth:`invalidate` and subsequently ascends the transform</span>
<span class="sd">        stack calling each TransformNode's _invalidate_internal method.</span>
<span class="sd">        """</span>
        <span class="c1"># determine if this call will be an extension to the invalidation</span>
        <span class="c1"># status. If not, then a shortcut means that we needn't invoke an</span>
        <span class="c1"># invalidation up the transform stack as it will already have been</span>
        <span class="c1"># invalidated.</span>

        <span class="c1"># N.B This makes the invalidation sticky, once a transform has been</span>
        <span class="c1"># invalidated as NON_AFFINE, then it will always be invalidated as</span>
        <span class="c1"># NON_AFFINE even when triggered with a AFFINE_ONLY invalidation.</span>
        <span class="c1"># In most cases this is not a problem (i.e. for interactive panning and</span>
        <span class="c1"># zooming) and the only side effect will be on performance.</span>
        <span class="n">status_changed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">&lt;</span> <span class="n">value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pass_through</span> <span class="ow">or</span> <span class="n">status_changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">)):</span>
                <span class="c1"># Dereference the weak reference</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the children of the transform, to let the invalidation</span>
<span class="sd">        system know which transforms can invalidate this transform.</span>
<span class="sd">        Should be called from the constructor of any transforms that</span>
<span class="sd">        depend on other transforms.</span>
<span class="sd">        """</span>
        <span class="c1"># Parents are stored as weak references, so that if the</span>
        <span class="c1"># parents are destroyed, references from the children won't</span>
        <span class="c1"># keep them alive.</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_set_children</span> <span class="o">=</span> <span class="n">set_children</span>

<div class="viewcode-block" id="TransformNode.set_children"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.set_children">[docs]</a>        <span class="k">def</span> <span class="nf">set_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_children</span><span class="p">(</span><span class="o">*</span><span class="n">children</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="n">children</span></div>
        <span class="n">set_children</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_set_children</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="TransformNode.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a frozen copy of this transform node.  The frozen copy</span>
<span class="sd">        will not update when its children change.  Useful for storing</span>
<span class="sd">        a previously known state of a transform where</span>
<span class="sd">        ``copy.deepcopy()`` might normally be used.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">write_graphviz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fobj</span><span class="p">,</span> <span class="n">highlight</span><span class="o">=</span><span class="p">[]):</span>
            <span class="sd">"""</span>
<span class="sd">            For debugging purposes.</span>

<span class="sd">            Writes the transform tree rooted at 'self' to a graphviz "dot"</span>
<span class="sd">            format file.  This file can be run through the "dot" utility</span>
<span class="sd">            to produce a graph of the transform tree.</span>

<span class="sd">            Affine transforms are marked in blue.  Bounding boxes are</span>
<span class="sd">            marked in yellow.</span>

<span class="sd">            *fobj*: A Python file-like object</span>

<span class="sd">            Once the "dot" file has been created, it can be turned into a</span>
<span class="sd">            png easily with::</span>

<span class="sd">                $&gt; dot -Tpng -o $OUTPUT_FILE $DOT_FILE</span>

<span class="sd">            """</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">props</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s1">'[</span><span class="si">%s</span><span class="s1">]'</span> <span class="o">%</span> <span class="n">label</span>
                <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">highlight</span><span class="p">:</span>
                    <span class="n">props</span><span class="p">[</span><span class="s1">'style'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'bold'</span>
                <span class="n">props</span><span class="p">[</span><span class="s1">'shape'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'box'</span>
                <span class="n">props</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'"</span><span class="si">%s</span><span class="s1">"'</span> <span class="o">%</span> <span class="n">label</span>
                <span class="n">props</span> <span class="o">=</span> <span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">'</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span>
                                  <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">props</span><span class="p">)])</span>

                <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1"> [</span><span class="si">%s</span><span class="s1">];</span><span class="se">\n</span><span class="s1">'</span> <span class="o">%</span>
                           <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">root</span><span class="p">),</span> <span class="n">props</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">'_children'</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">_children</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="s1">'?'</span>
                        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">child</span><span class="p">:</span>
                                <span class="n">name</span> <span class="o">=</span> <span class="n">key</span>
                                <span class="k">break</span>
                        <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'"</span><span class="si">%s</span><span class="s1">" -&gt; "</span><span class="si">%s</span><span class="s1">" [label="</span><span class="si">%s</span><span class="s1">", fontsize=10];</span><span class="se">\n</span><span class="s1">'</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                                    <span class="nb">hash</span><span class="p">(</span><span class="n">child</span><span class="p">),</span>
                                    <span class="n">name</span><span class="p">))</span>
                        <span class="n">recurse</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"digraph G {</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
            <span class="n">recurse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"}</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span></div>


<div class="viewcode-block" id="BboxBase"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase">[docs]</a><span class="k">class</span> <span class="nc">BboxBase</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    This is the base class of all bounding boxes, and provides</span>
<span class="sd">    read-only access to its data.  A mutable bounding box is provided</span>
<span class="sd">    by the :class:`Bbox` class.</span>

<span class="sd">    The canonical representation is as two points, with no</span>
<span class="sd">    restrictions on their ordering.  Convenience properties are</span>
<span class="sd">    provided to get the left, bottom, right and top edges and width</span>
<span class="sd">    and height, but these are not stored explicitly.</span>
<span class="sd">    """</span>
    <span class="n">is_bbox</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"Bbox bounds are a masked array."</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span>
                <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"Singular Bbox."</span><span class="p">)</span>
        <span class="n">_check</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">_check</span><span class="p">)</span>

<div class="viewcode-block" id="BboxBase.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">TransformNode</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>

<div class="viewcode-block" id="BboxBase.is_unit"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.is_unit">[docs]</a>    <span class="k">def</span> <span class="nf">is_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns True if the :class:`Bbox` is the unit bounding box</span>
<span class="sd">        from (0, 0) to (1, 1).</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`x0` is the first of the pair of *x* coordinates that</span>
<span class="sd">        define the bounding box. :attr:`x0` is not guaranteed to be less than</span>
<span class="sd">        :attr:`x1`.  If you require that, use :attr:`xmin`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`y0` is the first of the pair of *y* coordinates that</span>
<span class="sd">        define the bounding box. :attr:`y0` is not guaranteed to be less than</span>
<span class="sd">        :attr:`y1`.  If you require that, use :attr:`ymin`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`x1` is the second of the pair of *x* coordinates that</span>
<span class="sd">        define the bounding box. :attr:`x1` is not guaranteed to be greater</span>
<span class="sd">        than :attr:`x0`.  If you require that, use :attr:`xmax`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`y1` is the second of the pair of *y* coordinates that</span>
<span class="sd">        define the bounding box. :attr:`y1` is not guaranteed to be greater</span>
<span class="sd">        than :attr:`y0`.  If you require that, use :attr:`ymax`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">p0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`p0` is the first pair of (*x*, *y*) coordinates that</span>
<span class="sd">        define the bounding box.  It is not guaranteed to be the bottom-left</span>
<span class="sd">        corner.  For that, use :attr:`min`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">p1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`p1` is the second pair of (*x*, *y*) coordinates that</span>
<span class="sd">        define the bounding box.  It is not guaranteed to be the top-right</span>
<span class="sd">        corner.  For that, use :attr:`max`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`xmin` is the left edge of the bounding box.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ymin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`ymin` is the bottom edge of the bounding box.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`xmax` is the right edge of the bounding box.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ymax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`ymax` is the top edge of the bounding box.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`min` is the bottom-left corner of the bounding box.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`max` is the top-right corner of the bounding box.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intervalx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`intervalx` is the pair of *x* coordinates that define</span>
<span class="sd">        the bounding box. It is not guaranteed to be sorted from left to right.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intervaly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :attr:`intervaly` is the pair of *y* coordinates that define</span>
<span class="sd">        the bounding box.  It is not guaranteed to be sorted from bottom to</span>
<span class="sd">        top.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The width of the bounding box.  It may be negative if</span>
<span class="sd">        :attr:`x1` &lt; :attr:`x0`.</span>
<span class="sd">        """</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The height of the bounding box.  It may be negative if</span>
<span class="sd">        :attr:`y1` &lt; :attr:`y0`.</span>
<span class="sd">        """</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The width and height of the bounding box.  May be negative,</span>
<span class="sd">        in the same way as :attr:`width` and :attr:`height`.</span>
<span class="sd">        """</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns (:attr:`x0`, :attr:`y0`, :attr:`width`,</span>
<span class="sd">        :attr:`height`).</span>
<span class="sd">        """</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns (:attr:`x0`, :attr:`y0`, :attr:`x1`,</span>
<span class="sd">        :attr:`y1`).</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="BboxBase.get_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BboxBase.containsx"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.containsx">[docs]</a>    <span class="k">def</span> <span class="nf">containsx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether *x* is in the closed (:attr:`x0`, :attr:`x1`) interval.</span>
<span class="sd">        """</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalx</span>
        <span class="k">return</span> <span class="n">x0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x1</span> <span class="ow">or</span> <span class="n">x0</span> <span class="o">&gt;=</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x1</span></div>

<div class="viewcode-block" id="BboxBase.containsy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.containsy">[docs]</a>    <span class="k">def</span> <span class="nf">containsy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether *y* is in the closed (:attr:`y0`, :attr:`y1`) interval.</span>
<span class="sd">        """</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="k">return</span> <span class="n">y0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">y1</span> <span class="ow">or</span> <span class="n">y0</span> <span class="o">&gt;=</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">y1</span></div>

<div class="viewcode-block" id="BboxBase.contains"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether ``(x, y)`` is in the bounding box or on its edge.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">containsx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">containsy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.overlaps"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether this bounding box overlaps with the other bounding box.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : BboxBase</span>
<span class="sd">        """</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">bx1</span><span class="p">,</span> <span class="n">by1</span><span class="p">,</span> <span class="n">bx2</span><span class="p">,</span> <span class="n">by2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">extents</span>
        <span class="k">if</span> <span class="n">ax2</span> <span class="o">&lt;</span> <span class="n">ax1</span><span class="p">:</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span>
        <span class="k">if</span> <span class="n">ay2</span> <span class="o">&lt;</span> <span class="n">ay1</span><span class="p">:</span>
            <span class="n">ay2</span><span class="p">,</span> <span class="n">ay1</span> <span class="o">=</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ay2</span>
        <span class="k">if</span> <span class="n">bx2</span> <span class="o">&lt;</span> <span class="n">bx1</span><span class="p">:</span>
            <span class="n">bx2</span><span class="p">,</span> <span class="n">bx1</span> <span class="o">=</span> <span class="n">bx1</span><span class="p">,</span> <span class="n">bx2</span>
        <span class="k">if</span> <span class="n">by2</span> <span class="o">&lt;</span> <span class="n">by1</span><span class="p">:</span>
            <span class="n">by2</span><span class="p">,</span> <span class="n">by1</span> <span class="o">=</span> <span class="n">by1</span><span class="p">,</span> <span class="n">by2</span>
        <span class="k">return</span> <span class="n">ax1</span> <span class="o">&lt;=</span> <span class="n">bx2</span> <span class="ow">and</span> <span class="n">bx1</span> <span class="o">&lt;=</span> <span class="n">ax2</span> <span class="ow">and</span> <span class="n">ay1</span> <span class="o">&lt;=</span> <span class="n">by2</span> <span class="ow">and</span> <span class="n">by1</span> <span class="o">&lt;=</span> <span class="n">ay2</span></div>

<div class="viewcode-block" id="BboxBase.fully_containsx"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.fully_containsx">[docs]</a>    <span class="k">def</span> <span class="nf">fully_containsx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether *x* is in the open (:attr:`x0`, :attr:`x1`) interval.</span>
<span class="sd">        """</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalx</span>
        <span class="k">return</span> <span class="n">x0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x1</span> <span class="ow">or</span> <span class="n">x0</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x1</span></div>

<div class="viewcode-block" id="BboxBase.fully_containsy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.fully_containsy">[docs]</a>    <span class="k">def</span> <span class="nf">fully_containsy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether *y* is in the open (:attr:`y0`, :attr:`y1`) interval.</span>
<span class="sd">        """</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="k">return</span> <span class="n">y0</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y1</span> <span class="ow">or</span> <span class="n">y0</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">y1</span></div>

<div class="viewcode-block" id="BboxBase.fully_contains"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.fully_contains">[docs]</a>    <span class="k">def</span> <span class="nf">fully_contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether ``x, y`` is in the bounding box, but not on its edge.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fully_containsx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fully_containsy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.fully_overlaps"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.fully_overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">fully_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether this bounding box overlaps with the other bounding box,</span>
<span class="sd">        not including the edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : BboxBase</span>
<span class="sd">        """</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">bx1</span><span class="p">,</span> <span class="n">by1</span><span class="p">,</span> <span class="n">bx2</span><span class="p">,</span> <span class="n">by2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">extents</span>
        <span class="k">if</span> <span class="n">ax2</span> <span class="o">&lt;</span> <span class="n">ax1</span><span class="p">:</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span>
        <span class="k">if</span> <span class="n">ay2</span> <span class="o">&lt;</span> <span class="n">ay1</span><span class="p">:</span>
            <span class="n">ay2</span><span class="p">,</span> <span class="n">ay1</span> <span class="o">=</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ay2</span>
        <span class="k">if</span> <span class="n">bx2</span> <span class="o">&lt;</span> <span class="n">bx1</span><span class="p">:</span>
            <span class="n">bx2</span><span class="p">,</span> <span class="n">bx1</span> <span class="o">=</span> <span class="n">bx1</span><span class="p">,</span> <span class="n">bx2</span>
        <span class="k">if</span> <span class="n">by2</span> <span class="o">&lt;</span> <span class="n">by1</span><span class="p">:</span>
            <span class="n">by2</span><span class="p">,</span> <span class="n">by1</span> <span class="o">=</span> <span class="n">by1</span><span class="p">,</span> <span class="n">by2</span>
        <span class="k">return</span> <span class="n">ax1</span> <span class="o">&lt;</span> <span class="n">bx2</span> <span class="ow">and</span> <span class="n">bx1</span> <span class="o">&lt;</span> <span class="n">ax2</span> <span class="ow">and</span> <span class="n">ay1</span> <span class="o">&lt;</span> <span class="n">by2</span> <span class="ow">and</span> <span class="n">by1</span> <span class="o">&lt;</span> <span class="n">ay2</span></div>

<div class="viewcode-block" id="BboxBase.transformed"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.transformed">[docs]</a>    <span class="k">def</span> <span class="nf">transformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a new :class:`Bbox` object, statically transformed by</span>
<span class="sd">        the given transform.</span>
<span class="sd">        """</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">ul</span><span class="p">,</span> <span class="n">lr</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]))</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="n">ll</span><span class="p">,</span> <span class="p">[</span><span class="n">lr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ul</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span></div>

<div class="viewcode-block" id="BboxBase.inverse_transformed"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.inverse_transformed">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a new :class:`Bbox` object, statically transformed by</span>
<span class="sd">        the inverse of the given transform.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span></div>

    <span class="n">coefs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'C'</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
             <span class="s1">'SW'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">'S'</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">'SE'</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">'E'</span><span class="p">:</span>  <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
             <span class="s1">'NE'</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">'N'</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">'NW'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">'W'</span><span class="p">:</span>  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)}</span>

<div class="viewcode-block" id="BboxBase.anchored"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.anchored">[docs]</a>    <span class="k">def</span> <span class="nf">anchored</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a copy of the :class:`Bbox`, shifted to position *c*</span>
<span class="sd">        within a container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c :</span>
<span class="sd">            May be either:</span>

<span class="sd">            * A sequence (*cx*, *cy*) where *cx* and *cy* range from 0</span>
<span class="sd">              to 1, where 0 is left or bottom and 1 is right or top</span>

<span class="sd">            * a string:</span>
<span class="sd">              - 'C' for centered</span>
<span class="sd">              - 'S' for bottom-center</span>
<span class="sd">              - 'SE' for bottom-left</span>
<span class="sd">              - 'E' for left</span>
<span class="sd">              - etc.</span>

<span class="sd">        container : Bbox, optional</span>
<span class="sd">            The box within which the :class:`Bbox` is positioned; it defaults</span>
<span class="sd">            to the initial :class:`Bbox`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span>
                    <span class="p">[(</span><span class="n">l</span> <span class="o">+</span> <span class="n">cx</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">W</span><span class="p">))</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">cy</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">H</span><span class="p">))</span> <span class="o">-</span> <span class="n">B</span><span class="p">])</span></div>

<div class="viewcode-block" id="BboxBase.shrunk"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.shrunk">[docs]</a>    <span class="k">def</span> <span class="nf">shrunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a copy of the :class:`Bbox`, shrunk by the factor *mx*</span>
<span class="sd">        in the *x* direction and the factor *my* in the *y* direction.</span>
<span class="sd">        The lower left corner of the box remains unchanged.  Normally</span>
<span class="sd">        *mx* and *my* will be less than 1, but this is not enforced.</span>
<span class="sd">        """</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">mx</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">my</span> <span class="o">*</span> <span class="n">h</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.shrunk_to_aspect"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.shrunk_to_aspect">[docs]</a>    <span class="k">def</span> <span class="nf">shrunk_to_aspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_aspect</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_aspect</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a copy of the :class:`Bbox`, shrunk so that it is as</span>
<span class="sd">        large as it can be while having the desired aspect ratio,</span>
<span class="sd">        *box_aspect*.  If the box coordinates are relative---that</span>
<span class="sd">        is, fractions of a larger box such as a figure---then the</span>
<span class="sd">        physical aspect ratio of that figure is specified with</span>
<span class="sd">        *fig_aspect*, so that *box_aspect* can also be given as a</span>
<span class="sd">        ratio of the absolute dimensions, not the relative dimensions.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">box_aspect</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">fig_aspect</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'box_aspect' and 'fig_aspect' must be positive"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">size</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">box_aspect</span> <span class="o">/</span> <span class="n">fig_aspect</span>
        <span class="k">if</span> <span class="n">H</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">fig_aspect</span> <span class="o">/</span> <span class="n">box_aspect</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">)])</span></div>

<div class="viewcode-block" id="BboxBase.splitx"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.splitx">[docs]</a>    <span class="k">def</span> <span class="nf">splitx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        e.g., ``bbox.splitx(f1, f2, ...)``</span>

<span class="sd">        Returns a list of new :class:`Bbox` objects formed by</span>
<span class="sd">        splitting the original one with vertical lines at fractional</span>
<span class="sd">        positions *f1*, *f2*, ...</span>
<span class="sd">        """</span>
        <span class="n">xf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">xf0</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">xf1</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">y1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">xf0</span><span class="p">,</span> <span class="n">xf1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xf</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span></div>

<div class="viewcode-block" id="BboxBase.splity"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.splity">[docs]</a>    <span class="k">def</span> <span class="nf">splity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        e.g., ``bbox.splitx(f1, f2, ...)``</span>

<span class="sd">        Returns a list of new :class:`Bbox` objects formed by</span>
<span class="sd">        splitting the original one with horizontal lines at fractional</span>
<span class="sd">        positions *f1*, *f2*, ...</span>
<span class="sd">        """</span>
        <span class="n">yf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">yf0</span> <span class="o">*</span> <span class="n">h</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">yf1</span> <span class="o">*</span> <span class="n">h</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">yf0</span><span class="p">,</span> <span class="n">yf1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">yf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yf</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span></div>

<div class="viewcode-block" id="BboxBase.count_contains"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.count_contains">[docs]</a>    <span class="k">def</span> <span class="nf">count_contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Count the number of vertices contained in the :class:`Bbox`.</span>
<span class="sd">        Any vertices with a non-finite x or y value are ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vertices : Nx2 Numpy array.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">vertices</span><span class="p">)</span> <span class="o">&amp;</span>
                     <span class="p">(</span><span class="n">vertices</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span></div>

<div class="viewcode-block" id="BboxBase.count_overlaps"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.count_overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">count_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Count the number of bounding boxes that overlap this one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bboxes : sequence of :class:`BboxBase` objects</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">count_bboxes_overlapping_bbox</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">]))</span></div>

<div class="viewcode-block" id="BboxBase.expanded"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.expanded">[docs]</a>    <span class="k">def</span> <span class="nf">expanded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a new :class:`Bbox` which is this :class:`Bbox`</span>
<span class="sd">        expanded around its center by the given factors *sw* and</span>
<span class="sd">        *sh*.</span>
<span class="sd">        """</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>
        <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span>
        <span class="n">deltaw</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">*</span> <span class="n">width</span> <span class="o">-</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">deltah</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh</span> <span class="o">*</span> <span class="n">height</span> <span class="o">-</span> <span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">deltaw</span><span class="p">,</span> <span class="o">-</span><span class="n">deltah</span><span class="p">],</span> <span class="p">[</span><span class="n">deltaw</span><span class="p">,</span> <span class="n">deltah</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.padded"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.padded">[docs]</a>    <span class="k">def</span> <span class="nf">padded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a new :class:`Bbox` that is padded on all four sides by</span>
<span class="sd">        the given value.</span>
<span class="sd">        """</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">points</span> <span class="o">+</span> <span class="p">[[</span><span class="o">-</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span><span class="p">],</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.translated"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.translated">[docs]</a>    <span class="k">def</span> <span class="nf">translated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a copy of the :class:`Bbox`, statically translated by</span>
<span class="sd">        *tx* and *ty*.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.corners"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.corners">[docs]</a>    <span class="k">def</span> <span class="nf">corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return an array of points which are the four corners of this</span>
<span class="sd">        rectangle.  For example, if this :class:`Bbox` is defined by</span>
<span class="sd">        the points (*a*, *b*) and (*c*, *d*), :meth:`corners` returns</span>
<span class="sd">        (*a*, *b*), (*a*, *d*), (*c*, *b*) and (*c*, *d*).</span>
<span class="sd">        """</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.rotated"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.rotated">[docs]</a>    <span class="k">def</span> <span class="nf">rotated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radians</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a new bounding box that bounds a rotated version of</span>
<span class="sd">        this bounding box by the given radians.  The new bounding box</span>
<span class="sd">        is still aligned with the axes, of course.</span>
<span class="sd">        """</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corners</span><span class="p">()</span>
        <span class="n">corners_rotated</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
        <span class="n">bbox</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">corners_rotated</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bbox</span></div>

<div class="viewcode-block" id="BboxBase.union"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.union">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">bboxes</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a :class:`Bbox` that contains all of the given bboxes.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">bboxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'bboxes' cannot be empty"</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">bbox</span><span class="o">.</span><span class="n">xmin</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">])</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">bbox</span><span class="o">.</span><span class="n">xmax</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">])</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">bbox</span><span class="o">.</span><span class="n">ymin</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">])</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">bbox</span><span class="o">.</span><span class="n">ymax</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.intersection"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.intersection">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">bbox1</span><span class="p">,</span> <span class="n">bbox2</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the intersection of the two bboxes or None</span>
<span class="sd">        if they do not intersect.</span>
<span class="sd">        """</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">bbox1</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">bbox1</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">bbox1</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">ymin</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">bbox1</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">ymax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]])</span> <span class="k">if</span> <span class="n">x0</span> <span class="o">&lt;=</span> <span class="n">x1</span> <span class="ow">and</span> <span class="n">y0</span> <span class="o">&lt;=</span> <span class="n">y1</span> <span class="k">else</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="Bbox"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox">[docs]</a><span class="k">class</span> <span class="nc">Bbox</span><span class="p">(</span><span class="n">BboxBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A mutable bounding box.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : ndarray</span>
<span class="sd">            A 2x2 numpy array of the form ``[[x0, y0], [x1, y1]]``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you need to create a :class:`Bbox` object from another form</span>
<span class="sd">        of data, consider the static methods :meth:`unit`,</span>
<span class="sd">        :meth:`from_bounds` and :meth:`from_extents`.</span>
<span class="sd">        """</span>
        <span class="n">BboxBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Bbox points must be of the form '</span>
                             <span class="s1">'"[[x0, y0], [x1, y1]]".'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># it is helpful in some contexts to know if the bbox is a</span>
        <span class="c1"># default or has been mutated; we store the orig points to</span>
        <span class="c1"># support the mutated methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">___init__</span> <span class="o">=</span> <span class="fm">__init__</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">___init__</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>
            <span class="n">TransformNode</span><span class="o">.</span><span class="n">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Bbox.unit"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.unit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">():</span>
        <span class="sd">"""</span>
<span class="sd">        (staticmethod) Create a new unit :class:`Bbox` from (0, 0) to</span>
<span class="sd">        (1, 1).</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="nb">float</span><span class="p">))</span></div>

<div class="viewcode-block" id="Bbox.null"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.null">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">null</span><span class="p">():</span>
        <span class="sd">"""</span>
<span class="sd">        (staticmethod) Create a new null :class:`Bbox` from (inf, inf) to</span>
<span class="sd">        (-inf, -inf).</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]],</span> <span class="nb">float</span><span class="p">))</span></div>

<div class="viewcode-block" id="Bbox.from_bounds"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.from_bounds">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_bounds</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (staticmethod) Create a new :class:`Bbox` from *x0*, *y0*,</span>
<span class="sd">        *width* and *height*.</span>

<span class="sd">        *width* and *height* may be negative.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">from_extents</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span></div>

<div class="viewcode-block" id="Bbox.from_extents"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.from_extents">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_extents</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (staticmethod) Create a new Bbox from *left*, *bottom*,</span>
<span class="sd">        *right* and *top*.</span>

<span class="sd">        The *y*-axis increases upwards.</span>
<span class="sd">        """</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s1">'Bbox(x0={0.x0:</span><span class="si">{1}</span><span class="s1">}, y0={0.y0:</span><span class="si">{1}</span><span class="s1">}, x1={0.x1:</span><span class="si">{1}</span><span class="s1">}, y1={0.y1:</span><span class="si">{1}</span><span class="s1">})'</span><span class="o">.</span>
            <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">'Bbox([[</span><span class="si">{0.x0}</span><span class="s1">, </span><span class="si">{0.y0}</span><span class="s1">], [</span><span class="si">{0.x1}</span><span class="s1">, </span><span class="si">{0.y1}</span><span class="s1">]])'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Bbox.ignore"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.ignore">[docs]</a>    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set whether the existing bounds of the box should be ignored</span>
<span class="sd">        by subsequent calls to :meth:`update_from_data_xy`.</span>

<span class="sd">        value : bool</span>
<span class="sd">           - When ``True``, subsequent calls to :meth:`update_from_data_xy`</span>
<span class="sd">             will ignore the existing bounds of the :class:`Bbox`.</span>

<span class="sd">           - When ``False``, subsequent calls to :meth:`update_from_data_xy`</span>
<span class="sd">             will include the existing bounds of the :class:`Bbox`.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Bbox.update_from_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.update_from_path">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Update the bounds of the :class:`Bbox` based on the passed in</span>
<span class="sd">        data.  After updating, the bounds will have positive *width*</span>
<span class="sd">        and *height*; *x0* and *y0* will be the minimal values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`~matplotlib.path.Path`</span>

<span class="sd">        ignore : bool, optional</span>
<span class="sd">           - when ``True``, ignore the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - when ``False``, include the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - when ``None``, use the last value passed to :meth:`ignore`.</span>

<span class="sd">        updatex, updatey : bool, optional</span>
<span class="sd">            When ``True``, update the x/y values.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span>

        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">points</span><span class="p">,</span> <span class="n">minpos</span><span class="p">,</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">update_path_extents</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">updatex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">updatey</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Bbox.update_from_data_xy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.update_from_data_xy">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_data_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Update the bounds of the :class:`Bbox` based on the passed in</span>
<span class="sd">        data.  After updating, the bounds will have positive *width*</span>
<span class="sd">        and *height*; *x0* and *y0* will be the minimal values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy : ndarray</span>
<span class="sd">            A numpy array of 2D points.</span>

<span class="sd">        ignore : bool, optional</span>
<span class="sd">           - When ``True``, ignore the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - When ``False``, include the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - When ``None``, use the last value passed to :meth:`ignore`.</span>

<span class="sd">        updatex, updatey : bool, optional</span>
<span class="sd">            When ``True``, update the x/y values.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_from_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span>
                                    <span class="n">updatex</span><span class="o">=</span><span class="n">updatex</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="n">updatey</span><span class="p">)</span></div>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">y0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">y0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">x1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">y1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">y1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">p0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">p0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">p1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">intervalx</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">intervalx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">intervaly</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">intervaly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">h</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">points</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minpos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minposx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minposy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="Bbox.get_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get the points of the bounding box directly as a numpy array</span>
<span class="sd">        of the form: ``[[x0, y0], [x1, y1]]``.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span></div>

<div class="viewcode-block" id="Bbox.set_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.set_points">[docs]</a>    <span class="k">def</span> <span class="nf">set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the points of the bounding box directly from a numpy array</span>
<span class="sd">        of the form: ``[[x0, y0], [x1, y1]]``.  No error checking is</span>
<span class="sd">        performed, as this method is mainly for internal use.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">points</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.set"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set this bounding box from the "frozen" bounds of another</span>
<span class="sd">        :class:`Bbox`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_points</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.mutated"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.mutated">[docs]</a>    <span class="k">def</span> <span class="nf">mutated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">'Return whether the bbox has changed since init.'</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutatedx</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutatedy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.mutatedx"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.mutatedx">[docs]</a>    <span class="k">def</span> <span class="nf">mutatedx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">'Return whether the x-limits have changed since init.'</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Bbox.mutatedy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.mutatedy">[docs]</a>    <span class="k">def</span> <span class="nf">mutatedy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">'Return whether the y-limits have changed since init.'</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="TransformedBbox"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedBbox">[docs]</a><span class="k">class</span> <span class="nc">TransformedBbox</span><span class="p">(</span><span class="n">BboxBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A :class:`Bbox` that is automatically transformed by a given</span>
<span class="sd">    transform.  When either the child bounding box or transform</span>
<span class="sd">    changes, the bounds of this bbox will update accordingly.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bbox : :class:`Bbox`</span>

<span class="sd">        transform : :class:`Transform`</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'bbox' is not a bbox"</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'transform' must be an instance of "</span>
                             <span class="s2">"'matplotlib.transform.Transform'"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transform</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">transform</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"The input and output dimensions of 'transform' must be 2"</span><span class="p">)</span>

        <span class="n">BboxBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="p">),</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">)))</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="c1"># Transform all four points, then make a new bounding box</span>
            <span class="c1"># from the result, taking care to make the orientation the</span>
            <span class="c1"># same.</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                 <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                 <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                 <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]])</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="n">xs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">ys</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>
    <span class="n">get_points</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">get_points</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_get_points</span> <span class="o">=</span> <span class="n">get_points</span>

<div class="viewcode-block" id="TransformedBbox.get_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedBbox.get_points">[docs]</a>        <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">points</span></div></div>


<div class="viewcode-block" id="LockableBbox"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.LockableBbox">[docs]</a><span class="k">class</span> <span class="nc">LockableBbox</span><span class="p">(</span><span class="n">BboxBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A :class:`Bbox` where some elements may be locked at certain values.</span>

<span class="sd">    When the child bounding box changes, the bounds of this bbox will update</span>
<span class="sd">    accordingly with the exception of the locked elements.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bbox : Bbox</span>
<span class="sd">            The child bounding box to wrap.</span>

<span class="sd">        x0 : float or None</span>
<span class="sd">            The locked value for x0, or None to leave unlocked.</span>

<span class="sd">        y0 : float or None</span>
<span class="sd">            The locked value for y0, or None to leave unlocked.</span>

<span class="sd">        x1 : float or None</span>
<span class="sd">            The locked value for x1, or None to leave unlocked.</span>

<span class="sd">        y1 : float or None</span>
<span class="sd">            The locked value for y1, or None to leave unlocked.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'bbox' is not a bbox"</span><span class="p">)</span>

        <span class="n">BboxBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="p">),</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">)))</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                                    <span class="n">points</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>
    <span class="n">get_points</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">get_points</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_get_points</span> <span class="o">=</span> <span class="n">get_points</span>

<div class="viewcode-block" id="LockableBbox.get_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.LockableBbox.get_points">[docs]</a>        <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">points</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locked_x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        float or None: The value used for the locked x0.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@locked_x0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">locked_x0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locked_y0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        float or None: The value used for the locked y0.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@locked_y0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">locked_y0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locked_x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        float or None: The value used for the locked x1.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@locked_x1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">locked_x1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locked_y1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        float or None: The value used for the locked y1.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@locked_y1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">locked_y1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>


<div class="viewcode-block" id="Transform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform">[docs]</a><span class="k">class</span> <span class="nc">Transform</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    The base class of all :class:`TransformNode` instances that</span>
<span class="sd">    actually perform a transformation.</span>

<span class="sd">    All non-affine transformations should be subclasses of this class.</span>
<span class="sd">    New affine transformations should be subclasses of</span>
<span class="sd">    :class:`Affine2D`.</span>

<span class="sd">    Subclasses of this class should override the following members (at</span>
<span class="sd">    minimum):</span>

<span class="sd">      - :attr:`input_dims`</span>
<span class="sd">      - :attr:`output_dims`</span>
<span class="sd">      - :meth:`transform`</span>
<span class="sd">      - :attr:`is_separable`</span>
<span class="sd">      - :attr:`has_inverse`</span>
<span class="sd">      - :meth:`inverted` (if :attr:`has_inverse` is True)</span>

<span class="sd">    If the transform needs to do something non-standard with</span>
<span class="sd">    :class:`matplotlib.path.Path` objects, such as adding curves</span>
<span class="sd">    where there were once line segments, it should override:</span>

<span class="sd">      - :meth:`transform_path`</span>
<span class="sd">    """</span>
    <span class="n">input_dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""</span>
<span class="sd">    The number of input dimensions of this transform.</span>
<span class="sd">    Must be overridden (with integers) in the subclass.</span>
<span class="sd">    """</span>

    <span class="n">output_dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""</span>
<span class="sd">    The number of output dimensions of this transform.</span>
<span class="sd">    Must be overridden (with integers) in the subclass.</span>
<span class="sd">    """</span>

    <span class="n">has_inverse</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">"""True if this transform has a corresponding inverse transform."""</span>

    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">"""True if this transform is separable in the x- and y- dimensions."""</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Composes two transforms together such that *self* is followed</span>
<span class="sd">        by *other*.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">composite_transform_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">"Can not add Transform to object of type '</span><span class="si">%s</span><span class="s2">'"</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Composes two transforms together such that *self* is followed</span>
<span class="sd">        by *other*.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">composite_transform_factory</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">"Can not add Transform to object of type '</span><span class="si">%s</span><span class="s2">'"</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="c1"># Equality is based on object identity for `Transform`s (so we don't</span>
    <span class="c1"># override `__eq__`), but some subclasses, such as TransformWrapper &amp;</span>
    <span class="c1"># AffineBase, override this behavior.</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns an iterator breaking down this transform stack from left to</span>
<span class="sd">        right recursively. If self == ((A, N), A) then the result will be an</span>
<span class="sd">        iterator which yields I : ((A, N), A), followed by A : (N, A),</span>
<span class="sd">        followed by (A, N) : (A), but not ((A, N), A) : I.</span>

<span class="sd">        This is equivalent to flattening the stack then yielding</span>
<span class="sd">        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).</span>

<span class="sd">        """</span>
        <span class="k">yield</span> <span class="n">IdentityTransform</span><span class="p">(),</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the number of transforms which have been chained</span>
<span class="sd">        together to form this Transform instance.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For the special case of a Composite transform, the maximum depth</span>
<span class="sd">            of the two is returned.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="mi">1</span>

<div class="viewcode-block" id="Transform.contains_branch"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.contains_branch">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return whether the given transform is a sub-tree of this transform.</span>

<span class="sd">        This routine uses transform equality to identify sub-trees, therefore</span>
<span class="sd">        in many situations it is object id which will be used.</span>

<span class="sd">        For the case where the given transform represents the whole</span>
<span class="sd">        of this transform, returns True.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># check that a subtree is equal to other (starting from self)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Transform.contains_branch_seperately"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.contains_branch_seperately">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_transform</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether the given branch is a sub-tree of this transform on</span>
<span class="sd">        each separate dimension.</span>

<span class="sd">        A common use for this method is to identify if a transform is a blended</span>
<span class="sd">        transform containing an axes' data transform. e.g.::</span>

<span class="sd">            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'contains_branch_seperately only supports '</span>
                             <span class="s1">'transforms with 2 output dimensions'</span><span class="p">)</span>
        <span class="c1"># for a non-blended transform each separate dimension is the same, so</span>
        <span class="c1"># just return the appropriate shape.</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">other_transform</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span></div>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a transform stack which goes all the way down self's transform</span>
<span class="sd">        stack, and then ascends back up other's stack. If it can, this is</span>
<span class="sd">        optimised::</span>

<span class="sd">            # normally</span>
<span class="sd">            A - B == a + b.inverted()</span>

<span class="sd">            # sometimes, when A contains the tree B there is no need to</span>
<span class="sd">            # descend all the way down to the base of A (via B), instead we</span>
<span class="sd">            # can just stop at B.</span>

<span class="sd">            (A + B) - (B)^-1 == A</span>

<span class="sd">            # similarly, when B contains tree A, we can avoid decending A at</span>
<span class="sd">            # all, basically:</span>
<span class="sd">            A - (A + B) == ((B + A) - A).inverted() or B^-1</span>

<span class="sd">        For clarity, the result of ``(A + B) - B + B == (A + B)``.</span>

<span class="sd">        """</span>
        <span class="c1"># we only know how to do this operation if other is a Transform.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">for</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">remainder</span>

        <span class="k">for</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">remainder</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The shortcut cannot be computed since "</span>
                     <span class="s2">"other's transform includes a non-invertable component."</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">remainder</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>

        <span class="c1"># if we have got this far, then there was no shortcut possible</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'It is not possible to compute transA - transB '</span>
                             <span class="s1">'since transB cannot be inverted and there is no '</span>
                             <span class="s1">'shortcut possible.'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Array interface to get at this Transform's affine matrix.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>

<div class="viewcode-block" id="Transform.transform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Performs the transformation on the given array of values.</span>

<span class="sd">        Accepts a numpy array of shape (N x :attr:`input_dims`) and</span>
<span class="sd">        returns a numpy array of shape (N x :attr:`output_dims`).</span>

<span class="sd">        Alternatively, accepts a numpy array of length :attr:`input_dims`</span>
<span class="sd">        and returns a numpy array of length :attr:`output_dims`.</span>
<span class="sd">        """</span>
        <span class="c1"># Ensure that values is a 2d array (but remember whether</span>
        <span class="c1"># we started with a 1d or 2d array).</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">))</span>

        <span class="c1"># Transform the values</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="c1"># Convert the result back to the shape of the input values.</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>  <span class="c1"># just to be on the safe side</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Input values must have shape (N x </span><span class="si">{dims}</span><span class="s2">) "</span>
            <span class="s2">"or (</span><span class="si">{dims}</span><span class="s2">)."</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">))</span></div>

<div class="viewcode-block" id="Transform.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Performs only the affine part of this transformation on the</span>
<span class="sd">        given array of values.</span>

<span class="sd">        ``transform(values)`` is always equivalent to</span>
<span class="sd">        ``transform_affine(transform_non_affine(values))``.</span>

<span class="sd">        In non-affine transformations, this is generally a no-op.  In</span>
<span class="sd">        affine transformations, this is equivalent to</span>
<span class="sd">        ``transform(values)``.</span>

<span class="sd">        Accepts a numpy array of shape (N x :attr:`input_dims`) and</span>
<span class="sd">        returns a numpy array of shape (N x :attr:`output_dims`).</span>

<span class="sd">        Alternatively, accepts a numpy array of length :attr:`input_dims`</span>
<span class="sd">        and returns a numpy array of length :attr:`output_dims`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Performs only the non-affine part of the transformation.</span>

<span class="sd">        ``transform(values)`` is always equivalent to</span>
<span class="sd">        ``transform_affine(transform_non_affine(values))``.</span>

<span class="sd">        In non-affine transformations, this is generally equivalent to</span>
<span class="sd">        ``transform(values)``.  In affine transformations, this is</span>
<span class="sd">        always a no-op.</span>

<span class="sd">        Accepts a numpy array of shape (N x :attr:`input_dims`) and</span>
<span class="sd">        returns a numpy array of shape (N x :attr:`output_dims`).</span>

<span class="sd">        Alternatively, accepts a numpy array of length :attr:`input_dims`</span>
<span class="sd">        and returns a numpy array of length :attr:`output_dims`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="Transform.transform_bbox"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_bbox">[docs]</a>    <span class="k">def</span> <span class="nf">transform_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Transform the given bounding box.</span>

<span class="sd">        Note, for smarter transforms including caching (a common</span>
<span class="sd">        requirement for matplotlib figures), see :class:`TransformedBbox`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Transform.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get the affine part of this transform.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">IdentityTransform</span><span class="p">()</span></div>

<div class="viewcode-block" id="Transform.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get the Affine transformation array for the affine part</span>
<span class="sd">        of this transform.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span></div>

<div class="viewcode-block" id="Transform.transform_point"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_point">[docs]</a>    <span class="k">def</span> <span class="nf">transform_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A convenience function that returns the transformed copy of a</span>
<span class="sd">        single point.</span>

<span class="sd">        The point is given as a sequence of length :attr:`input_dims`.</span>
<span class="sd">        The transformed point is returned as a sequence of length</span>
<span class="sd">        :attr:`output_dims`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The length of 'point' must be 'self.input_dims'"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">point</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Transform.transform_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_path">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a transformed path.</span>

<span class="sd">        *path*: a :class:`~matplotlib.path.Path` instance.</span>

<span class="sd">        In some cases, this transform may insert curves into the path</span>
<span class="sd">        that began as line segments.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">path</span><span class="p">))</span></div>

<div class="viewcode-block" id="Transform.transform_path_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_path_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a path, transformed only by the affine part of</span>
<span class="sd">        this transform.</span>

<span class="sd">        *path*: a :class:`~matplotlib.path.Path` instance.</span>

<span class="sd">        ``transform_path(path)`` is equivalent to</span>
<span class="sd">        ``transform_path_affine(transform_path_non_affine(values))``.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.transform_path_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_path_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a path, transformed only by the non-affine</span>
<span class="sd">        part of this transform.</span>

<span class="sd">        *path*: a :class:`~matplotlib.path.Path` instance.</span>

<span class="sd">        ``transform_path(path)`` is equivalent to</span>
<span class="sd">        ``transform_path_affine(transform_path_non_affine(values))``.</span>
<span class="sd">        """</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Path</span><span class="o">.</span><span class="n">_fast_from_codes_and_verts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span>
                <span class="p">{</span><span class="s1">'interpolation_steps'</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">_interpolation_steps</span><span class="p">,</span>
                 <span class="s1">'should_simplify'</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">should_simplify</span><span class="p">})</span></div>

<div class="viewcode-block" id="Transform.transform_angles"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_angles">[docs]</a>    <span class="k">def</span> <span class="nf">transform_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pushoff</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Performs transformation on a set of angles anchored at</span>
<span class="sd">        specific locations.</span>

<span class="sd">        The *angles* must be a column vector (i.e., numpy array).</span>

<span class="sd">        The *pts* must be a two-column numpy array of x,y positions</span>
<span class="sd">        (angle transforms currently only work in 2D).  This array must</span>
<span class="sd">        have the same number of rows as *angles*.</span>

<span class="sd">        *radians* indicates whether or not input angles are given in</span>
<span class="sd">         radians (True) or degrees (False; the default).</span>

<span class="sd">        *pushoff* is the distance to move away from *pts* for</span>
<span class="sd">         determining transformed angles (see discussion of method</span>
<span class="sd">         below).</span>

<span class="sd">        The transformed angles are returned in an array with the same</span>
<span class="sd">        size as *angles*.</span>

<span class="sd">        The generic version of this method uses a very generic</span>
<span class="sd">        algorithm that transforms *pts*, as well as locations very</span>
<span class="sd">        close to *pts*, to find the angle in the transformed system.</span>
<span class="sd">        """</span>
        <span class="c1"># Must be 2D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Only defined in 2D'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'pts' must be array with 2 columns for x,y"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">angles</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'angles' must be a column vector and have same "</span>
                             <span class="s2">"number of rows as 'pts'"</span><span class="p">)</span>

        <span class="c1"># Convert to radians if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">radians</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># Move a short distance away</span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">pts</span> <span class="o">+</span> <span class="n">pushoff</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)]</span>

        <span class="c1"># Transform both sets of points</span>
        <span class="n">tpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">tpts2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts2</span><span class="p">)</span>

        <span class="c1"># Calculate transformed angles</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">tpts2</span> <span class="o">-</span> <span class="n">tpts</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Convert back to degrees if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">radians</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Transform.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the corresponding inverse transformation.</span>

<span class="sd">        The return value of this method should be treated as</span>
<span class="sd">        temporary.  An update to *self* does not cause a corresponding</span>
<span class="sd">        update to its inverted copy.</span>

<span class="sd">        ``x === self.inverted().transform(self.transform(x))``</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="TransformWrapper"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformWrapper">[docs]</a><span class="k">class</span> <span class="nc">TransformWrapper</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A helper class that holds a single child transform and acts</span>
<span class="sd">    equivalently to it.</span>

<span class="sd">    This is useful if a node of the transform tree must be replaced at</span>
<span class="sd">    run time with a transform of a different type.  This class allows</span>
<span class="sd">    that replacement to correctly trigger invalidation.</span>

<span class="sd">    Note that :class:`TransformWrapper` instances must have the same</span>
<span class="sd">    input and output dimensions during their entire lifetime, so the</span>
<span class="sd">    child transform may only be replaced with another child transform</span>
<span class="sd">    of the same dimensions.</span>
<span class="sd">    """</span>
    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        *child*: A class:`Transform` instance.  This child may later</span>
<span class="sd">        be replaced with :meth:`set`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'child' must be an instance of "</span>
                             <span class="s2">"'matplotlib.transform.Transform'"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">output_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># NOTE: Transform.__[gs]etstate__ should be sufficient when using only</span>
    <span class="c1"># Python 3.4+.</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># only store the child information and parents</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">'child'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="p">,</span>
            <span class="s1">'input_dims'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">,</span>
            <span class="s1">'output_dims'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span><span class="p">,</span>
            <span class="c1"># turn the weak-values dictionary into a normal dictionary</span>
            <span class="s1">'parents'</span><span class="p">:</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">())</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span>
                            <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">))</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># re-initialise the TransformWrapper with the state's child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">'child'</span><span class="p">])</span>
        <span class="c1"># The child may not be unpickled yet, so restore its information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">'input_dims'</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">'output_dims'</span><span class="p">]</span>
        <span class="c1"># turn the normal dictionary back into a dictionary with weak</span>
        <span class="c1"># values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span>
                             <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">'parents'</span><span class="p">])</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="p">)))</span>

<div class="viewcode-block" id="TransformWrapper.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformWrapper.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">frozen</span><span class="p">()</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_child</span> <span class="o">=</span> <span class="n">child</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_non_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_non_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path_non_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">get_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inverted</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">inverted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">get_matrix</span>

        <span class="c1"># note we do not wrap other properties here since the transform's</span>
        <span class="c1"># child can be changed with WrappedTransform.set and so checking</span>
        <span class="c1"># is_affine and other such properties may be dangerous.</span>

<div class="viewcode-block" id="TransformWrapper.set"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformWrapper.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Replace the current child of this transform with another one.</span>

<span class="sd">        The new child must have the same number of input and output</span>
<span class="sd">        dimensions as the current child.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="ow">or</span>
                <span class="n">child</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"The new child must have the same number of input and output "</span>
                <span class="s2">"dimensions as the current child"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="k">def</span> <span class="nf">_get_is_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">is_affine</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_affine</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">is_separable</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_separable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_has_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">has_inverse</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_has_inverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="AffineBase"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase">[docs]</a><span class="k">class</span> <span class="nc">AffineBase</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    The base class of all affine transformations of any number of</span>
<span class="sd">    dimensions.</span>
<span class="sd">    """</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># optimises the access of the transform matrix vs the superclass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_concat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Concatenates two transformation matrices (represented as numpy</span>
<span class="sd">        arrays) together.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">"is_affine"</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

<div class="viewcode-block" id="AffineBase.transform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>
    <span class="n">transform</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="AffineBase.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Affine subclasses should override this '</span>
                                  <span class="s1">'method.'</span><span class="p">)</span></div>
    <span class="n">transform_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="AffineBase.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">points</span></div>
    <span class="n">transform_non_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="AffineBase.transform_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_path">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>
    <span class="n">transform_path</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_path</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="AffineBase.transform_path_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_path_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                    <span class="n">path</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">_interpolation_steps</span><span class="p">)</span></div>
    <span class="n">transform_path_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="AffineBase.transform_path_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_path_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span></div>
    <span class="n">transform_path_non_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="AffineBase.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    <span class="n">get_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">get_affine</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="Affine2DBase"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase">[docs]</a><span class="k">class</span> <span class="nc">Affine2DBase</span><span class="p">(</span><span class="n">AffineBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    The base class of all 2D affine transformations.</span>

<span class="sd">    2D affine transformations are performed using a 3x3 numpy array::</span>

<span class="sd">        a c e</span>
<span class="sd">        b d f</span>
<span class="sd">        0 0 1</span>

<span class="sd">    This class provides the read-only interface.  For a mutable 2D</span>
<span class="sd">    affine transformation, use :class:`Affine2D`.</span>

<span class="sd">    Subclasses of this class will generally only need to override a</span>
<span class="sd">    constructor and :meth:`get_matrix` that generates a custom 3x3 matrix.</span>
<span class="sd">    """</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">input_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">output_dims</span> <span class="o">=</span> <span class="mi">2</span>

<div class="viewcode-block" id="Affine2DBase.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">AffineBase</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">_get_is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_separable</span><span class="p">)</span>

<div class="viewcode-block" id="Affine2DBase.to_values"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.to_values">[docs]</a>    <span class="k">def</span> <span class="nf">to_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the values of the matrix as a sequence (a,b,c,d,e,f)</span>
<span class="sd">        """</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mtx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span></div>

<div class="viewcode-block" id="Affine2DBase.matrix_from_values"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.matrix_from_values">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">matrix_from_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (staticmethod) Create a new transformation matrix as a 3x3</span>
<span class="sd">        numpy array of the form::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">tpoints</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mtx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">tpoints</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">mtx</span><span class="p">)</span>

<div class="viewcode-block" id="Affine2DBase.transform_point"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.transform_point">[docs]</a>    <span class="k">def</span> <span class="nf">transform_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">affine_transform</span><span class="p">([</span><span class="n">point</span><span class="p">],</span> <span class="n">mtx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>
    <span class="n">transform_point</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">AffineBase</span><span class="o">.</span><span class="n">transform_point</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_transform_affine</span> <span class="o">=</span> <span class="n">transform_affine</span>

<div class="viewcode-block" id="Affine2DBase.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.transform_affine">[docs]</a>        <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
            <span class="c1"># The major speed trap here is just converting to the</span>
            <span class="c1"># points to an array in the first place.  If we can use</span>
            <span class="c1"># more arrays upstream, that should help here.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span><span class="s1">'A non-numpy array of type </span><span class="si">%s</span><span class="s1"> was passed in for '</span> <span class="o">+</span>
                     <span class="s1">'transformation.  Please correct this.'</span><span class="p">)</span>
                    <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>
    <span class="n">transform_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">AffineBase</span><span class="o">.</span><span class="n">transform_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Affine2DBase.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
            <span class="n">shorthand_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span><span class="p">:</span>
                <span class="n">shorthand_name</span> <span class="o">=</span> <span class="s1">'(</span><span class="si">%s</span><span class="s1">)-1'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">mtx</span><span class="p">),</span> <span class="n">shorthand_name</span><span class="o">=</span><span class="n">shorthand_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span></div>
    <span class="n">inverted</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">AffineBase</span><span class="o">.</span><span class="n">inverted</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="Affine2D"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D">[docs]</a><span class="k">class</span> <span class="nc">Affine2D</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A mutable 2D affine transformation.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Initialize an Affine transform from a 3x3 numpy float array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        If *matrix* is None, initialize with the identity transform.</span>
<span class="sd">        """</span>
        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># A bit faster than np.identity(3).</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">IdentityTransform</span><span class="o">.</span><span class="n">_mtx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)))</span>

<div class="viewcode-block" id="Affine2D.from_values"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.from_values">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (staticmethod) Create a new Affine2D instance from the given</span>
<span class="sd">        values::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Affine2D.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get the underlying transformation matrix as a 3x3 numpy array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>

<div class="viewcode-block" id="Affine2D.set_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.set_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">set_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mtx</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the underlying transformation matrix from a 3x3 numpy array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">mtx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Affine2D.set"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set this transformation from the frozen copy of another</span>
<span class="sd">        :class:`Affine2DBase` object.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'other' must be an instance of "</span>
                             <span class="s2">"'matplotlib.transform.Affine2DBase'"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Affine2D.identity"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.identity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">identity</span><span class="p">():</span>
        <span class="sd">"""</span>
<span class="sd">        (staticmethod) Return a new :class:`Affine2D` object that is</span>
<span class="sd">        the identity transform.</span>

<span class="sd">        Unless this transform will be mutated later on, consider using</span>
<span class="sd">        the faster :class:`IdentityTransform` class instead.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">()</span></div>

<div class="viewcode-block" id="Affine2D.clear"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Reset the underlying matrix to the identity transform.</span>
<span class="sd">        """</span>
        <span class="c1"># A bit faster than np.identity(3).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">IdentityTransform</span><span class="o">.</span><span class="n">_mtx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.rotate"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a rotation (in radians) to this transform in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        """</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">rotate_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                              <span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotate_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.rotate_deg"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.rotate_deg">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_deg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a rotation (in degrees) to this transform in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">degrees</span><span class="p">))</span></div>

<div class="viewcode-block" id="Affine2D.rotate_around"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.rotate_around">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_around</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a rotation (in radians) around the point (x, y) in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2D.rotate_deg_around"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.rotate_deg_around">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_deg_around</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a rotation (in degrees) around the point (x, y) in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        """</span>
        <span class="c1"># Cast to float to avoid wraparound issues with uint8's</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">rotate_deg</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2D.translate"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Adds a translation in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        """</span>
        <span class="n">translate_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">tx</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">ty</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">translate_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.scale"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Adds a scale in place.</span>

<span class="sd">        If *sy* is None, the same scale is applied in both the *x*- and</span>
<span class="sd">        *y*-directions.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">sy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="n">sx</span>
        <span class="n">scale_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">sx</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scale_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.skew"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.skew">[docs]</a>    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xShear</span><span class="p">,</span> <span class="n">yShear</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Adds a skew in place.</span>

<span class="sd">        *xShear* and *yShear* are the shear angles along the *x*- and</span>
<span class="sd">        *y*-axes, respectively, in radians.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        """</span>
        <span class="n">rotX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">xShear</span><span class="p">)</span>
        <span class="n">rotY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">yShear</span><span class="p">)</span>
        <span class="n">skew_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">rotX</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">rotY</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">skew_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.skew_deg"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.skew_deg">[docs]</a>    <span class="k">def</span> <span class="nf">skew_deg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xShear</span><span class="p">,</span> <span class="n">yShear</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Adds a skew in place.</span>

<span class="sd">        *xShear* and *yShear* are the shear angles along the *x*- and</span>
<span class="sd">        *y*-axes, respectively, in degrees.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">xShear</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">yShear</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_separable</span><span class="p">)</span></div>


<div class="viewcode-block" id="IdentityTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform">[docs]</a><span class="k">class</span> <span class="nc">IdentityTransform</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A special class that does one thing, the identity transform, in a</span>
<span class="sd">    fast way.</span>
<span class="sd">    """</span>
    <span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<div class="viewcode-block" id="IdentityTransform.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">()"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

<div class="viewcode-block" id="IdentityTransform.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="IdentityTransform.transform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>
    <span class="n">transform</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="n">transform_affine</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="n">transform_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_affine</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="n">transform_non_affine</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="n">transform_non_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="IdentityTransform.transform_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.transform_path">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span></div>
    <span class="n">transform_path</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_path</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="n">transform_path_affine</span> <span class="o">=</span> <span class="n">transform_path</span>
    <span class="n">transform_path_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="n">transform_path_non_affine</span> <span class="o">=</span> <span class="n">transform_path</span>
    <span class="n">transform_path_non_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="IdentityTransform.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    <span class="n">get_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_affine</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="n">inverted</span> <span class="o">=</span> <span class="n">get_affine</span>
    <span class="n">inverted</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">inverted</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="BlendedGenericTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform">[docs]</a><span class="k">class</span> <span class="nc">BlendedGenericTransform</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A "blended" transform uses one transform for the *x*-direction, and</span>
<span class="sd">    another transform for the *y*-direction.</span>

<span class="sd">    This "generic" version can handle any given child transform in the</span>
<span class="sd">    *x*- and *y*-directions.</span>
<span class="sd">    """</span>
    <span class="n">input_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">output_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a new "blended" transform using *x_transform* to</span>
<span class="sd">        transform the *x*-axis and *y_transform* to transform the</span>
<span class="sd">        *y*-axis.</span>

<span class="sd">        You will generally not call this constructor directly but use</span>
<span class="sd">        the :func:`blended_transform_factory` function instead, which</span>
<span class="sd">        can determine automatically which kind of blended transform to</span>
<span class="sd">        create.</span>
<span class="sd">        """</span>
        <span class="c1"># Here we ask: "Does it blend?"</span>

        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">y_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Note, this is an exact copy of BlendedAffine2D.__eq__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">BlendedAffine2D</span><span class="p">,</span> <span class="n">BlendedGenericTransform</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

<div class="viewcode-block" id="BlendedGenericTransform.contains_branch_seperately"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.contains_branch_seperately">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="c1"># Note, this is an exact copy of BlendedAffine2D.contains_branch_seperately</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span>

<div class="viewcode-block" id="BlendedGenericTransform.contains_branch"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.contains_branch">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># a blended transform cannot possibly contain a branch from two different transforms.</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">_get_is_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">is_affine</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_affine</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_has_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">has_inverse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">has_inverse</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_has_inverse</span><span class="p">)</span>

<div class="viewcode-block" id="BlendedGenericTransform.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">blended_transform_factory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">),</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)))</span>

<div class="viewcode-block" id="BlendedGenericTransform.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span></div>
    <span class="n">transform_non_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="BlendedGenericTransform.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BlendedGenericTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">inverted</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span></div>
    <span class="n">inverted</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">inverted</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="BlendedGenericTransform.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="n">y_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="c1"># This works because we already know the transforms are</span>
                <span class="c1"># separable, though normally one would want to set b and</span>
                <span class="c1"># c to zero.</span>
                <span class="n">mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">mtx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span></div>
    <span class="n">get_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">get_affine</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="BlendedAffine2D"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedAffine2D">[docs]</a><span class="k">class</span> <span class="nc">BlendedAffine2D</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A "blended" transform uses one transform for the *x*-direction, and</span>
<span class="sd">    another transform for the *y*-direction.</span>

<span class="sd">    This version is an optimization for the case where both child</span>
<span class="sd">    transforms are of type :class:`Affine2DBase`.</span>
<span class="sd">    """</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a new "blended" transform using *x_transform* to</span>
<span class="sd">        transform the *x*-axis and *y_transform* to transform the</span>
<span class="sd">        *y*-axis.</span>

<span class="sd">        Both *x_transform* and *y_transform* must be 2D affine</span>
<span class="sd">        transforms.</span>

<span class="sd">        You will generally not call this constructor directly but use</span>
<span class="sd">        the :func:`blended_transform_factory` function instead, which</span>
<span class="sd">        can determine automatically which kind of blended transform to</span>
<span class="sd">        create.</span>
<span class="sd">        """</span>
        <span class="n">is_affine</span> <span class="o">=</span> <span class="n">x_transform</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="n">y_transform</span><span class="o">.</span><span class="n">is_affine</span>
        <span class="n">is_separable</span> <span class="o">=</span> <span class="n">x_transform</span><span class="o">.</span><span class="n">is_separable</span> <span class="ow">and</span> <span class="n">y_transform</span><span class="o">.</span><span class="n">is_separable</span>
        <span class="n">is_correct</span> <span class="o">=</span> <span class="n">is_affine</span> <span class="ow">and</span> <span class="n">is_separable</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_correct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Both *x_transform* and *y_transform* must be 2D "</span>
                             <span class="s2">"affine transforms"</span><span class="p">)</span>

        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">y_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Note, this is an exact copy of BlendedGenericTransform.__eq__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">BlendedAffine2D</span><span class="p">,</span> <span class="n">BlendedGenericTransform</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

<div class="viewcode-block" id="BlendedAffine2D.contains_branch_seperately"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedAffine2D.contains_branch_seperately">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="c1"># Note, this is an exact copy of BlendedTransform.contains_branch_seperately</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">),</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)))</span>

<div class="viewcode-block" id="BlendedAffine2D.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedAffine2D.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="n">y_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="c1"># This works because we already know the transforms are</span>
                <span class="c1"># separable, though normally one would want to set b and</span>
                <span class="c1"># c to zero.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="blended_transform_factory"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.blended_transform_factory">[docs]</a><span class="k">def</span> <span class="nf">blended_transform_factory</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Create a new "blended" transform using *x_transform* to transform</span>
<span class="sd">    the *x*-axis and *y_transform* to transform the *y*-axis.</span>

<span class="sd">    A faster version of the blended transform is returned for the case</span>
<span class="sd">    where both child transforms are affine.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_transform</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">BlendedAffine2D</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BlendedGenericTransform</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span></div>


<div class="viewcode-block" id="CompositeGenericTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform">[docs]</a><span class="k">class</span> <span class="nc">CompositeGenericTransform</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A composite transform formed by applying transform *a* then</span>
<span class="sd">    transform *b*.</span>

<span class="sd">    This "generic" version can handle any two arbitrary</span>
<span class="sd">    transformations.</span>
<span class="sd">    """</span>
    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a new composite transform that is the result of</span>
<span class="sd">        applying transform *a* then transform *b*.</span>

<span class="sd">        You will generally not call this constructor directly but use</span>
<span class="sd">        the :func:`composite_transform_factory` function instead,</span>
<span class="sd">        which can automatically choose the best kind of composite</span>
<span class="sd">        transform instance to create.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The output dimension of 'a' must be equal to "</span>
                             <span class="s2">"the input dimensions of 'b'"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">output_dims</span>

        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">)</span>

<div class="viewcode-block" id="CompositeGenericTransform.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">frozen</span> <span class="o">=</span> <span class="n">composite_transform_factory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frozen</span><span class="p">,</span> <span class="n">CompositeGenericTransform</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">frozen</span><span class="o">.</span><span class="n">frozen</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">frozen</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="p">):</span>
        <span class="c1"># In some cases for a composite transform, an invalidating call to AFFINE_ONLY needs</span>
        <span class="c1"># to be extended to invalidate the NON_AFFINE part too. These cases are when the right</span>
        <span class="c1"># hand transform is non-affine and either:</span>
        <span class="c1"># (a) the left hand transform is non affine</span>
        <span class="c1"># (b) it is the left hand node which has triggered the invalidation</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">Transform</span><span class="o">.</span><span class="n">INVALID_AFFINE</span> \
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span> \
            <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">or</span> <span class="n">invalidating_node</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">):</span>

            <span class="n">value</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">INVALID</span>

        <span class="n">Transform</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                       <span class="n">invalidating_node</span><span class="o">=</span><span class="n">invalidating_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">CompositeGenericTransform</span><span class="p">,</span> <span class="n">CompositeAffine2D</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_a</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span>
        <span class="k">for</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">+</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">depth</span>

    <span class="k">def</span> <span class="nf">_get_is_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_affine</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_separable</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_separable</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_separable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">),</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)))</span>

<div class="viewcode-block" id="CompositeGenericTransform.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.transform_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>
    <span class="n">transform_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="CompositeGenericTransform.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">points</span><span class="p">))</span></div>
    <span class="n">transform_non_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="CompositeGenericTransform.transform_path_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_path</span><span class="p">(</span><span class="n">path</span><span class="p">))</span></div>
    <span class="n">transform_path_non_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="CompositeGenericTransform.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()))</span></div>
    <span class="n">get_affine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">get_affine</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="CompositeGenericTransform.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CompositeGenericTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">inverted</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span></div>
    <span class="n">inverted</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">inverted</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">_get_has_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">has_inverse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">has_inverse</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_has_inverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="CompositeAffine2D"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeAffine2D">[docs]</a><span class="k">class</span> <span class="nc">CompositeAffine2D</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A composite transform formed by applying transform *a* then transform *b*.</span>

<span class="sd">    This version is an optimization that handles the case where both *a*</span>
<span class="sd">    and *b* are 2D affines.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a new composite transform that is the result of</span>
<span class="sd">        applying transform *a* then transform *b*.</span>

<span class="sd">        Both *a* and *b* must be instances of :class:`Affine2DBase`.</span>

<span class="sd">        You will generally not call this constructor directly but use</span>
<span class="sd">        the :func:`composite_transform_factory` function instead,</span>
<span class="sd">        which can automatically choose the best kind of composite</span>
<span class="sd">        transform instance to create.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'a' and 'b' must be affine transforms"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The output dimension of 'a' must be equal to "</span>
                             <span class="s2">"the input dimensions of 'b'"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">output_dims</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">depth</span>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span>
        <span class="k">for</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">+</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">),</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)))</span>

<div class="viewcode-block" id="CompositeAffine2D.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeAffine2D.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="composite_transform_factory"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.composite_transform_factory">[docs]</a><span class="k">def</span> <span class="nf">composite_transform_factory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Create a new composite transform that is the result of applying</span>
<span class="sd">    transform a then transform b.</span>

<span class="sd">    Shortcut versions of the blended transform are provided for the</span>
<span class="sd">    case where both child transforms are affine, or one or the other</span>
<span class="sd">    is the identity transform.</span>

<span class="sd">    Composite transforms may also be created using the '+' operator,</span>
<span class="sd">    e.g.::</span>

<span class="sd">      c = a + b</span>
<span class="sd">    """</span>
    <span class="c1"># check to see if any of a or b are IdentityTransforms. We use</span>
    <span class="c1"># isinstance here to guarantee that the transforms will *always*</span>
    <span class="c1"># be IdentityTransforms. Since TransformWrappers are mutable,</span>
    <span class="c1"># use of equality here would be wrong.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">IdentityTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">IdentityTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Affine2D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Affine2D</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CompositeAffine2D</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CompositeGenericTransform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>


<div class="viewcode-block" id="BboxTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransform">[docs]</a><span class="k">class</span> <span class="nc">BboxTransform</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    :class:`BboxTransform` linearly transforms points from one</span>
<span class="sd">    :class:`Bbox` to another :class:`Bbox`.</span>
<span class="sd">    """</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxin</span><span class="p">,</span> <span class="n">boxout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a new :class:`BboxTransform` that linearly transforms</span>
<span class="sd">        points from *boxin* to *boxout*.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxin</span><span class="o">.</span><span class="n">is_bbox</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">boxout</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'boxin' and 'boxout' must be bbox"</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span> <span class="o">=</span> <span class="n">boxin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span> <span class="o">=</span> <span class="n">boxout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxin</span><span class="p">,</span> <span class="n">boxout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="p">),</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="p">)))</span>

<div class="viewcode-block" id="BboxTransform.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">inl</span><span class="p">,</span> <span class="n">inb</span><span class="p">,</span> <span class="n">inw</span><span class="p">,</span> <span class="n">inh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">outl</span><span class="p">,</span> <span class="n">outb</span><span class="p">,</span> <span class="n">outw</span><span class="p">,</span> <span class="n">outh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">x_scale</span> <span class="o">=</span> <span class="n">outw</span> <span class="o">/</span> <span class="n">inw</span>
            <span class="n">y_scale</span> <span class="o">=</span> <span class="n">outh</span> <span class="o">/</span> <span class="n">inh</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x_scale</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y_scale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Transforming from or to a singular bounding box."</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x_scale</span><span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inl</span><span class="o">*</span><span class="n">x_scale</span><span class="o">+</span><span class="n">outl</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="n">y_scale</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inb</span><span class="o">*</span><span class="n">y_scale</span><span class="o">+</span><span class="n">outb</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">1.0</span>        <span class="p">]],</span>
                                 <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="BboxTransformTo"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformTo">[docs]</a><span class="k">class</span> <span class="nc">BboxTransformTo</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    :class:`BboxTransformTo` is a transformation that linearly</span>
<span class="sd">    transforms points from the unit bounding box to a given</span>
<span class="sd">    :class:`Bbox`.</span>
<span class="sd">    """</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a new :class:`BboxTransformTo` that linearly transforms</span>
<span class="sd">        points from the unit bounding box to *boxout*.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxout</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'boxout' must be bbox"</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span> <span class="o">=</span> <span class="n">boxout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="p">)))</span>

<div class="viewcode-block" id="BboxTransformTo.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformTo.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">outl</span><span class="p">,</span> <span class="n">outb</span><span class="p">,</span> <span class="n">outw</span><span class="p">,</span> <span class="n">outh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">outw</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">outh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Transforming to a singular bounding box."</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">outw</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="n">outl</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">outh</span><span class="p">,</span> <span class="n">outb</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">]],</span>
                                  <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="BboxTransformToMaxOnly"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformToMaxOnly">[docs]</a><span class="k">class</span> <span class="nc">BboxTransformToMaxOnly</span><span class="p">(</span><span class="n">BboxTransformTo</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    :class:`BboxTransformTo` is a transformation that linearly</span>
<span class="sd">    transforms points from the unit bounding box to a given</span>
<span class="sd">    :class:`Bbox` with a fixed upper left of (0, 0).</span>
<span class="sd">    """</span>
<div class="viewcode-block" id="BboxTransformToMaxOnly.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformToMaxOnly.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">max</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ymax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Transforming to a singular bounding box."</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xmax</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                                 <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="BboxTransformFrom"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformFrom">[docs]</a><span class="k">class</span> <span class="nc">BboxTransformFrom</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    :class:`BboxTransformFrom` linearly transforms points from a given</span>
<span class="sd">    :class:`Bbox` to the unit bounding box.</span>
<span class="sd">    """</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxin</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxin</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'boxin' must be bbox"</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span> <span class="o">=</span> <span class="n">boxin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="p">)))</span>

<div class="viewcode-block" id="BboxTransformFrom.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformFrom.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">inl</span><span class="p">,</span> <span class="n">inb</span><span class="p">,</span> <span class="n">inw</span><span class="p">,</span> <span class="n">inh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inw</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">inh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Transforming from a singular bounding box."</span><span class="p">)</span>
            <span class="n">x_scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">inw</span>
            <span class="n">y_scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">inh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x_scale</span><span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inl</span><span class="o">*</span><span class="n">x_scale</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="n">y_scale</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inb</span><span class="o">*</span><span class="n">y_scale</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">1.0</span>        <span class="p">]],</span>
                                 <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="ScaledTranslation"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.ScaledTranslation">[docs]</a><span class="k">class</span> <span class="nc">ScaledTranslation</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A transformation that translates by *xt* and *yt*, after *xt* and *yt*</span>
<span class="sd">    have been transformad by the given transform *scale_trans*.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">scale_trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_trans</span> <span class="o">=</span> <span class="n">scale_trans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">scale_trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">"</span>
                    <span class="s2">"</span><span class="si">{}</span><span class="s2">)"</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">_indent_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">)))</span>

<div class="viewcode-block" id="ScaledTranslation.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.ScaledTranslation.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_trans</span><span class="o">.</span><span class="n">transform_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">xt</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">yt</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                                 <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="TransformedPath"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath">[docs]</a><span class="k">class</span> <span class="nc">TransformedPath</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A :class:`TransformedPath` caches a non-affine transformed copy of</span>
<span class="sd">    the :class:`~matplotlib.path.Path`.  This cached copy is</span>
<span class="sd">    automatically updated when the non-affine part of the transform</span>
<span class="sd">    changes.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Paths are considered immutable by this class. Any update to the</span>
<span class="sd">        path's vertices/codes will not trigger a transform recomputation.</span>

<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a new :class:`TransformedPath` from the given</span>
<span class="sd">        :class:`~matplotlib.path.Path` and :class:`Transform`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'transform' must be an instance of "</span>
                             <span class="s2">"'matplotlib.transform.Transform'"</span><span class="p">)</span>
        <span class="n">TransformNode</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_revalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># only recompute if the invalidation includes the non_affine part of the transform</span>
        <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> \
                <span class="n">Path</span><span class="o">.</span><span class="n">_fast_from_codes_and_verts</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="p">{</span><span class="s1">'interpolation_steps'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">_interpolation_steps</span><span class="p">,</span>
                     <span class="s1">'should_simplify'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">should_simplify</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="TransformedPath.get_transformed_points_and_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.get_transformed_points_and_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_transformed_points_and_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a copy of the child path, with the non-affine part of</span>
<span class="sd">        the transform already applied, along with the affine part of</span>
<span class="sd">        the path necessary to complete the transformation.  Unlike</span>
<span class="sd">        :meth:`get_transformed_path_and_affine`, no interpolation will</span>
<span class="sd">        be performed.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransformedPath.get_transformed_path_and_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.get_transformed_path_and_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_transformed_path_and_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a copy of the child path, with the non-affine part of</span>
<span class="sd">        the transform already applied, along with the affine part of</span>
<span class="sd">        the path necessary to complete the transformation.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransformedPath.get_fully_transformed_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.get_fully_transformed_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_fully_transformed_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a fully-transformed copy of the child path.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransformedPath.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="TransformedPatchPath"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPatchPath">[docs]</a><span class="k">class</span> <span class="nc">TransformedPatchPath</span><span class="p">(</span><span class="n">TransformedPath</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A :class:`TransformedPatchPath` caches a non-affine transformed copy of</span>
<span class="sd">    the :class:`~matplotlib.path.Patch`. This cached copy is automatically</span>
<span class="sd">    updated when the non-affine part of the transform or the patch changes.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patch</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a new :class:`TransformedPatchPath` from the given</span>
<span class="sd">        :class:`~matplotlib.path.Patch`.</span>
<span class="sd">        """</span>
        <span class="n">TransformNode</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="n">patch</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patch</span> <span class="o">=</span> <span class="n">patch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">patch</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_revalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">patch_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
        <span class="c1"># Only recompute if the invalidation includes the non_affine part of</span>
        <span class="c1"># the transform, or the Patch's Path has changed.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">!=</span> <span class="n">patch_path</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span> <span class="o">==</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">patch_path</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">patch_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> \
                <span class="n">Path</span><span class="o">.</span><span class="n">_fast_from_codes_and_verts</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">patch_path</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="p">{</span><span class="s1">'interpolation_steps'</span><span class="p">:</span> <span class="n">patch_path</span><span class="o">.</span><span class="n">_interpolation_steps</span><span class="p">,</span>
                     <span class="s1">'should_simplify'</span><span class="p">:</span> <span class="n">patch_path</span><span class="o">.</span><span class="n">should_simplify</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="nonsingular"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.nonsingular">[docs]</a><span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">tiny</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Modify the endpoints of a range as needed to avoid singularities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vmin, vmax : float</span>
<span class="sd">        The initial endpoints.</span>
<span class="sd">    expander : float, optional, default: 0.001</span>
<span class="sd">        Fractional amount by which *vmin* and *vmax* are expanded if</span>
<span class="sd">        the original interval is too small, based on *tiny*.</span>
<span class="sd">    tiny : float, optional, default: 1e-15</span>
<span class="sd">        Threshold for the ratio of the interval to the maximum absolute</span>
<span class="sd">        value of its endpoints.  If the interval is smaller than</span>
<span class="sd">        this, it will be expanded.  This value should be around</span>
<span class="sd">        1e-15 or larger; otherwise the interval will be approaching</span>
<span class="sd">        the double precision resolution limit.</span>
<span class="sd">    increasing : bool, optional, default: True</span>
<span class="sd">        If True, swap *vmin*, *vmax* if *vmin* &gt; *vmax*.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vmin, vmax : float</span>
<span class="sd">        Endpoints, expanded and/or swapped if necessary.</span>
<span class="sd">        If either input is inf or NaN, or if both inputs are 0 or very</span>
<span class="sd">        close to zero, it returns -*expander*, *expander*.</span>
<span class="sd">    """</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmin</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmax</span><span class="p">)):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">expander</span><span class="p">,</span> <span class="n">expander</span>

    <span class="n">swapped</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">vmax</span> <span class="o">&lt;</span> <span class="n">vmin</span><span class="p">:</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">maxabsvalue</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">maxabsvalue</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mf">1e6</span> <span class="o">/</span> <span class="n">tiny</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">expander</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">expander</span>

    <span class="k">elif</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span> <span class="o">&lt;=</span> <span class="n">maxabsvalue</span> <span class="o">*</span> <span class="n">tiny</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vmin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">expander</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">expander</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">-=</span> <span class="n">expander</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
            <span class="n">vmax</span> <span class="o">+=</span> <span class="n">expander</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">swapped</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">increasing</span><span class="p">:</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
    <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span></div>


<div class="viewcode-block" id="interval_contains"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.interval_contains">[docs]</a><span class="k">def</span> <span class="nf">interval_contains</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Check, inclusively, whether an interval includes a given value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interval : sequence of scalar</span>
<span class="sd">        A 2-length sequence, endpoints that define the interval.</span>
<span class="sd">    val : scalar</span>
<span class="sd">        Value to check is within interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns true if given val is within the interval.</span>
<span class="sd">    """</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">interval</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">b</span></div>


<div class="viewcode-block" id="interval_contains_open"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.interval_contains_open">[docs]</a><span class="k">def</span> <span class="nf">interval_contains_open</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Check, excluding endpoints, whether an interval includes a given value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interval : sequence of scalar</span>
<span class="sd">        A 2-length sequence, endpoints that define the interval.</span>
<span class="sd">    val : scalar</span>
<span class="sd">        Value to check is within interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns true if given val is within the interval.</span>
<span class="sd">    """</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">interval</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">b</span></div>


<div class="viewcode-block" id="offset_copy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.offset_copy">[docs]</a><span class="k">def</span> <span class="nf">offset_copy</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">'inches'</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Return a new transform with an added offset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trans : :class:`Transform` instance</span>
<span class="sd">        Any transform, to which offset will be applied.</span>
<span class="sd">    fig : :class:`~matplotlib.figure.Figure`, optional, default: None</span>
<span class="sd">        Current figure. It can be None if *units* are 'dots'.</span>
<span class="sd">    x, y : float, optional, default: 0.0</span>
<span class="sd">        Specifies the offset to apply.</span>
<span class="sd">    units : {'inches', 'points', 'dots'}, optional</span>
<span class="sd">        Units of the offset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trans : :class:`Transform` instance</span>
<span class="sd">        Transform with applied offset.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">'dots'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trans</span> <span class="o">+</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'For units of inches or points a fig kwarg is needed'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">'points'</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">/=</span> <span class="mf">72.0</span>
        <span class="n">y</span> <span class="o">/=</span> <span class="mf">72.0</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">'inches'</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'units must be dots, points, or inches'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trans</span> <span class="o">+</span> <span class="n">ScaledTranslation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="p">)</span></div>
</pre></div>
</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="footer">
        © Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br/>
      Last updated on Jun 28, 2018.
	Created using
	<ahref>Sphinx 1.7.5.
	Doc version v2.2.2-101-g15e1eadd0.
    </ahref></div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
<!--Flipcause Integration v3.0// Flipcause Integration Instructions:
Install the following code block once in the website Header (after <head> tag) -->
<style>

.fc-black_overlay{
display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;
background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;
}

.fc-white_content {
opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;
position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;
}

.fc-main-box{
opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;
}

.fc-widget_close{
opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);
position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;
}

.floating_button{
display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;
position:fixed; z-index:999999; overflow: auto;
}

@keyframes backfadesin {
   from { opacity:0; }
   to {opacity:.5;}
}

@-moz-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-webkit-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-o-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}


@-ms-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; transform: translateY(20px);}
   100% {opacity: 1; transform: translateY(0);}
}

@-moz-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -moz-transform: translateY(20px);}
   100% {opacity: 1; -moz-transform: translateY(0);}
}

@-webkit-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -webkit-transform: translateY(20px);}
   100% {opacity: 1; -webkit-transform: translateY(0);}
}

@-o-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -o-transform: translateY(20px);}
   100% {opacity: 1; -o-transform: translateY(0);}
}

@-ms-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -ms-transform: translateY(20px);}
   100% {opacity: 1; -ms-transform: translateY(0);}
}

</style>
<div class="fc-black_overlay" id="fc-fade" onclick="close_window()"></div>
<div class="fc-white_content" id="fc-light">
<div class="fc-main-box" id="fc-main">
<div class="fc-widget_close" id="fc-close" onclick="close_window()">
</div><iframe height="580" id="fc-myFrame" iframe="" scrolling="no" src="" style="border: 0;
border-radius:5px 5px 5px 5px; box-shadow:0 0 8px rgba(0, 0, 0, 0.5);" width="925"></iframe></div>
</div>
<!--END Flipcause Main Integration Code-->
</footer>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>matplotlib.axes._axes — Matplotlib 2.2.2 documentation</title>
<link href="../../../_static/mpl.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/gallery.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="../../../_static/jquery.js" type="text/javascript"></script>
<script src="../../../_static/underscore.js" type="text/javascript"></script>
<script src="../../../_static/doctools.js" type="text/javascript"></script>
<link href="../../../_static/opensearch.xml" rel="search" title="Search within Matplotlib 2.2.2 documentation" type="application/opensearchdescription+xml"/>
<link href="../../../_static/favicon.ico" rel="shortcut icon"/>
<link href="../../../genindex.html" rel="index" title="Index"/>
<link href="../../../search.html" rel="search" title="Search"/>
<link href="../../../index.html" rel="top" title="Matplotlib 2.2.2 documentation"/>
<link href="../../matplotlib.html" rel="up" title="matplotlib"/>
<link href="https://matplotlib.org/_modules/matplotlib/axes/_axes.html" rel="canonical"/>
<link href="https://matplotlib.org/_modules/matplotlib/axes/_axes.html" rel="canonical"/></head>
<body><div id="old-version-banner">
            You are reading documentation for a static version of Matplotlib.
            <a href="https://matplotlib.org/_modules/matplotlib/axes/_axes.html">This page may have been updated.</a>
</div>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../../../index.html">
<div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 2.2.2</span></div>
<img alt="matplotlib" border="0" height="125px" src="../../../_static/logo2.png"/></a>
<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../../../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../../../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li><a href="../../../index.html">home</a>| </li>
<li><a href="../../../gallery/index.html">examples</a>| </li>
<li><a href="../../../tutorials/index.html">tutorials</a>| </li>
<li><a href="../../../api/pyplot_summary.html">pyplot</a>| </li>
<li><a href="../../../contents.html">docs</a> »</li>
<li><a href="../../index.html">Module code</a> »</li>
<li><a accesskey="U" href="../../matplotlib.html">matplotlib</a> »</li>
</ul>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div id="searchbox" role="search" style="display: none">
<h3>Quick search</h3>
<div class="searchformwrapper">
<form action="../../../search.html" class="search" method="get">
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="../../../contents.html">Documentation overview</a><ul>
<li><a href="../../index.html">Module code</a><ul>
<li><a href="../../matplotlib.html">matplotlib</a><ul>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<h1>Source code for matplotlib.axes._axes</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">xrange</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">zip_longest</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">ma</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">_preprocess_data</span>

<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="k">as</span> <span class="nn">mcoll</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
<span class="kn">import</span> <span class="nn">matplotlib.contour</span> <span class="k">as</span> <span class="nn">mcontour</span>
<span class="kn">import</span> <span class="nn">matplotlib.category</span> <span class="k">as</span> <span class="nn">_</span>  <span class="c1"># &lt;-registers a category unit converter</span>
<span class="kn">import</span> <span class="nn">matplotlib.dates</span> <span class="k">as</span> <span class="nn">_</span>  <span class="c1"># &lt;-registers a date unit converter</span>
<span class="kn">import</span> <span class="nn">matplotlib.docstring</span> <span class="k">as</span> <span class="nn">docstring</span>
<span class="kn">import</span> <span class="nn">matplotlib.image</span> <span class="k">as</span> <span class="nn">mimage</span>
<span class="kn">import</span> <span class="nn">matplotlib.legend</span> <span class="k">as</span> <span class="nn">mlegend</span>
<span class="kn">import</span> <span class="nn">matplotlib.lines</span> <span class="k">as</span> <span class="nn">mlines</span>
<span class="kn">import</span> <span class="nn">matplotlib.markers</span> <span class="k">as</span> <span class="nn">mmarkers</span>
<span class="kn">import</span> <span class="nn">matplotlib.mlab</span> <span class="k">as</span> <span class="nn">mlab</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.quiver</span> <span class="k">as</span> <span class="nn">mquiver</span>
<span class="kn">import</span> <span class="nn">matplotlib.stackplot</span> <span class="k">as</span> <span class="nn">mstack</span>
<span class="kn">import</span> <span class="nn">matplotlib.streamplot</span> <span class="k">as</span> <span class="nn">mstream</span>
<span class="kn">import</span> <span class="nn">matplotlib.table</span> <span class="k">as</span> <span class="nn">mtable</span>
<span class="kn">import</span> <span class="nn">matplotlib.text</span> <span class="k">as</span> <span class="nn">mtext</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">mticker</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">mtransforms</span>
<span class="kn">import</span> <span class="nn">matplotlib.tri</span> <span class="k">as</span> <span class="nn">mtri</span>
<span class="kn">from</span> <span class="nn">matplotlib.cbook</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">_backports</span><span class="p">,</span> <span class="n">mplDeprecation</span><span class="p">,</span> <span class="n">warn_deprecated</span><span class="p">,</span>
    <span class="n">STEP_LOOKUP_MAP</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">safe_first_element</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">matplotlib.container</span> <span class="k">import</span> <span class="n">BarContainer</span><span class="p">,</span> <span class="n">ErrorbarContainer</span><span class="p">,</span> <span class="n">StemContainer</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes._base</span> <span class="k">import</span> <span class="n">_AxesBase</span><span class="p">,</span> <span class="n">_process_plot_format</span>

<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">rcParams</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span>

<span class="n">_alias_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'color'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'c'</span><span class="p">],</span>
              <span class="s1">'linewidth'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'lw'</span><span class="p">],</span>
              <span class="s1">'linestyle'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'ls'</span><span class="p">],</span>
              <span class="s1">'facecolor'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'fc'</span><span class="p">],</span>
              <span class="s1">'edgecolor'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'ec'</span><span class="p">],</span>
              <span class="s1">'markerfacecolor'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'mfc'</span><span class="p">],</span>
              <span class="s1">'markeredgecolor'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'mec'</span><span class="p">],</span>
              <span class="s1">'markeredgewidth'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'mew'</span><span class="p">],</span>
              <span class="s1">'markersize'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'ms'</span><span class="p">],</span>
             <span class="p">}</span>


<span class="k">def</span> <span class="nf">_plot_args_replacer</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">"y"</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># this can be two cases: x,y or y,c</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="c1"># this is not in data, so just assume that it is something which</span>
            <span class="c1"># will not get replaced (color spec or array like).</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">"y"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">]</span>
        <span class="c1"># it's data, but could be a color code like 'ro' or 'b--'</span>
        <span class="c1"># -&gt; warn the user in that case...</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">"Second argument </span><span class="si">{!r}</span><span class="s2"> is ambiguous: could be a color spec but "</span>
                <span class="s2">"is in data; using as data.  Either rename the entry in data "</span>
                <span class="s2">"or use three arguments to plot."</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Using arbitrary long args with data is not "</span>
                         <span class="s2">"supported due to ambiguity of arguments.</span><span class="se">\n</span><span class="s2">Use "</span>
                         <span class="s2">"multiple plotting calls instead."</span><span class="p">)</span>


<span class="c1"># The axes module contains all the wrappers to plotting functions.</span>
<span class="c1"># All the other methods should go in the _AxesBase class.</span>

<div class="viewcode-block" id="Axes"><a class="viewcode-back" href="../../../api/axes_api.html#matplotlib.axes.Axes">[docs]</a><span class="k">class</span> <span class="nc">Axes</span><span class="p">(</span><span class="n">_AxesBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    The :class:`Axes` contains most of the figure elements:</span>
<span class="sd">    :class:`~matplotlib.axis.Axis`, :class:`~matplotlib.axis.Tick`,</span>
<span class="sd">    :class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.text.Text`,</span>
<span class="sd">    :class:`~matplotlib.patches.Polygon`, etc., and sets the</span>
<span class="sd">    coordinate system.</span>

<span class="sd">    The :class:`Axes` instance supports callbacks through a callbacks</span>
<span class="sd">    attribute which is a :class:`~matplotlib.cbook.CallbackRegistry`</span>
<span class="sd">    instance.  The events you can connect to are 'xlim_changed' and</span>
<span class="sd">    'ylim_changed' and the callback will be called with func(*ax*)</span>
<span class="sd">    where *ax* is the :class:`Axes` instance.</span>
<span class="sd">    """</span>
    <span class="c1">### Labelling, legend and texts</span>

    <span class="n">aname</span> <span class="o">=</span> <span class="s1">'Axes'</span>

<div class="viewcode-block" id="Axes.get_title"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.get_title.html#matplotlib.axes.Axes.get_title">[docs]</a>    <span class="k">def</span> <span class="nf">get_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">"center"</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get an axes title.</span>

<span class="sd">        Get one of the three available axes titles. The available titles</span>
<span class="sd">        are positioned above the axes in the center, flush with the left</span>
<span class="sd">        edge, and flush with the right edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : {'center', 'left', 'right'}, str, optional</span>
<span class="sd">            Which title to get, defaults to 'center'.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        title : str</span>
<span class="sd">            The title text string.</span>

<span class="sd">        """</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'left'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_title</span><span class="p">,</span>
                     <span class="s1">'center'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                     <span class="s1">'right'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_title</span><span class="p">}[</span><span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'</span><span class="si">%s</span><span class="s2">' is not a valid location"</span> <span class="o">%</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">title</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span></div>

<div class="viewcode-block" id="Axes.set_title"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.set_title.html#matplotlib.axes.Axes.set_title">[docs]</a>    <span class="k">def</span> <span class="nf">set_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">"center"</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set a title for the axes.</span>

<span class="sd">        Set one of the three available axes titles. The available titles</span>
<span class="sd">        are positioned above the axes in the center, flush with the left</span>
<span class="sd">        edge, and flush with the right edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : str</span>
<span class="sd">            Text to use for the title</span>

<span class="sd">        fontdict : dict</span>
<span class="sd">            A dictionary controlling the appearance of the title text,</span>
<span class="sd">            the default `fontdict` is::</span>

<span class="sd">               {'fontsize': rcParams['axes.titlesize'],</span>
<span class="sd">                'fontweight' : rcParams['axes.titleweight'],</span>
<span class="sd">                'verticalalignment': 'baseline',</span>
<span class="sd">                'horizontalalignment': loc}</span>

<span class="sd">        loc : {'center', 'left', 'right'}, str, optional</span>
<span class="sd">            Which title to set, defaults to 'center'</span>

<span class="sd">        pad : float</span>
<span class="sd">            The offset of the title from the top of the axes, in points.</span>
<span class="sd">            Default is ``None`` to use rcParams['axes.titlepad'].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        text : :class:`~matplotlib.text.Text`</span>
<span class="sd">            The matplotlib text instance representing the title</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.text.Text` properties</span>
<span class="sd">            Other keyword arguments are text properties, see</span>
<span class="sd">            :class:`~matplotlib.text.Text` for a list of valid text</span>
<span class="sd">            properties.</span>
<span class="sd">        """</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'left'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_title</span><span class="p">,</span>
                     <span class="s1">'center'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                     <span class="s1">'right'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_title</span><span class="p">}[</span><span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'</span><span class="si">%s</span><span class="s2">' is not a valid location"</span> <span class="o">%</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">'fontsize'</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'axes.titlesize'</span><span class="p">],</span>
            <span class="s1">'fontweight'</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'axes.titleweight'</span><span class="p">],</span>
            <span class="s1">'verticalalignment'</span><span class="p">:</span> <span class="s1">'baseline'</span><span class="p">,</span>
            <span class="s1">'horizontalalignment'</span><span class="p">:</span> <span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'axes.titlepad'</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_title_offset_trans</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pad</span><span class="p">))</span>
        <span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fontdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fontdict</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">title</span></div>

<div class="viewcode-block" id="Axes.get_xlabel"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.get_xlabel.html#matplotlib.axes.Axes.get_xlabel">[docs]</a>    <span class="k">def</span> <span class="nf">get_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get the xlabel text string.</span>
<span class="sd">        """</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">label</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span></div>

<div class="viewcode-block" id="Axes.set_xlabel"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.set_xlabel.html#matplotlib.axes.Axes.set_xlabel">[docs]</a>    <span class="k">def</span> <span class="nf">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the label for the x-axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xlabel : str</span>
<span class="sd">            The label text.</span>

<span class="sd">        labelpad : scalar, optional, default: None</span>
<span class="sd">            Spacing in points between the label and the x-axis.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `.Text` properties</span>
<span class="sd">            `.Text` properties control the appearance of the label.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        text : for information on how override and the optional args work</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">labelpad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="n">labelpad</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_text</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.get_ylabel"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.get_ylabel.html#matplotlib.axes.Axes.get_ylabel">[docs]</a>    <span class="k">def</span> <span class="nf">get_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get the ylabel text string.</span>
<span class="sd">        """</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">label</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span></div>

<div class="viewcode-block" id="Axes.set_ylabel"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.set_ylabel.html#matplotlib.axes.Axes.set_ylabel">[docs]</a>    <span class="k">def</span> <span class="nf">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the label for the y-axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ylabel : str</span>
<span class="sd">            The label text.</span>

<span class="sd">        labelpad : scalar, optional, default: None</span>
<span class="sd">            Spacing in points between the label and the y-axis.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `.Text` properties</span>
<span class="sd">            `.Text` properties control the appearance of the label.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        text : for information on how override and the optional args work</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">labelpad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="n">labelpad</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_text</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.get_legend_handles_labels"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.get_legend_handles_labels.html#matplotlib.axes.Axes.get_legend_handles_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_legend_handles_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legend_handler_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return handles and labels for legend</span>

<span class="sd">        ``ax.legend()`` is equivalent to ::</span>

<span class="sd">          h, l = ax.get_legend_handles_labels()</span>
<span class="sd">          ax.legend(h, l)</span>

<span class="sd">        """</span>

        <span class="c1"># pass through to legend.</span>
        <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">_get_legend_handles_labels</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span>
                <span class="n">legend_handler_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="Axes.legend"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Places a legend on the axes.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            legend()</span>
<span class="sd">            legend(labels)</span>
<span class="sd">            legend(handles, labels)</span>

<span class="sd">        The call signatures correspond to three different ways how to use</span>
<span class="sd">        this method.</span>

<span class="sd">        **1. Automatic detection of elements to be shown in the legend**</span>

<span class="sd">        The elements to be added to the legend are automatically determined,</span>
<span class="sd">        when you do not pass in any extra arguments.</span>

<span class="sd">        In this case, the labels are taken from the artist. You can specify</span>
<span class="sd">        them either at artist creation or by calling the</span>
<span class="sd">        :meth:`~.Artist.set_label` method on the artist::</span>

<span class="sd">            line, = ax.plot([1, 2, 3], label='Inline label')</span>
<span class="sd">            ax.legend()</span>

<span class="sd">        or::</span>

<span class="sd">            line.set_label('Label via method')</span>
<span class="sd">            line, = ax.plot([1, 2, 3])</span>
<span class="sd">            ax.legend()</span>

<span class="sd">        Specific lines can be excluded from the automatic legend element</span>
<span class="sd">        selection by defining a label starting with an underscore.</span>
<span class="sd">        This is default for all artists, so calling `Axes.legend` without</span>
<span class="sd">        any arguments and without setting the labels manually will result in</span>
<span class="sd">        no legend being drawn.</span>


<span class="sd">        **2. Labeling existing plot elements**</span>

<span class="sd">        To make a legend for lines which already exist on the axes</span>
<span class="sd">        (via plot for instance), simply call this function with an iterable</span>
<span class="sd">        of strings, one for each legend item. For example::</span>

<span class="sd">            ax.plot([1, 2, 3])</span>
<span class="sd">            ax.legend(['A simple line'])</span>

<span class="sd">        Note: This way of using is discouraged, because the relation between</span>
<span class="sd">        plot elements and labels is only implicit by their order and can</span>
<span class="sd">        easily be mixed up.</span>


<span class="sd">        **3. Explicitly defining the elements in the legend**</span>

<span class="sd">        For full control of which artists have a legend entry, it is possible</span>
<span class="sd">        to pass an iterable of legend artists followed by an iterable of</span>
<span class="sd">        legend labels respectively::</span>

<span class="sd">            legend((line1, line2, line3), ('label1', 'label2', 'label3'))</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        handles : sequence of `.Artist`, optional</span>
<span class="sd">            A list of Artists (lines, patches) to be added to the legend.</span>
<span class="sd">            Use this together with *labels*, if you need full control on what</span>
<span class="sd">            is shown in the legend and the automatic mechanism described above</span>
<span class="sd">            is not sufficient.</span>

<span class="sd">            The length of handles and labels should be the same in this</span>
<span class="sd">            case. If they are not, they are truncated to the smaller length.</span>

<span class="sd">        labels : sequence of strings, optional</span>
<span class="sd">            A list of labels to show next to the artists.</span>
<span class="sd">            Use this together with *handles*, if you need full control on what</span>
<span class="sd">            is shown in the legend and the automatic mechanism described above</span>
<span class="sd">            is not sufficient.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>

<span class="sd">        loc : int or string or pair of floats, default: 'upper right'</span>
<span class="sd">            The location of the legend. Possible codes are:</span>

<span class="sd">                ===============   =============</span>
<span class="sd">                Location String   Location Code</span>
<span class="sd">                ===============   =============</span>
<span class="sd">                'best'            0</span>
<span class="sd">                'upper right'     1</span>
<span class="sd">                'upper left'      2</span>
<span class="sd">                'lower left'      3</span>
<span class="sd">                'lower right'     4</span>
<span class="sd">                'right'           5</span>
<span class="sd">                'center left'     6</span>
<span class="sd">                'center right'    7</span>
<span class="sd">                'lower center'    8</span>
<span class="sd">                'upper center'    9</span>
<span class="sd">                'center'          10</span>
<span class="sd">                ===============   =============</span>


<span class="sd">            Alternatively can be a 2-tuple giving ``x, y`` of the lower-left</span>
<span class="sd">            corner of the legend in axes coordinates (in which case</span>
<span class="sd">            ``bbox_to_anchor`` will be ignored).</span>

<span class="sd">        bbox_to_anchor : `.BboxBase` or pair of floats</span>
<span class="sd">            Specify any arbitrary location for the legend in `bbox_transform`</span>
<span class="sd">            coordinates (default Axes coordinates).</span>

<span class="sd">            For example, to put the legend's upper right hand corner in the</span>
<span class="sd">            center of the axes the following keywords can be used::</span>

<span class="sd">               loc='upper right', bbox_to_anchor=(0.5, 0.5)</span>

<span class="sd">        ncol : integer</span>
<span class="sd">            The number of columns that the legend has. Default is 1.</span>

<span class="sd">        prop : None or :class:`matplotlib.font_manager.FontProperties` or dict</span>
<span class="sd">            The font properties of the legend. If None (default), the current</span>
<span class="sd">            :data:`matplotlib.rcParams` will be used.</span>

<span class="sd">        fontsize : int or float or {'xx-small', 'x-small', 'small', 'medium', \</span>
<span class="sd">'large', 'x-large', 'xx-large'}</span>
<span class="sd">            Controls the font size of the legend. If the value is numeric the</span>
<span class="sd">            size will be the absolute font size in points. String values are</span>
<span class="sd">            relative to the current default font size. This argument is only</span>
<span class="sd">            used if `prop` is not specified.</span>

<span class="sd">        numpoints : None or int</span>
<span class="sd">            The number of marker points in the legend when creating a legend</span>
<span class="sd">            entry for a `.Line2D` (line).</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.numpoints`.</span>

<span class="sd">        scatterpoints : None or int</span>
<span class="sd">            The number of marker points in the legend when creating</span>
<span class="sd">            a legend entry for a `.PathCollection` (scatter plot).</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.scatterpoints`.</span>

<span class="sd">        scatteryoffsets : iterable of floats</span>
<span class="sd">            The vertical offset (relative to the font size) for the markers</span>
<span class="sd">            created for a scatter plot legend entry. 0.0 is at the base the</span>
<span class="sd">            legend text, and 1.0 is at the top. To draw all markers at the</span>
<span class="sd">            same height, set to ``[0.5]``. Default is ``[0.375, 0.5, 0.3125]``.</span>

<span class="sd">        markerscale : None or int or float</span>
<span class="sd">            The relative size of legend markers compared with the originally</span>
<span class="sd">            drawn ones.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.markerscale`.</span>

<span class="sd">        markerfirst : bool</span>
<span class="sd">            If *True*, legend marker is placed to the left of the legend label.</span>
<span class="sd">            If *False*, legend marker is placed to the right of the legend</span>
<span class="sd">            label.</span>
<span class="sd">            Default is *True*.</span>

<span class="sd">        frameon : None or bool</span>
<span class="sd">            Control whether the legend should be drawn on a patch</span>
<span class="sd">            (frame).</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.frameon`.</span>

<span class="sd">        fancybox : None or bool</span>
<span class="sd">            Control whether round edges should be enabled around the</span>
<span class="sd">            :class:`~matplotlib.patches.FancyBboxPatch` which makes up the</span>
<span class="sd">            legend's background.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.fancybox`.</span>

<span class="sd">        shadow : None or bool</span>
<span class="sd">            Control whether to draw a shadow behind the legend.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.shadow`.</span>

<span class="sd">        framealpha : None or float</span>
<span class="sd">            Control the alpha transparency of the legend's background.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.framealpha`.  If shadow is activated and</span>
<span class="sd">            *framealpha* is ``None``, the default value is ignored.</span>

<span class="sd">        facecolor : None or "inherit" or a color spec</span>
<span class="sd">            Control the legend's background color.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.facecolor`.  If ``"inherit"``, it will take</span>
<span class="sd">            :rc:`axes.facecolor`.</span>

<span class="sd">        edgecolor : None or "inherit" or a color spec</span>
<span class="sd">            Control the legend's background patch edge color.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.edgecolor` If ``"inherit"``, it will take</span>
<span class="sd">            :rc:`axes.edgecolor`.</span>

<span class="sd">        mode : {"expand", None}</span>
<span class="sd">            If `mode` is set to ``"expand"`` the legend will be horizontally</span>
<span class="sd">            expanded to fill the axes area (or `bbox_to_anchor` if defines</span>
<span class="sd">            the legend's size).</span>

<span class="sd">        bbox_transform : None or :class:`matplotlib.transforms.Transform`</span>
<span class="sd">            The transform for the bounding box (`bbox_to_anchor`). For a value</span>
<span class="sd">            of ``None`` (default) the Axes'</span>
<span class="sd">            :data:`~matplotlib.axes.Axes.transAxes` transform will be used.</span>

<span class="sd">        title : str or None</span>
<span class="sd">            The legend's title. Default is no title (``None``).</span>

<span class="sd">        borderpad : float or None</span>
<span class="sd">            The fractional whitespace inside the legend border.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.borderpad`.</span>

<span class="sd">        labelspacing : float or None</span>
<span class="sd">            The vertical space between the legend entries.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.labelspacing`.</span>

<span class="sd">        handlelength : float or None</span>
<span class="sd">            The length of the legend handles.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.handlelength`.</span>

<span class="sd">        handletextpad : float or None</span>
<span class="sd">            The pad between the legend handle and text.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.handletextpad`.</span>

<span class="sd">        borderaxespad : float or None</span>
<span class="sd">            The pad between the axes and legend border.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.borderaxespad`.</span>

<span class="sd">        columnspacing : float or None</span>
<span class="sd">            The spacing between columns.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None``, which will take the value from</span>
<span class="sd">            :rc:`legend.columnspacing`.</span>

<span class="sd">        handler_map : dict or None</span>
<span class="sd">            The custom dictionary mapping instances or types to a legend</span>
<span class="sd">            handler. This `handler_map` updates the default handler map</span>
<span class="sd">            found at :func:`matplotlib.legend.Legend.get_legend_handler_map`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        :class:`matplotlib.legend.Legend` instance</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Not all kinds of artist are supported by the legend command. See</span>
<span class="sd">        :ref:`sphx_glr_tutorials_intermediate_legend_guide.py` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: gallery/api/legend.py</span>

<span class="sd">        """</span>
        <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">extra_args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">_parse_legend_args</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'legend only accepts two non-keyword arguments'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">Legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span><span class="o">.</span><span class="n">_remove_method</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">h</span><span class="p">:</span> <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'legend_'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span></div>

<div class="viewcode-block" id="Axes.text"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.text.html#matplotlib.axes.Axes.text">[docs]</a>    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">withdash</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add text to the axes.</span>

<span class="sd">        Add the text *s* to the axes at location *x*, *y* in data coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : scalars</span>
<span class="sd">            The position to place the text. By default, this is in data</span>
<span class="sd">            coordinates. The coordinate system can be changed using the</span>
<span class="sd">            *transform* parameter.</span>

<span class="sd">        s : str</span>
<span class="sd">            The text.</span>

<span class="sd">        fontdict : dictionary, optional, default: None</span>
<span class="sd">            A dictionary to override the default text properties. If fontdict</span>
<span class="sd">            is None, the defaults are determined by your rc parameters.</span>

<span class="sd">        withdash : boolean, optional, default: False</span>
<span class="sd">            Creates a `~matplotlib.text.TextWithDash` instance instead of a</span>
<span class="sd">            `~matplotlib.text.Text` instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        text : `.Text`</span>
<span class="sd">            The created `.Text` instance.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.text.Text` properties.</span>
<span class="sd">            Other miscellaneous text parameters.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Individual keyword arguments can be used to override any given</span>
<span class="sd">        parameter::</span>

<span class="sd">            &gt;&gt;&gt; text(x, y, s, fontsize=12)</span>

<span class="sd">        The default transform specifies that text is in data coords,</span>
<span class="sd">        alternatively, you can specify text in axis coords (0,0 is</span>
<span class="sd">        lower-left and 1,1 is upper-right).  The example below places</span>
<span class="sd">        text in the center of the axes::</span>

<span class="sd">            &gt;&gt;&gt; text(0.5, 0.5, 'matplotlib', horizontalalignment='center',</span>
<span class="sd">            ...      verticalalignment='center', transform=ax.transAxes)</span>

<span class="sd">        You can put a rectangular box around the text instance (e.g., to</span>
<span class="sd">        set a background color) by using the keyword `bbox`.  `bbox` is</span>
<span class="sd">        a dictionary of `~matplotlib.patches.Rectangle`</span>
<span class="sd">        properties.  For example::</span>

<span class="sd">            &gt;&gt;&gt; text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))</span>
<span class="sd">        """</span>
        <span class="n">default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">'verticalalignment'</span><span class="p">:</span> <span class="s1">'baseline'</span><span class="p">,</span>
            <span class="s1">'horizontalalignment'</span><span class="p">:</span> <span class="s1">'left'</span><span class="p">,</span>
            <span class="s1">'transform'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
            <span class="s1">'clip_on'</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

        <span class="c1"># At some point if we feel confident that TextWithDash</span>
        <span class="c1"># is robust as a drop-in replacement for Text and that</span>
        <span class="c1"># the performance impact of the heavier-weight class</span>
        <span class="c1"># isn't too significant, it may make sense to eliminate</span>
        <span class="c1"># the withdash kwarg and simply delegate whether there's</span>
        <span class="c1"># a dash to TextWithDash and dashlength.</span>
        <span class="k">if</span> <span class="n">withdash</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">TextWithDash</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fontdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fontdict</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">t</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_text</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span></div>

<div class="viewcode-block" id="Axes.annotate"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.annotate.html#matplotlib.axes.Axes.annotate">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Annotation</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">'clip_on'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_text</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span></div>
    <span class="n">annotate</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Annotation</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="c1">#### Lines and spans</span>

<div class="viewcode-block" id="Axes.axhline"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.axhline.html#matplotlib.axes.Axes.axhline">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axhline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a horizontal line across the axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : scalar, optional, default: 0</span>
<span class="sd">            y position in data coordinates of the horizontal line.</span>

<span class="sd">        xmin : scalar, optional, default: 0</span>
<span class="sd">            Should be between 0 and 1, 0 being the far left of the plot, 1 the</span>
<span class="sd">            far right of the plot.</span>

<span class="sd">        xmax : scalar, optional, default: 1</span>
<span class="sd">            Should be between 0 and 1, 0 being the far left of the plot, 1 the</span>
<span class="sd">            far right of the plot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,</span>
<span class="sd">            with the exception of 'transform':</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hlines : Add horizontal lines in data coordinates.</span>
<span class="sd">        axhspan : Add a horizontal span (rectangle) across the axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        * draw a thick red hline at 'y' = 0 that spans the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(linewidth=4, color='r')</span>

<span class="sd">        * draw a default hline at 'y' = 1 that spans the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(y=1)</span>

<span class="sd">        * draw a default hline at 'y' = .5 that spans the middle half of</span>
<span class="sd">          the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(y=.5, xmin=0.25, xmax=0.75)</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="s2">"transform"</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"'transform' is not allowed as a kwarg;"</span>
                <span class="o">+</span> <span class="s2">"axhline generates its own transform."</span><span class="p">)</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ybound</span><span class="p">()</span>

        <span class="c1"># We need to strip away the units for comparison with</span>
        <span class="c1"># non-unitized bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">scaley</span> <span class="o">=</span> <span class="p">(</span><span class="n">yy</span> <span class="o">&lt;</span> <span class="n">ymin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">yy</span> <span class="o">&gt;</span> <span class="n">ymax</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">'grid'</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="n">scaley</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="Axes.axvline"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.axvline.html#matplotlib.axes.Axes.axvline">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axvline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a vertical line across the axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : scalar, optional, default: 0</span>
<span class="sd">            x position in data coordinates of the vertical line.</span>

<span class="sd">        ymin : scalar, optional, default: 0</span>
<span class="sd">            Should be between 0 and 1, 0 being the bottom of the plot, 1 the</span>
<span class="sd">            top of the plot.</span>

<span class="sd">        ymax : scalar, optional, default: 1</span>
<span class="sd">            Should be between 0 and 1, 0 being the bottom of the plot, 1 the</span>
<span class="sd">            top of the plot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,</span>
<span class="sd">            with the exception of 'transform':</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        * draw a thick red vline at *x* = 0 that spans the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(linewidth=4, color='r')</span>

<span class="sd">        * draw a default vline at *x* = 1 that spans the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(x=1)</span>

<span class="sd">        * draw a default vline at *x* = .5 that spans the middle half of</span>
<span class="sd">          the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(x=.5, ymin=0.25, ymax=0.75)</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        vlines : Add vertical lines in data coordinates.</span>
<span class="sd">        axvspan : Add a vertical span (rectangle) across the axis.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="s2">"transform"</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"'transform' is not allowed as a kwarg;"</span>
                <span class="o">+</span> <span class="s2">"axvline generates its own transform."</span><span class="p">)</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xbound</span><span class="p">()</span>

        <span class="c1"># We need to strip away the units for comparison with</span>
        <span class="c1"># non-unitized bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">scalex</span> <span class="o">=</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">'grid'</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="n">scalex</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="Axes.axhspan"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.axhspan.html#matplotlib.axes.Axes.axhspan">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axhspan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a horizontal span (rectangle) across the axis.</span>

<span class="sd">        Draw a horizontal span (rectangle) from *ymin* to *ymax*.</span>
<span class="sd">        With the default values of *xmin* = 0 and *xmax* = 1, this</span>
<span class="sd">        always spans the xrange, regardless of the xlim settings, even</span>
<span class="sd">        if you change them, e.g., with the :meth:`set_xlim` command.</span>
<span class="sd">        That is, the horizontal extent is in axes coords: 0=left,</span>
<span class="sd">        0.5=middle, 1.0=right but the *y* location is in data</span>
<span class="sd">        coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ymin : float</span>
<span class="sd">               Lower limit of the horizontal span in data units.</span>
<span class="sd">        ymax : float</span>
<span class="sd">               Upper limit of the horizontal span in data units.</span>
<span class="sd">        xmin : float, optional, default: 0</span>
<span class="sd">               Lower limit of the vertical span in axes (relative</span>
<span class="sd">               0-1) units.</span>
<span class="sd">        xmax : float, optional, default: 1</span>
<span class="sd">               Upper limit of the vertical span in axes (relative</span>
<span class="sd">               0-1) units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Polygon : `~matplotlib.patches.Polygon`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.patches.Polygon` properties.</span>

<span class="sd">        %(Polygon)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        axvspan : Add a vertical span across the axes.</span>
<span class="sd">        """</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">'grid'</span><span class="p">)</span>

        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># first we need to strip away the units</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="Axes.axvspan"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.axvspan.html#matplotlib.axes.Axes.axvspan">[docs]</a>    <span class="k">def</span> <span class="nf">axvspan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a vertical span (rectangle) across the axes.</span>

<span class="sd">        Draw a vertical span (rectangle) from `xmin` to `xmax`.  With</span>
<span class="sd">        the default values of `ymin` = 0 and `ymax` = 1. This always</span>
<span class="sd">        spans the yrange, regardless of the ylim settings, even if you</span>
<span class="sd">        change them, e.g., with the :meth:`set_ylim` command.  That is,</span>
<span class="sd">        the vertical extent is in axes coords: 0=bottom, 0.5=middle,</span>
<span class="sd">        1.0=top but the y location is in data coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xmin : scalar</span>
<span class="sd">            Number indicating the first X-axis coordinate of the vertical</span>
<span class="sd">            span rectangle in data units.</span>
<span class="sd">        xmax : scalar</span>
<span class="sd">            Number indicating the second X-axis coordinate of the vertical</span>
<span class="sd">            span rectangle in data units.</span>
<span class="sd">        ymin : scalar, optional</span>
<span class="sd">            Number indicating the first Y-axis coordinate of the vertical</span>
<span class="sd">            span rectangle in relative Y-axis units (0-1). Default to 0.</span>
<span class="sd">        ymax : scalar, optional</span>
<span class="sd">            Number indicating the second Y-axis coordinate of the vertical</span>
<span class="sd">            span rectangle in relative Y-axis units (0-1). Default to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rectangle : matplotlib.patches.Polygon</span>
<span class="sd">            Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Optional parameters are properties of the class</span>
<span class="sd">            matplotlib.patches.Polygon.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        axhspan : Add a horizontal span across the axes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Draw a vertical, green, translucent rectangle from x = 1.25 to</span>
<span class="sd">        x = 1.55 that spans the yrange of the axes.</span>

<span class="sd">        &gt;&gt;&gt; axvspan(1.25, 1.55, facecolor='g', alpha=0.5)</span>

<span class="sd">        """</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">'grid'</span><span class="p">)</span>

        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># first we need to strip away the units</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scaley</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="Axes.hlines"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.hlines.html#matplotlib.axes.Axes.hlines">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"y"</span><span class="p">,</span> <span class="s2">"xmin"</span><span class="p">,</span> <span class="s2">"xmax"</span><span class="p">,</span> <span class="s2">"colors"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">"y"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">'k'</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">'solid'</span><span class="p">,</span>
               <span class="n">label</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot horizontal lines at each *y* from *xmin* to *xmax*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : scalar or sequence of scalar</span>
<span class="sd">            y-indexes where to plot the lines.</span>

<span class="sd">        xmin, xmax : scalar or 1D array_like</span>
<span class="sd">            Respective beginning and end of each line. If scalars are</span>
<span class="sd">            provided, all lines will have same length.</span>

<span class="sd">        colors : array_like of colors, optional, default: 'k'</span>

<span class="sd">        linestyles : ['solid' | 'dashed' | 'dashdot' | 'dotted'], optional</span>

<span class="sd">        label : string, optional, default: ''</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : `~matplotlib.collections.LineCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :  `~matplotlib.collections.LineCollection` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        vlines : vertical lines</span>
<span class="sd">        axhline: horizontal line across the axes</span>
<span class="sd">        """</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xmin</span><span class="p">):</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xmax</span><span class="p">):</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmax</span><span class="p">]</span>

        <span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[((</span><span class="n">thisxmin</span><span class="p">,</span> <span class="n">thisy</span><span class="p">),</span> <span class="p">(</span><span class="n">thisxmax</span><span class="p">,</span> <span class="n">thisy</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">thisxmin</span><span class="p">,</span> <span class="n">thisxmax</span><span class="p">,</span> <span class="n">thisy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                     <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">xmax</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmin</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">xmax</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lines</span></div>

<div class="viewcode-block" id="Axes.vlines"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.vlines.html#matplotlib.axes.Axes.vlines">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"ymin"</span><span class="p">,</span> <span class="s2">"ymax"</span><span class="p">,</span> <span class="s2">"colors"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">"x"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">vlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">'k'</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">'solid'</span><span class="p">,</span>
               <span class="n">label</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot vertical lines.</span>

<span class="sd">        Plot vertical lines at each *x* from *ymin* to *ymax*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : scalar or 1D array_like</span>
<span class="sd">            x-indexes where to plot the lines.</span>

<span class="sd">        ymin, ymax : scalar or 1D array_like</span>
<span class="sd">            Respective beginning and end of each line. If scalars are</span>
<span class="sd">            provided, all lines will have same length.</span>

<span class="sd">        colors : array_like of colors, optional, default: 'k'</span>

<span class="sd">        linestyles : ['solid' | 'dashed' | 'dashdot' | 'dotted'], optional</span>

<span class="sd">        label : string, optional, default: ''</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : `~matplotlib.collections.LineCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.collections.LineCollection` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hlines : horizontal lines</span>
<span class="sd">        axvline: vertical line across the axes</span>
<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">ymin</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">ymax</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">ymin</span><span class="p">):</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymin</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">ymax</span><span class="p">):</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymax</span><span class="p">]</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[((</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thisymin</span><span class="p">),</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thisymax</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">thisx</span><span class="p">,</span> <span class="n">thisymin</span><span class="p">,</span> <span class="n">thisymax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                     <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ymin</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ymax</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymin</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">ymax</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

            <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lines</span></div>

<div class="viewcode-block" id="Axes.eventplot"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.eventplot.html#matplotlib.axes.Axes.eventplot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"positions"</span><span class="p">,</span> <span class="s2">"lineoffsets"</span><span class="p">,</span>
                                     <span class="s2">"linelengths"</span><span class="p">,</span> <span class="s2">"linewidths"</span><span class="p">,</span>
                                     <span class="s2">"colors"</span><span class="p">,</span> <span class="s2">"linestyles"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">eventplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">'horizontal'</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">linelengths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">linestyles</span><span class="o">=</span><span class="s1">'solid'</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot identical parallel lines at the given positions.</span>

<span class="sd">        *positions* should be a 1D or 2D array-like object, with each row</span>
<span class="sd">        corresponding to a row or column of lines.</span>

<span class="sd">        This type of plot is commonly used in neuroscience for representing</span>
<span class="sd">        neural events, where it is usually called a spike raster, dot raster,</span>
<span class="sd">        or raster plot.</span>

<span class="sd">        However, it is useful in any situation where you wish to show the</span>
<span class="sd">        timing or position of multiple sets of discrete events, such as the</span>
<span class="sd">        arrival times of people to a business on each day of the month or the</span>
<span class="sd">        date of hurricanes each year of the last century.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions : 1D or 2D array-like object</span>
<span class="sd">            Each value is an event. If *positions* is a 2D array-like, each</span>
<span class="sd">            row corresponds to a row or a column of lines (depending on the</span>
<span class="sd">            *orientation* parameter).</span>

<span class="sd">        orientation : {'horizontal', 'vertical'}, optional</span>
<span class="sd">            Controls the direction of the event collections:</span>

<span class="sd">                - 'horizontal' : the lines are arranged horizontally in rows,</span>
<span class="sd">                  and are vertical.</span>
<span class="sd">                - 'vertical' : the lines are arranged vertically in columns,</span>
<span class="sd">                  and are horizontal.</span>

<span class="sd">        lineoffsets : scalar or sequence of scalars, optional, default: 1</span>
<span class="sd">            The offset of the center of the lines from the origin, in the</span>
<span class="sd">            direction orthogonal to *orientation*.</span>

<span class="sd">        linelengths : scalar or sequence of scalars, optional, default: 1</span>
<span class="sd">            The total height of the lines (i.e. the lines stretches from</span>
<span class="sd">            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).</span>

<span class="sd">        linewidths : scalar, scalar sequence or None, optional, default: None</span>
<span class="sd">            The line width(s) of the event lines, in points. If it is None,</span>
<span class="sd">            defaults to its rcParams setting.</span>

<span class="sd">        colors : color, sequence of colors or None, optional, default: None</span>
<span class="sd">            The color(s) of the event lines. If it is None, defaults to its</span>
<span class="sd">            rcParams setting.</span>

<span class="sd">        linestyles : str or tuple or a sequence of such values, optional</span>
<span class="sd">            Default is 'solid'. Valid strings are ['solid', 'dashed',</span>
<span class="sd">            'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples</span>
<span class="sd">            should be of the form::</span>

<span class="sd">                (offset, onoffseq),</span>

<span class="sd">            where *onoffseq* is an even length tuple of on and off ink</span>
<span class="sd">            in points.</span>

<span class="sd">        **kwargs : optional</span>
<span class="sd">            Other keyword arguments are line collection properties.  See</span>
<span class="sd">            :class:`~matplotlib.collections.LineCollection` for a list of</span>
<span class="sd">            the valid properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        A list of :class:`matplotlib.collections.EventCollection` objects that</span>
<span class="sd">        were added.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        For *linelengths*, *linewidths*, *colors*, and *linestyles*, if only</span>
<span class="sd">        a single value is given, that value is applied to all lines.  If an</span>
<span class="sd">        array-like is given, it must have the same length as *positions*, and</span>
<span class="sd">        each value will be applied to the corresponding row of the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span>
                                <span class="n">ydata</span><span class="o">=</span><span class="p">[</span><span class="n">lineoffsets</span><span class="p">,</span> <span class="n">linelengths</span><span class="p">],</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">lineoffsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="n">linelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">positions</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">positions</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># prevent 'singular' keys from **kwargs dict from overriding the effect</span>
        <span class="c1"># of 'plural' keyword arguments (e.g. 'color' overriding 'colors')</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">'color'</span><span class="p">)</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">'linewidth'</span><span class="p">)</span>
        <span class="n">linestyles</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">'linestyle'</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">):</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">lineoffsets</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">linelengths</span><span class="p">):</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linelengths</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linewidths</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="s1">'lower'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">linestyles</span><span class="p">):</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span>

        <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="n">linelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Early conversion of the colors into RGBA values to take care</span>
            <span class="c1"># of cases like colors='0.5' or colors='C1'.  (Issue #8193)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Will fail if any element of *colors* is None. But as long</span>
            <span class="c1"># as len(colors) == 1 or len(positions), the rest of the</span>
            <span class="c1"># code should process *colors* properly.</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
            <span class="n">lineoffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">linelengths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'lineoffsets and positions are unequal sized '</span>
                             <span class="s1">'sequences'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'linelengths and positions are unequal sized '</span>
                             <span class="s1">'sequences'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'linewidths and positions are unequal sized '</span>
                             <span class="s1">'sequences'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'colors and positions are unequal sized '</span>
                             <span class="s1">'sequences'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'linestyles and positions are unequal sized '</span>
                             <span class="s1">'sequences'</span><span class="p">)</span>

        <span class="n">colls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">lineoffset</span><span class="p">,</span> <span class="n">linelength</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">linestyle</span> <span class="ow">in</span> \
            <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="p">,</span> <span class="n">linelengths</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">,</span>
                           <span class="n">colors</span><span class="p">,</span> <span class="n">linestyles</span><span class="p">):</span>
            <span class="n">coll</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">EventCollection</span><span class="p">(</span><span class="n">position</span><span class="p">,</span>
                                         <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
                                         <span class="n">lineoffset</span><span class="o">=</span><span class="n">lineoffset</span><span class="p">,</span>
                                         <span class="n">linelength</span><span class="o">=</span><span class="n">linelength</span><span class="p">,</span>
                                         <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
                                         <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                         <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">coll</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">coll</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">colls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coll</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># try to get min/max</span>
            <span class="n">min_max</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_p</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_p</span><span class="p">))</span> <span class="k">for</span> <span class="n">_p</span> <span class="ow">in</span> <span class="n">positions</span>
                       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># if we have any non-empty positions, try to autoscale</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mins</span><span class="p">,</span> <span class="n">maxes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">min_max</span><span class="p">)</span>
                <span class="n">minpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mins</span><span class="p">)</span>
                <span class="n">maxpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">maxes</span><span class="p">)</span>

                <span class="n">minline</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffsets</span> <span class="o">-</span> <span class="n">linelengths</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">maxline</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffsets</span> <span class="o">+</span> <span class="n">linelengths</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">orientation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                        <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"vertical"</span><span class="p">):</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minline</span><span class="p">,</span> <span class="n">minpos</span><span class="p">),</span> <span class="p">(</span><span class="n">maxline</span><span class="p">,</span> <span class="n">maxpos</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># "horizontal", None or "none" (see EventCollection)</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minpos</span><span class="p">,</span> <span class="n">minline</span><span class="p">),</span> <span class="p">(</span><span class="n">maxpos</span><span class="p">,</span> <span class="n">maxline</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">colls</span></div>

    <span class="c1"># ### Basic plotting</span>
    <span class="c1"># The label_naming happens in `matplotlib.axes._base._plot_args`</span>
<div class="viewcode-block" id="Axes.plot"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span>
                      <span class="n">positional_parameter_names</span><span class="o">=</span><span class="n">_plot_args_replacer</span><span class="p">,</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot y versus x as lines and/or markers.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            plot([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        The coordinates of the points or line nodes are given by *x*, *y*.</span>

<span class="sd">        The optional parameter *fmt* is a convenient way for defining basic</span>
<span class="sd">        formatting like color, marker and linestyle. It's a shortcut string</span>
<span class="sd">        notation described in the *Notes* section below.</span>

<span class="sd">        &gt;&gt;&gt; plot(x, y)        # plot x and y using default line style and color</span>
<span class="sd">        &gt;&gt;&gt; plot(x, y, 'bo')  # plot x and y using blue circle markers</span>
<span class="sd">        &gt;&gt;&gt; plot(y)           # plot y using x as index array 0..N-1</span>
<span class="sd">        &gt;&gt;&gt; plot(y, 'r+')     # ditto, but with red plusses</span>

<span class="sd">        You can use `.Line2D` properties as keyword arguments for more</span>
<span class="sd">        control on the  appearance. Line properties and *fmt* can be mixed.</span>
<span class="sd">        The following two calls yield identical results:</span>

<span class="sd">        &gt;&gt;&gt; plot(x, y, 'go--', linewidth=2, markersize=12)</span>
<span class="sd">        &gt;&gt;&gt; plot(x, y, color='green', marker='o', linestyle='dashed',</span>
<span class="sd">                linewidth=2, markersize=12)</span>

<span class="sd">        When conflicting with *fmt*, keyword arguments take precedence.</span>

<span class="sd">        **Plotting labelled data**</span>

<span class="sd">        There's a convenient way for plotting objects with labelled data (i.e.</span>
<span class="sd">        data that can be accessed by index ``obj['y']``). Instead of giving</span>
<span class="sd">        the data in *x* and *y*, you can provide the object in the *data*</span>
<span class="sd">        parameter and just give the labels for *x* and *y*::</span>

<span class="sd">        &gt;&gt;&gt; plot('xlabel', 'ylabel', data=obj)</span>

<span class="sd">        All indexable objects are supported. This could e.g. be a `dict`, a</span>
<span class="sd">        `pandas.DataFame` or a structured numpy array.</span>


<span class="sd">        **Plotting multiple sets of data**</span>

<span class="sd">        There are various ways to plot multiple sets of data.</span>

<span class="sd">        - The most straight forward way is just to call `plot` multiple times.</span>
<span class="sd">          Example:</span>

<span class="sd">          &gt;&gt;&gt; plot(x1, y1, 'bo')</span>
<span class="sd">          &gt;&gt;&gt; plot(x2, y2, 'go')</span>

<span class="sd">        - Alternatively, if your data is already a 2d array, you can pass it</span>
<span class="sd">          directly to *x*, *y*. A separate data set will be drawn for every</span>
<span class="sd">          column.</span>

<span class="sd">          Example: an array ``a`` where the first column represents the *x*</span>
<span class="sd">          values and the other columns are the *y* columns::</span>

<span class="sd">          &gt;&gt;&gt; plot(a[0], a[1:])</span>

<span class="sd">        - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*</span>
<span class="sd">          groups::</span>

<span class="sd">          &gt;&gt;&gt; plot(x1, y1, 'g^', x2, y2, 'g-')</span>

<span class="sd">          In this case, any additional keyword argument applies to all</span>
<span class="sd">          datasets. Also this syntax cannot be combined with the *data*</span>
<span class="sd">          parameter.</span>

<span class="sd">        By default, each line is assigned a different style specified by a</span>
<span class="sd">        'style cycle'. The *fmt* and line property parameters are only</span>
<span class="sd">        necessary if you want explicit deviations from these defaults.</span>
<span class="sd">        Alternatively, you can also change the style cycle using the</span>
<span class="sd">        'axes.prop_cycle' rcParam.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like or scalar</span>
<span class="sd">            The horizontal / vertical coordinates of the data points.</span>
<span class="sd">            *x* values are optional. If not given, they default to</span>
<span class="sd">            ``[0, ..., N-1]``.</span>

<span class="sd">            Commonly, these parameters are arrays of length N. However,</span>
<span class="sd">            scalars are supported as well (equivalent to an array with</span>
<span class="sd">            constant value).</span>

<span class="sd">            The parameters can also be 2-dimensional. Then, the columns</span>
<span class="sd">            represent separate data sets.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            A format string, e.g. 'ro' for red circles. See the *Notes*</span>
<span class="sd">            section for a full description of the format strings.</span>

<span class="sd">            Format strings are just an abbreviation for quickly setting</span>
<span class="sd">            basic line properties. All of these and more can also be</span>
<span class="sd">            controlled by keyword arguments.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            An object with labelled data. If given, provide the label names to</span>
<span class="sd">            plot in *x* and *y*.</span>

<span class="sd">            .. note::</span>
<span class="sd">                Technically there's a slight ambiguity in calls where the</span>
<span class="sd">                second label is a valid *fmt*. `plot('n', 'o', data=obj)`</span>
<span class="sd">                could be `plt(x, y)` or `plt(y, fmt)`. In such cases,</span>
<span class="sd">                the former interpretation is chosen, but a warning is issued.</span>
<span class="sd">                You may suppress the warning by adding an empty format string</span>
<span class="sd">                `plot('n', 'o', '', data=obj)`.</span>


<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        scalex, scaley : bool, optional, default: True</span>
<span class="sd">            These parameters determined if the view limits are adapted to</span>
<span class="sd">            the data limits. The values are passed on to `autoscale_view`.</span>

<span class="sd">        **kwargs : `.Line2D` properties, optional</span>
<span class="sd">            *kwargs* are used to specify properties like a line label (for</span>
<span class="sd">            auto legends), linewidth, antialiasing, marker face color.</span>
<span class="sd">            Example::</span>

<span class="sd">            &gt;&gt;&gt; plot([1,2,3], [1,2,3], 'go-', label='line 1', linewidth=2)</span>
<span class="sd">            &gt;&gt;&gt; plot([1,2,3], [1,4,9], 'rs',  label='line 2')</span>

<span class="sd">            If you make multiple lines with one plot command, the kwargs</span>
<span class="sd">            apply to all those lines.</span>

<span class="sd">            Here is a list of available `.Line2D` properties:</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `.Line2D` objects representing the plotted data.</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scatter : XY scatter plot with markers of variing size and/or color (</span>
<span class="sd">            sometimes also called bubble chart).</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Format Strings**</span>

<span class="sd">        A format string consists of a part for color, marker and line::</span>

<span class="sd">            fmt = '[color][marker][line]'</span>

<span class="sd">        Each of them is optional. If not provided, the value from the style</span>
<span class="sd">        cycle is used. Exception: If ``line`` is given, but no ``marker``,</span>
<span class="sd">        the data will be a line without markers.</span>

<span class="sd">        **Colors**</span>

<span class="sd">        The following color abbreviations are supported:</span>

<span class="sd">        =============    ===============================</span>
<span class="sd">        character        color</span>
<span class="sd">        =============    ===============================</span>
<span class="sd">        ``'b'``          blue</span>
<span class="sd">        ``'g'``          green</span>
<span class="sd">        ``'r'``          red</span>
<span class="sd">        ``'c'``          cyan</span>
<span class="sd">        ``'m'``          magenta</span>
<span class="sd">        ``'y'``          yellow</span>
<span class="sd">        ``'k'``          black</span>
<span class="sd">        ``'w'``          white</span>
<span class="sd">        =============    ===============================</span>

<span class="sd">        If the color is the only part of the format string, you can</span>
<span class="sd">        additionally use any  `matplotlib.colors` spec, e.g. full names</span>
<span class="sd">        (``'green'``) or hex strings (``'#008000'``).</span>

<span class="sd">        **Markers**</span>

<span class="sd">        =============    ===============================</span>
<span class="sd">        character        description</span>
<span class="sd">        =============    ===============================</span>
<span class="sd">        ``'.'``          point marker</span>
<span class="sd">        ``','``          pixel marker</span>
<span class="sd">        ``'o'``          circle marker</span>
<span class="sd">        ``'v'``          triangle_down marker</span>
<span class="sd">        ``'^'``          triangle_up marker</span>
<span class="sd">        ``'&lt;'``          triangle_left marker</span>
<span class="sd">        ``'&gt;'``          triangle_right marker</span>
<span class="sd">        ``'1'``          tri_down marker</span>
<span class="sd">        ``'2'``          tri_up marker</span>
<span class="sd">        ``'3'``          tri_left marker</span>
<span class="sd">        ``'4'``          tri_right marker</span>
<span class="sd">        ``'s'``          square marker</span>
<span class="sd">        ``'p'``          pentagon marker</span>
<span class="sd">        ``'*'``          star marker</span>
<span class="sd">        ``'h'``          hexagon1 marker</span>
<span class="sd">        ``'H'``          hexagon2 marker</span>
<span class="sd">        ``'+'``          plus marker</span>
<span class="sd">        ``'x'``          x marker</span>
<span class="sd">        ``'D'``          diamond marker</span>
<span class="sd">        ``'d'``          thin_diamond marker</span>
<span class="sd">        ``'|'``          vline marker</span>
<span class="sd">        ``'_'``          hline marker</span>
<span class="sd">        =============    ===============================</span>

<span class="sd">        **Line Styles**</span>

<span class="sd">        =============    ===============================</span>
<span class="sd">        character        description</span>
<span class="sd">        =============    ===============================</span>
<span class="sd">        ``'-'``          solid line style</span>
<span class="sd">        ``'--'``         dashed line style</span>
<span class="sd">        ``'-.'``         dash-dot line style</span>
<span class="sd">        ``':'``          dotted line style</span>
<span class="sd">        =============    ===============================</span>

<span class="sd">        Example format strings::</span>

<span class="sd">            'b'    # blue markers with default shape</span>
<span class="sd">            'ro'   # red circles</span>
<span class="sd">            'g-'   # green solid line</span>
<span class="sd">            '--'   # dashed line with default color</span>
<span class="sd">            'k^:'  # black triangle_up markers connected by a dotted line</span>

<span class="sd">        """</span>
        <span class="n">scalex</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'scalex'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">scaley</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'scaley'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">_alias_map</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="n">scalex</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="n">scaley</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lines</span></div>

<div class="viewcode-block" id="Axes.plot_date"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.plot_date.html#matplotlib.axes.Axes.plot_date">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">"y"</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">plot_date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">'o'</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xdate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ydate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot data that contains dates.</span>

<span class="sd">        Similar to `.plot`, this plots *y* vs. *x* as lines or markers.</span>
<span class="sd">        However, the axis labels are formatted as dates depending on *xdate*</span>
<span class="sd">        and *ydate*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like</span>
<span class="sd">            The coordinates of the data points. If *xdate* or *ydate* is</span>
<span class="sd">            *True*, the respective values *x* or *y* are interpreted as</span>
<span class="sd">            :ref:`Matplotlib dates &lt;date-format&gt;`.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            The plot format string. For details, see the corresponding</span>
<span class="sd">            parameter in `.plot`.</span>

<span class="sd">        tz : [ *None* | timezone string | :class:`tzinfo` instance]</span>
<span class="sd">            The time zone to use in labeling dates. If *None*, defaults to</span>
<span class="sd">            rcParam ``timezone``.</span>

<span class="sd">        xdate : bool, optional, default: True</span>
<span class="sd">            If *True*, the *x*-axis will be interpreted as Matplotlib dates.</span>

<span class="sd">        ydate : bool, optional, default: False</span>
<span class="sd">            If *True*, the *y*-axis will be interpreted as Matplotlib dates.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `~.Line2D` objects representing the plotted data.</span>


<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">            %(Line2D)s</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        matplotlib.dates : Helper functions on dates.</span>
<span class="sd">        matplotlib.dates.date2num : Convert dates to num.</span>
<span class="sd">        matplotlib.dates.num2date : Convert num to dates.</span>
<span class="sd">        matplotlib.dates.drange : Create an equally spaced sequence of dates.</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you are using custom date tickers and formatters, it may be</span>
<span class="sd">        necessary to set the formatters/locators after the call to</span>
<span class="sd">        `.plot_date`. `.plot_date` will set the default tick locator to</span>
<span class="sd">        `.AutoDateLocator` (if the tick locator is not already set to a</span>
<span class="sd">        `.DateLocator` instance) and the default tick formatter to</span>
<span class="sd">        `.AutoDateFormatter` (if the tick formatter is not already set to a</span>
<span class="sd">        `.DateFormatter` instance).</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">xdate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_date</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ydate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_date</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="c1"># @_preprocess_data() # let 'plot' do the unpacking..</span>
<div class="viewcode-block" id="Axes.loglog"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.loglog.html#matplotlib.axes.Axes.loglog">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">loglog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Make a plot with log scaling on both the x and y axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            loglog([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        both the x-axis and the y-axis to log scaling. All of the concepts and</span>
<span class="sd">        parameters of plot can be used here as well.</span>

<span class="sd">        The additional parameters *basex/y*, *subsx/y* and *nonposx/y* control</span>
<span class="sd">        the x/y-axis properties. They are just forwarded to `.Axes.set_xscale`</span>
<span class="sd">        and `.Axes.set_yscale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basex, basey : scalar, optional, default 10</span>
<span class="sd">            Base of the x/y logarithm.</span>

<span class="sd">        subsx, subsy : sequence, optional</span>
<span class="sd">            The location of the minor x/y ticks. If *None*, reasonable</span>
<span class="sd">            locations are automatically chosen depending on the number of</span>
<span class="sd">            decades in the plot.</span>
<span class="sd">            See `.Axes.set_xscale` / `.Axes.set_yscale` for details.</span>

<span class="sd">        nonposx, nonposy : {'mask', 'clip'}, optional, default 'mask'</span>
<span class="sd">            Non-positive values in x or y can be masked as invalid, or clipped</span>
<span class="sd">            to a very small positive number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `~.Line2D` objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'basex'</span><span class="p">,</span> <span class="s1">'subsx'</span><span class="p">,</span> <span class="s1">'nonposx'</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'basey'</span><span class="p">,</span> <span class="s1">'subsy'</span><span class="p">,</span> <span class="s1">'nonposy'</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="o">**</span><span class="n">dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="o">**</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># we've already processed the hold</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># restore the hold</span>

        <span class="k">return</span> <span class="n">l</span></div>

    <span class="c1"># @_preprocess_data() # let 'plot' do the unpacking..</span>
<div class="viewcode-block" id="Axes.semilogx"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.semilogx.html#matplotlib.axes.Axes.semilogx">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">semilogx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Make a plot with log scaling on the x axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            semilogx([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        the x-axis to log scaling. All of the concepts and parameters of plot</span>
<span class="sd">        can be used here as well.</span>

<span class="sd">        The additional parameters *basex*, *subsx* and *nonposx* control the</span>
<span class="sd">        x-axis properties. They are just forwarded to `.Axes.set_xscale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basex : scalar, optional, default 10</span>
<span class="sd">            Base of the x logarithm.</span>

<span class="sd">        subsx : array_like, optional</span>
<span class="sd">            The location of the minor xticks. If *None*, reasonable locations</span>
<span class="sd">            are automatically chosen depending on the number of decades in the</span>
<span class="sd">            plot. See `.Axes.set_xscale` for details.</span>

<span class="sd">        nonposx : {'mask', 'clip'}, optional, default 'mask'</span>
<span class="sd">            Non-positive values in x can be masked as invalid, or clipped to a</span>
<span class="sd">            very small positive number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `~.Line2D` objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'basex'</span><span class="p">,</span> <span class="s1">'subsx'</span><span class="p">,</span> <span class="s1">'nonposx'</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># we've already processed the hold</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># restore the hold</span>
        <span class="k">return</span> <span class="n">l</span></div>

    <span class="c1"># @_preprocess_data() # let 'plot' do the unpacking..</span>
<div class="viewcode-block" id="Axes.semilogy"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.semilogy.html#matplotlib.axes.Axes.semilogy">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">semilogy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Make a plot with log scaling on the y axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            semilogy([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        the y-axis to log scaling. All of the concepts and parameters of plot</span>
<span class="sd">        can be used here as well.</span>

<span class="sd">        The additional parameters *basey*, *subsy* and *nonposy* control the</span>
<span class="sd">        y-axis properties. They are just forwarded to `.Axes.set_yscale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basey : scalar, optional, default 10</span>
<span class="sd">            Base of the y logarithm.</span>

<span class="sd">        subsy : array_like, optional</span>
<span class="sd">            The location of the minor yticks. If *None*, reasonable locations</span>
<span class="sd">            are automatically chosen depending on the number of decades in the</span>
<span class="sd">            plot. See `.Axes.set_yscale` for details.</span>

<span class="sd">        nonposy : {'mask', 'clip'}, optional, default 'mask'</span>
<span class="sd">            Non-positive values in y can be masked as invalid, or clipped to a</span>
<span class="sd">            very small positive number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `~.Line2D` objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'basey'</span><span class="p">,</span> <span class="s1">'subsy'</span><span class="p">,</span> <span class="s1">'nonposy'</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># we've already processed the hold</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># restore the hold</span>

        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="Axes.acorr"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.acorr.html#matplotlib.axes.Axes.acorr">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">"x"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">acorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot the autocorrelation of *x*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        x : sequence of scalar</span>

<span class="sd">        hold : bool, optional, *deprecated*, default: True</span>

<span class="sd">        detrend : callable, optional, default: `mlab.detrend_none`</span>
<span class="sd">            *x* is detrended by the *detrend* callable. Default is no</span>
<span class="sd">            normalization.</span>

<span class="sd">        normed : bool, optional, default: True</span>
<span class="sd">            If ``True``, input vectors are normalised to unit length.</span>

<span class="sd">        usevlines : bool, optional, default: True</span>
<span class="sd">            If ``True``, `Axes.vlines` is used to plot the vertical lines from</span>
<span class="sd">            the origin to the acorr. Otherwise, `Axes.plot` is used.</span>

<span class="sd">        maxlags : integer, optional, default: 10</span>
<span class="sd">            Number of lags to show. If ``None``, will return all</span>
<span class="sd">            ``2 * len(x) - 1`` lags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags : array (lenth ``2*maxlags+1``)</span>
<span class="sd">            lag vector.</span>
<span class="sd">        c : array  (length ``2*maxlags+1``)</span>
<span class="sd">            auto correlation vector.</span>
<span class="sd">        line : `.LineCollection` or `.Line2D`</span>
<span class="sd">            `.Artist` added to the axes of the correlation.</span>

<span class="sd">             `.LineCollection` if *usevlines* is True</span>
<span class="sd">             `.Line2D` if *usevlines* is False</span>
<span class="sd">        b : `.Line2D` or None</span>
<span class="sd">            Horizontal line at 0 if *usevlines* is True</span>
<span class="sd">            None *usevlines* is False</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        linestyle : `~matplotlib.lines.Line2D` prop, optional, default: None</span>
<span class="sd">            Only used if usevlines is ``False``.</span>

<span class="sd">        marker : string, optional, default: 'o'</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cross correlation is performed with :func:`numpy.correlate` with</span>
<span class="sd">        ``mode = 2``.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="s2">"hold"</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"the 'hold' kwarg is deprecated"</span><span class="p">,</span> <span class="n">mplDeprecation</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.xcorr"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.xcorr.html#matplotlib.axes.Axes.xcorr">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">"y"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">xcorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
              <span class="n">usevlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxlags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot the cross correlation between *x* and *y*.</span>

<span class="sd">        The correlation with lag k is defined as sum_n x[n+k] * conj(y[n]).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : sequence of scalars of length n</span>

<span class="sd">        y : sequence of scalars of length n</span>

<span class="sd">        hold : bool, optional, *deprecated*, default: True</span>

<span class="sd">        detrend : callable, optional, default: `mlab.detrend_none`</span>
<span class="sd">            *x* is detrended by the *detrend* callable. Default is no</span>
<span class="sd">            normalization.</span>

<span class="sd">        normed : bool, optional, default: True</span>
<span class="sd">            If ``True``, input vectors are normalised to unit length.</span>

<span class="sd">        usevlines : bool, optional, default: True</span>
<span class="sd">            If ``True``, `Axes.vlines` is used to plot the vertical lines from</span>
<span class="sd">            the origin to the acorr. Otherwise, `Axes.plot` is used.</span>

<span class="sd">        maxlags : int, optional</span>
<span class="sd">            Number of lags to show. If None, will return all ``2 * len(x) - 1``</span>
<span class="sd">            lags. Default is 10.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags : array (lenth ``2*maxlags+1``)</span>
<span class="sd">            lag vector.</span>
<span class="sd">        c : array  (length ``2*maxlags+1``)</span>
<span class="sd">            auto correlation vector.</span>
<span class="sd">        line : `.LineCollection` or `.Line2D`</span>
<span class="sd">            `.Artist` added to the axes of the correlation</span>

<span class="sd">             `.LineCollection` if *usevlines* is True</span>
<span class="sd">             `.Line2D` if *usevlines* is False</span>
<span class="sd">        b : `.Line2D` or None</span>
<span class="sd">            Horizontal line at 0 if *usevlines* is True</span>
<span class="sd">            None *usevlines* is False</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        linestyle : `~matplotlib.lines.Line2D` property, optional</span>
<span class="sd">            Only used if usevlines is ``False``.</span>

<span class="sd">        marker : string, optional</span>
<span class="sd">            Default is 'o'.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cross correlation is performed with :func:`numpy.correlate` with</span>
<span class="sd">        ``mode = 2``.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="s2">"hold"</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"the 'hold' kwarg is deprecated"</span><span class="p">,</span> <span class="n">mplDeprecation</span><span class="p">)</span>

        <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nx</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'x and y must be equal length'</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">correls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normed</span><span class="p">:</span>
            <span class="n">correls</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">maxlags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxlags</span> <span class="o">=</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">maxlags</span> <span class="o">&gt;=</span> <span class="n">Nx</span> <span class="ow">or</span> <span class="n">maxlags</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'maxlags must be None or strictly '</span>
                             <span class="s1">'positive &lt; </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">Nx</span><span class="p">)</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">maxlags</span><span class="p">,</span> <span class="n">maxlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">correls</span> <span class="o">=</span> <span class="n">correls</span><span class="p">[</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlags</span><span class="p">:</span><span class="n">Nx</span> <span class="o">+</span> <span class="n">maxlags</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">usevlines</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">correls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Make label empty so only vertical lines get a legend entry</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'marker'</span><span class="p">,</span> <span class="s1">'o'</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'linestyle'</span><span class="p">,</span> <span class="s1">'None'</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">correls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">lags</span><span class="p">,</span> <span class="n">correls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>

    <span class="c1">#### Specialized plotting</span>

<div class="viewcode-block" id="Axes.step"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.step.html#matplotlib.axes.Axes.step">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">"y"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Make a step plot.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            step(x, y, [fmt], *, data=None, where='pre', **kwargs)</span>
<span class="sd">            step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which changes some</span>
<span class="sd">        formatting options. Most of the concepts and parameters of plot can be</span>
<span class="sd">        used here as well.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            1-D sequence of x positions. It is assumed, but not checked, that</span>
<span class="sd">            it is uniformly increasing.</span>

<span class="sd">        y : array_like</span>
<span class="sd">            1-D sequence of y levels.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            A format string, e.g. 'g' for a green line. See `.plot` for a more</span>
<span class="sd">            detailed description.</span>

<span class="sd">            Note: While full format strings are accepted, it is recommended to</span>
<span class="sd">            only specify the color. Line styles are currently ignored (use</span>
<span class="sd">            the keyword argument *linestyle* instead). Markers are accepted</span>
<span class="sd">            and plotted on the given positions, however, this is a rarely</span>
<span class="sd">            needed feature for step plots.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            An object with labelled data. If given, provide the label names to</span>
<span class="sd">            plot in *x* and *y*.</span>

<span class="sd">        where : {'pre', 'post', 'mid'}, optional, default 'pre'</span>
<span class="sd">            Define where the steps should be placed:</span>

<span class="sd">            - 'pre': The y value is continued constantly to the left from</span>
<span class="sd">              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - 'post': The y value is continued constantly to the right from</span>
<span class="sd">              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - 'mid': Steps occur half-way between the *x* positions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `.Line2D` objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional parameters are the same as those for `.plot`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [notes section required to get data note injection right]</span>
<span class="sd">        """</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'where'</span><span class="p">,</span> <span class="s1">'pre'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">where</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'pre'</span><span class="p">,</span> <span class="s1">'post'</span><span class="p">,</span> <span class="s1">'mid'</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'where' argument to step must be "</span>
                             <span class="s2">"'pre', 'post' or 'mid'"</span><span class="p">)</span>
        <span class="n">usr_linestyle</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'linestyle'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'linestyle'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'steps-'</span> <span class="o">+</span> <span class="n">where</span> <span class="o">+</span> <span class="n">usr_linestyle</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.bar"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.bar.html#matplotlib.axes.Axes.bar">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">,</span>
                                     <span class="s2">"height"</span><span class="p">,</span> <span class="s2">"width"</span><span class="p">,</span>
                                     <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"bottom"</span><span class="p">,</span>
                                     <span class="s2">"color"</span><span class="p">,</span> <span class="s2">"edgecolor"</span><span class="p">,</span> <span class="s2">"linewidth"</span><span class="p">,</span>
                                     <span class="s2">"tick_label"</span><span class="p">,</span> <span class="s2">"xerr"</span><span class="p">,</span> <span class="s2">"yerr"</span><span class="p">,</span>
                                     <span class="s2">"ecolor"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">replace_all_args</span><span class="o">=</span><span class="kc">True</span>
                      <span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Make a bar plot.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">           bar(x, height, *, align='center', **kwargs)</span>
<span class="sd">           bar(x, height, width, *, align='center', **kwargs)</span>
<span class="sd">           bar(x, height, width, bottom, *, align='center', **kwargs)</span>

<span class="sd">        The bars are positioned at *x* with the given *align* ment. Their</span>
<span class="sd">        dimensions are given by *width* and *height*. The vertical baseline</span>
<span class="sd">        is *bottom* (default 0).</span>

<span class="sd">        Each of *x*, *height*, *width*, and *bottom* may either be a scalar</span>
<span class="sd">        applying to all bars, or it may be a sequence of length N providing a</span>
<span class="sd">        separate value for each bar.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : sequence of scalars</span>
<span class="sd">            The x coordinates of the bars. See also *align* for the</span>
<span class="sd">            alignment of the bars to the coordinates.</span>

<span class="sd">        height : scalar or sequence of scalars</span>
<span class="sd">            The height(s) of the bars.</span>

<span class="sd">        width : scalar or array-like, optional</span>
<span class="sd">            The width(s) of the bars (default: 0.8).</span>

<span class="sd">        bottom : scalar or array-like, optional</span>
<span class="sd">            The y coordinate(s) of the bars bases (default: 0).</span>

<span class="sd">        align : {'center', 'edge'}, optional, default: 'center'</span>
<span class="sd">            Alignment of the bars to the *x* coordinates:</span>

<span class="sd">            - 'center': Center the base on the *x* positions.</span>
<span class="sd">            - 'edge': Align the left edges of the bars with the *x* positions.</span>

<span class="sd">            To align the bars on the right edge pass a negative *width* and</span>
<span class="sd">            ``align='edge'``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.BarContainer`</span>
<span class="sd">            Container with all the bars and optionally errorbars.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        color : scalar or array-like, optional</span>
<span class="sd">            The colors of the bar faces.</span>

<span class="sd">        edgecolor : scalar or array-like, optional</span>
<span class="sd">            The colors of the bar edges.</span>

<span class="sd">        linewidth : scalar or array-like, optional</span>
<span class="sd">            Width of the bar edge(s). If 0, don't draw edges.</span>

<span class="sd">        tick_label : string or array-like, optional</span>
<span class="sd">            The tick labels of the bars.</span>
<span class="sd">            Default: None (Use default numeric labels.)</span>

<span class="sd">        xerr, yerr : scalar or array-like of shape(N,) or shape(2,N), optional</span>
<span class="sd">            If not *None*, add horizontal / vertical errorbars to the bar tips.</span>
<span class="sd">            The values are +/- sizes relative to the data:</span>

<span class="sd">            - scalar: symmetric +/- values for all bars</span>
<span class="sd">            - shape(N,): symmetric +/- values for each bar</span>
<span class="sd">            - shape(2,N): separate + and - values for each bar</span>

<span class="sd">            Default: None</span>

<span class="sd">        ecolor : scalar or array-like, optional, default: 'black'</span>
<span class="sd">            The line color of the errorbars.</span>

<span class="sd">        capsize : scalar, optional</span>
<span class="sd">           The length of the error bar caps in points.</span>
<span class="sd">           Default: None, which will take the value from</span>
<span class="sd">           :rc:`errorbar.capsize`.</span>

<span class="sd">        error_kw : dict, optional</span>
<span class="sd">            Dictionary of kwargs to be passed to the `~.Axes.errorbar`</span>
<span class="sd">            method. Values of *ecolor* or *capsize* defined here take</span>
<span class="sd">            precedence over the independent kwargs.</span>

<span class="sd">        log : bool, optional, default: False</span>
<span class="sd">            If *True*, set the y-axis to be log scale.</span>

<span class="sd">        orientation : {'vertical',  'horizontal'}, optional</span>
<span class="sd">            *This is for internal use only.* Please use `barh` for</span>
<span class="sd">            horizontal bar plots. Default: 'vertical'.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        barh: Plot a horizontal bar plot.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The optional arguments *color*, *edgecolor*, *linewidth*,</span>
<span class="sd">        *xerr*, and *yerr* can be either scalars or sequences of</span>
<span class="sd">        length equal to the number of bars.  This enables you to use</span>
<span class="sd">        bar as the basis for stacked bar charts, or candlestick plots.</span>
<span class="sd">        Detail: *xerr* and *yerr* are passed directly to</span>
<span class="sd">        :meth:`errorbar`, so they can also have shape 2xN for</span>
<span class="sd">        independent specification of lower and upper errors.</span>

<span class="sd">        Other optional kwargs:</span>

<span class="sd">        %(Rectangle)s</span>

<span class="sd">        """</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">_patch_alias_map</span><span class="p">)</span>
        <span class="c1"># this is using the lambdas to do the arg/kwarg unpacking rather</span>
        <span class="c1"># than trying to re-implement all of that logic our selves.</span>
        <span class="n">matchers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span>
             <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)),</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span>
             <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)),</span>
        <span class="p">]</span>
        <span class="n">exps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">matcher</span> <span class="ow">in</span> <span class="n">matchers</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">matcher</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># This can only come from a no-match as there is</span>
                <span class="c1"># no other logic in the matchers.</span>
                <span class="n">exps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># if we matched the second-case, then the user passed in</span>
        <span class="c1"># left=val as a kwarg which we want to deprecate</span>
        <span class="k">if</span> <span class="n">dp</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">"The *left* kwarg to `bar` is deprecated use *x* instead. "</span>
                <span class="s2">"Support for *left* will be removed in Matplotlib 3.0"</span><span class="p">,</span>
                <span class="n">mplDeprecation</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'color'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>
        <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'edgecolor'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">linewidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'linewidth'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Because xerr and yerr will be passed to errorbar,</span>
        <span class="c1"># most dimension checking and processing will be left</span>
        <span class="c1"># to the errorbar method.</span>
        <span class="n">xerr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'xerr'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">yerr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'yerr'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">error_kw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'error_kw'</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="n">ecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'ecolor'</span><span class="p">,</span> <span class="s1">'k'</span><span class="p">)</span>
        <span class="n">capsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'capsize'</span><span class="p">,</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">"errorbar.capsize"</span><span class="p">])</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'ecolor'</span><span class="p">,</span> <span class="n">ecolor</span><span class="p">)</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'capsize'</span><span class="p">,</span> <span class="n">capsize</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
            <span class="n">align</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'align'</span><span class="p">,</span> <span class="s1">'edge'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">align</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'align'</span><span class="p">,</span> <span class="s1">'center'</span><span class="p">)</span>

        <span class="n">orientation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'orientation'</span><span class="p">,</span> <span class="s1">'vertical'</span><span class="p">)</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
        <span class="n">tick_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'tick_label'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">adjust_ylim</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">adjust_xlim</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yscale</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'log'</span><span class="p">:</span>
                    <span class="n">adjust_ylim</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xscale</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'log'</span><span class="p">:</span>
                    <span class="n">adjust_xlim</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="n">nonposy</span><span class="o">=</span><span class="s1">'clip'</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="n">nonposx</span><span class="o">=</span><span class="s1">'clip'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'invalid orientation: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">orientation</span><span class="p">)</span>

        <span class="c1"># lets do some conversions now since some types cannot be</span>
        <span class="c1"># subtracted uniformly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span>
            <span class="c1"># Make args iterable too.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">)</span>

        <span class="c1"># Now that units have been converted, set the tick locations.</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
            <span class="n">tick_label_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span>
            <span class="n">tick_label_position</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
            <span class="n">tick_label_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span>
            <span class="n">tick_label_position</span> <span class="o">=</span> <span class="n">y</span>

        <span class="n">linewidth</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">linewidth</span><span class="p">))</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">color</span><span class="p">)),</span>
                                <span class="c1"># Fallback if color == "none".</span>
                                <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">edgecolor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">edgecolor</span><span class="p">)),</span>
                <span class="c1"># Fallback if edgecolor == "none".</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># We will now resolve the alignment and really have</span>
        <span class="c1"># left, bottom, width, height vectors</span>
        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">'center'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">'edge'</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'invalid alignment: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">align</span><span class="p">)</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">edgecolor</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">lw</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                <span class="n">edgecolor</span><span class="o">=</span><span class="n">e</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s1">'_nolegend_'</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">_interpolation_steps</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="n">holdstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># ensure hold is on before plotting errorbars</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
                <span class="c1"># using list comps rather than arrays to preserve unit info</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                <span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="n">h</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">height</span><span class="p">)]</span>

            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
                <span class="c1"># using list comps rather than arrays to preserve unit info</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">w</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                <span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">height</span><span class="p">)]</span>

            <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"label"</span><span class="p">,</span> <span class="s1">'_nolegend_'</span><span class="p">)</span>

            <span class="n">errorbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">,</span>
                                     <span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="n">xerr</span><span class="p">,</span>
                                     <span class="n">fmt</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span> <span class="o">**</span><span class="n">error_kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errorbar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">holdstate</span>  <span class="c1"># restore previous hold state</span>

        <span class="k">if</span> <span class="n">adjust_xlim</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervalx</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">width</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">xmin</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmin</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1e-100</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervalx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">adjust_ylim</span><span class="p">:</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervaly</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">height</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">ymin</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymin</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1e-100</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervaly</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="n">bar_container</span> <span class="o">=</span> <span class="n">BarContainer</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">errorbar</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_container</span><span class="p">(</span><span class="n">bar_container</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tick_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tick_labels</span> <span class="o">=</span> <span class="n">_backports</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">patches</span><span class="p">))</span>
            <span class="n">tick_label_axis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">tick_label_position</span><span class="p">)</span>
            <span class="n">tick_label_axis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bar_container</span></div>

<div class="viewcode-block" id="Axes.barh"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.barh.html#matplotlib.axes.Axes.barh">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">barh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Make a horizontal bar plot.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">           bar(y, width, *, align='center', **kwargs)</span>
<span class="sd">           bar(y, width, height, *, align='center', **kwargs)</span>
<span class="sd">           bar(y, width, height, left, *, align='center', **kwargs)</span>

<span class="sd">        The bars are positioned at *y* with the given *align*. Their</span>
<span class="sd">        dimensions are given by *width* and *height*. The horizontal baseline</span>
<span class="sd">        is *left* (default 0).</span>

<span class="sd">        Each of *y*, *width*, *height*, and *left* may either be a scalar</span>
<span class="sd">        applying to all bars, or it may be a sequence of length N providing a</span>
<span class="sd">        separate value for each bar.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : scalar or array-like</span>
<span class="sd">            The y coordinates of the bars. See also *align* for the</span>
<span class="sd">            alignment of the bars to the coordinates.</span>

<span class="sd">        width : scalar or array-like</span>
<span class="sd">            The width(s) of the bars.</span>

<span class="sd">        height : sequence of scalars, optional, default: 0.8</span>
<span class="sd">            The heights of the bars.</span>

<span class="sd">        left : sequence of scalars</span>
<span class="sd">            The x coordinates of the left sides of the bars (default: 0).</span>

<span class="sd">        align : {'center', 'edge'}, optional, default: 'center'</span>
<span class="sd">            Alignment of the base to the *y* coordinates*:</span>

<span class="sd">            - 'center': Center the bars on the *y* positions.</span>
<span class="sd">            - 'edge': Align the bottom edges of the bars with the *y*</span>
<span class="sd">              positions.</span>

<span class="sd">            To align the bars on the top edge pass a negative *height* and</span>
<span class="sd">            ``align='edge'``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.BarContainer`</span>
<span class="sd">            Container with all the bars and optionally errorbars.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        color : scalar or array-like, optional</span>
<span class="sd">            The colors of the bar faces.</span>

<span class="sd">        edgecolor : scalar or array-like, optional</span>
<span class="sd">            The colors of the bar edges.</span>

<span class="sd">        linewidth : scalar or array-like, optional</span>
<span class="sd">            Width of the bar edge(s). If 0, don't draw edges.</span>

<span class="sd">        tick_label : string or array-like, optional</span>
<span class="sd">            The tick labels of the bars.</span>
<span class="sd">            Default: None (Use default numeric labels.)</span>

<span class="sd">        xerr, yerr : scalar or array-like of shape(N,) or shape(2,N), optional</span>
<span class="sd">            If not ``None``, add horizontal / vertical errorbars to the</span>
<span class="sd">            bar tips. The values are +/- sizes relative to the data:</span>

<span class="sd">            - scalar: symmetric +/- values for all bars</span>
<span class="sd">            - shape(N,): symmetric +/- values for each bar</span>
<span class="sd">            - shape(2,N): separate + and - values for each bar</span>

<span class="sd">            Default: None</span>

<span class="sd">        ecolor : scalar or array-like, optional, default: 'black'</span>
<span class="sd">            The line color of the errorbars.</span>

<span class="sd">        capsize : scalar, optional</span>
<span class="sd">           The length of the error bar caps in points.</span>
<span class="sd">           Default: None, which will take the value from</span>
<span class="sd">           :rc:`errorbar.capsize`.</span>

<span class="sd">        error_kw : dict, optional</span>
<span class="sd">            Dictionary of kwargs to be passed to the `~.Axes.errorbar`</span>
<span class="sd">            method. Values of *ecolor* or *capsize* defined here take</span>
<span class="sd">            precedence over the independent kwargs.</span>

<span class="sd">        log : bool, optional, default: False</span>
<span class="sd">            If ``True``, set the x-axis to be log scale.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        bar: Plot a vertical bar plot.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The optional arguments *color*, *edgecolor*, *linewidth*,</span>
<span class="sd">        *xerr*, and *yerr* can be either scalars or sequences of</span>
<span class="sd">        length equal to the number of bars.  This enables you to use</span>
<span class="sd">        bar as the basis for stacked bar charts, or candlestick plots.</span>
<span class="sd">        Detail: *xerr* and *yerr* are passed directly to</span>
<span class="sd">        :meth:`errorbar`, so they can also have shape 2xN for</span>
<span class="sd">        independent specification of lower and upper errors.</span>

<span class="sd">        Other optional kwargs:</span>

<span class="sd">        %(Rectangle)s</span>

<span class="sd">        """</span>
        <span class="c1"># this is using the lambdas to do the arg/kwarg unpacking rather</span>
        <span class="c1"># than trying to re-implement all of that logic our selves.</span>
        <span class="n">matchers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span>
             <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)),</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span>
             <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)),</span>
        <span class="p">]</span>
        <span class="n">excs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">matcher</span> <span class="ow">in</span> <span class="n">matchers</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">matcher</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># This can only come from a no-match as there is</span>
                <span class="c1"># no other logic in the matchers.</span>
                <span class="n">excs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dp</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">"The *bottom* kwarg to `barh` is deprecated use *y* instead. "</span>
                <span class="s2">"Support for *bottom* will be removed in Matplotlib 3.0"</span><span class="p">,</span>
                <span class="n">mplDeprecation</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'orientation'</span><span class="p">,</span> <span class="s1">'horizontal'</span><span class="p">)</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                           <span class="n">bottom</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">patches</span></div>

<div class="viewcode-block" id="Axes.broken_barh"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.broken_barh.html#matplotlib.axes.Axes.broken_barh">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">broken_barh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xranges</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot a horizontal sequence of rectangles.</span>

<span class="sd">        A rectangle is drawn for each element of *xranges*. All rectangles</span>
<span class="sd">        have the same vertical position and size defined by *yrange*.</span>

<span class="sd">        This is a convenience function for instantiating a</span>
<span class="sd">        `.BrokenBarHCollection`, adding it to the axes and autoscaling the</span>
<span class="sd">        view.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xranges : sequence of tuples (*xmin*, *xwidth*)</span>
<span class="sd">            The x-positions and extends of the rectangles. For each tuple</span>
<span class="sd">            (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +</span>
<span class="sd">            *xwidth*.</span>
<span class="sd">        yranges : (*ymin*, *ymax*)</span>
<span class="sd">            The y-position and extend for all the rectangles.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : :class:`.BrokenBarHCollection` properties</span>

<span class="sd">            Each *kwarg* can be either a single argument applying to all</span>
<span class="sd">            rectangles, e.g.::</span>

<span class="sd">                facecolors='black'</span>

<span class="sd">            or a sequence of arguments over which is cycled, e.g.::</span>

<span class="sd">                facecolors=('black', 'blue')</span>

<span class="sd">            would create interleaving black and blue rectangles.</span>

<span class="sd">            Supported keywords:</span>

<span class="sd">            %(BrokenBarHCollection)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`matplotlib.collections.BrokenBarHCollection`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [Notes section required for data comment. See #10189.]</span>

<span class="sd">        """</span>
        <span class="c1"># process the unit information</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xranges</span><span class="p">):</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">xranges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yrange</span><span class="p">):</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">xdata</span><span class="p">,</span>
                                <span class="n">ydata</span><span class="o">=</span><span class="n">ydata</span><span class="p">,</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xranges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xranges</span><span class="p">)</span>
        <span class="n">yrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">BrokenBarHCollection</span><span class="p">(</span><span class="n">xranges</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">col</span></div>

<div class="viewcode-block" id="Axes.stem"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.stem.html#matplotlib.axes.Axes.stem">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_all_args</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a stem plot.</span>

<span class="sd">        A stem plot plots vertical lines at each *x* location from the baseline</span>
<span class="sd">        to *y*, and places a marker there.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          stem([x,] y, linefmt=None, markerfmt=None, basefmt=None)</span>

<span class="sd">        The x-positions are optional. The formats may be provided either as</span>
<span class="sd">        positional or as keyword-arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, optional</span>
<span class="sd">            The x-positions of the stems. Default: (0, 1, ..., len(y) - 1).</span>

<span class="sd">        y : array-like</span>
<span class="sd">            The y-values of the stem heads.</span>

<span class="sd">        linefmt : str, optional</span>
<span class="sd">            A string defining the properties of the vertical lines. Usually,</span>
<span class="sd">            this will be a color or a color and a linestyle:</span>

<span class="sd">            =========  =============</span>
<span class="sd">            Character  Line Style</span>
<span class="sd">            =========  =============</span>
<span class="sd">            ``'-'``    solid line</span>
<span class="sd">            ``'--'``   dashed line</span>
<span class="sd">            ``'-.'``   dash-dot line</span>
<span class="sd">            ``':'``    dotted line</span>
<span class="sd">            =========  =============</span>

<span class="sd">            Default: 'C0-', i.e. solid line with the first color of the color</span>
<span class="sd">            cycle.</span>

<span class="sd">            Note: While it is technically possible to specify valid formats</span>
<span class="sd">            other than color or color and linestyle (e.g. 'rx' or '-.'), this</span>
<span class="sd">            is beyond the intention of the method and will most likely not</span>
<span class="sd">            result in a reasonable reasonable plot.</span>

<span class="sd">        markerfmt : str, optional</span>
<span class="sd">            A string defining the properties of the markers at the stem heads.</span>
<span class="sd">            Default: 'C0o', i.e. filled circles with the first color of the</span>
<span class="sd">            color cycle.</span>

<span class="sd">        basefmt : str, optional</span>
<span class="sd">            A format string defining the properties of the baseline.</span>

<span class="sd">            Default: 'C3-' ('C2-' in classic mode).</span>

<span class="sd">        bottom : float, optional, default: 0</span>
<span class="sd">            The y-position of the baseline.</span>

<span class="sd">        label : str, optional, default: None</span>
<span class="sd">            The label to use for the stems in legends.</span>


<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            No other parameters are supported. They are currently ignored</span>
<span class="sd">            silently for backward compatibility. This behavior is deprecated.</span>
<span class="sd">            Future versions will not accept any other parameters and will</span>
<span class="sd">            raise a TypeError instead.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~matplotlib.container.StemContainer`</span>
<span class="sd">            The stemcontainer may be treated like a tuple</span>
<span class="sd">            (*markerline*, *stemlines*, *baseline*)</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            The MATLAB function</span>
<span class="sd">            `stem &lt;http://www.mathworks.com/help/techdoc/ref/stem.html&gt;`_</span>
<span class="sd">            which inspired this method.</span>

<span class="sd">        """</span>

        <span class="c1"># kwargs handling</span>
        <span class="c1"># We would like to have a signature with explicit kewords:</span>
        <span class="c1"># stem(*args, linefmt=None, markerfmt=None, basefmt=None,</span>
        <span class="c1">#      bottom=0, label=None)</span>
        <span class="c1"># Unfortunately,  this is not supported in Python 2.x. There, *args</span>
        <span class="c1"># can only exist after keyword arguments.</span>
        <span class="n">linefmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'linefmt'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">markerfmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'markerfmt'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">basefmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'basefmt'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'bottom'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warn_deprecated</span><span class="p">(</span><span class="n">since</span><span class="o">=</span><span class="s1">'2.2'</span><span class="p">,</span>
                            <span class="n">message</span><span class="o">=</span><span class="s2">"stem() got an unexpected keyword "</span>
                                    <span class="s2">"argument '</span><span class="si">%s</span><span class="s2">'. This will raise a "</span>
                                    <span class="s2">"TypeError in future versions."</span> <span class="o">%</span> <span class="p">(</span>
                                <span class="nb">next</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">),</span> <span class="p">)</span>
                            <span class="p">)</span>

        <span class="n">remember_hold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Assume there's at least one data array</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Try a second one</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">second</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="c1"># The second array doesn't make sense, or it doesn't exist</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">second</span>

        <span class="c1"># defaults for formats</span>
        <span class="k">if</span> <span class="n">linefmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># fallback to positional argument</span>
                <span class="n">linefmt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">linecolor</span> <span class="o">=</span> <span class="s1">'C0'</span>
                <span class="n">linemarker</span> <span class="o">=</span> <span class="s1">'None'</span>
                <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">'-'</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linestyle</span><span class="p">,</span> <span class="n">linemarker</span><span class="p">,</span> <span class="n">linecolor</span> <span class="o">=</span> \
                    <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">linefmt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">linestyle</span><span class="p">,</span> <span class="n">linemarker</span><span class="p">,</span> <span class="n">linecolor</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">linefmt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">markerfmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># fallback to positional argument</span>
                <span class="n">markerfmt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">markercolor</span> <span class="o">=</span> <span class="s1">'C0'</span>
                <span class="n">markermarker</span> <span class="o">=</span> <span class="s1">'o'</span>
                <span class="n">markerstyle</span> <span class="o">=</span> <span class="s1">'None'</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">markerstyle</span><span class="p">,</span> <span class="n">markermarker</span><span class="p">,</span> <span class="n">markercolor</span> <span class="o">=</span> \
                    <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">markerfmt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">markerstyle</span><span class="p">,</span> <span class="n">markermarker</span><span class="p">,</span> <span class="n">markercolor</span> <span class="o">=</span> \
                <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">markerfmt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">basefmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># fallback to positional argument</span>
                <span class="n">basefmt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
                    <span class="n">basecolor</span> <span class="o">=</span> <span class="s1">'C2'</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">basecolor</span> <span class="o">=</span> <span class="s1">'C3'</span>
                <span class="n">basemarker</span> <span class="o">=</span> <span class="s1">'None'</span>
                <span class="n">basestyle</span> <span class="o">=</span> <span class="s1">'-'</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">basestyle</span><span class="p">,</span> <span class="n">basemarker</span><span class="p">,</span> <span class="n">basecolor</span> <span class="o">=</span> \
                    <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">basefmt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basestyle</span><span class="p">,</span> <span class="n">basemarker</span><span class="p">,</span> <span class="n">basecolor</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">basefmt</span><span class="p">)</span>

        <span class="n">markerline</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">markercolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">markerstyle</span><span class="p">,</span>
                                <span class="n">marker</span><span class="o">=</span><span class="n">markermarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"_nolegend_"</span><span class="p">)</span>

        <span class="n">stemlines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">thisx</span><span class="p">,</span> <span class="n">thisy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">l</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thisx</span><span class="p">],</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">thisy</span><span class="p">],</span>
                           <span class="n">color</span><span class="o">=</span><span class="n">linecolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                           <span class="n">marker</span><span class="o">=</span><span class="n">linemarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"_nolegend_"</span><span class="p">)</span>
            <span class="n">stemlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="n">baseline</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span><span class="p">],</span>
                              <span class="n">color</span><span class="o">=</span><span class="n">basecolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">basestyle</span><span class="p">,</span>
                              <span class="n">marker</span><span class="o">=</span><span class="n">basemarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"_nolegend_"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">remember_hold</span>

        <span class="n">stem_container</span> <span class="o">=</span> <span class="n">StemContainer</span><span class="p">((</span><span class="n">markerline</span><span class="p">,</span> <span class="n">stemlines</span><span class="p">,</span> <span class="n">baseline</span><span class="p">),</span>
                                       <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_container</span><span class="p">(</span><span class="n">stem_container</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stem_container</span></div>

<div class="viewcode-block" id="Axes.pie"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.pie.html#matplotlib.axes.Axes.pie">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"explode"</span><span class="p">,</span> <span class="s2">"labels"</span><span class="p">,</span> <span class="s2">"colors"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">explode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">autopct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pctdistance</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labeldistance</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
            <span class="n">startangle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">counterclock</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">wedgeprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">textprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">frame</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rotatelabels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot a pie chart.</span>

<span class="sd">        Make a pie chart of array *x*.  The fractional area of each wedge is</span>
<span class="sd">        given by ``x/sum(x)``.  If ``sum(x) &lt; 1``, then the values of *x* give</span>
<span class="sd">        the fractional area directly and the array will not be normalized. The</span>
<span class="sd">        resulting pie will have an empty wedge of size ``1 - sum(x)``.</span>

<span class="sd">        The wedges are plotted counterclockwise, by default starting from the</span>
<span class="sd">        x-axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            The wedge sizes.</span>

<span class="sd">        explode : array-like, optional, default: None</span>
<span class="sd">            If not *None*, is a ``len(x)`` array which specifies the fraction</span>
<span class="sd">            of the radius with which to offset each wedge.</span>

<span class="sd">        labels : list, optional, default: None</span>
<span class="sd">            A sequence of strings providing the labels for each wedge</span>

<span class="sd">        colors : array-like, optional, default: None</span>
<span class="sd">            A sequence of matplotlib color args through which the pie chart</span>
<span class="sd">            will cycle.  If *None*, will use the colors in the currently</span>
<span class="sd">            active cycle.</span>

<span class="sd">        autopct : None (default), string, or function, optional</span>
<span class="sd">            If not *None*, is a string or function used to label the wedges</span>
<span class="sd">            with their numeric value.  The label will be placed inside the</span>
<span class="sd">            wedge.  If it is a format string, the label will be ``fmt%pct``.</span>
<span class="sd">            If it is a function, it will be called.</span>

<span class="sd">        pctdistance : float, optional, default: 0.6</span>
<span class="sd">            The ratio between the center of each pie slice and the start of</span>
<span class="sd">            the text generated by *autopct*.  Ignored if *autopct* is *None*.</span>

<span class="sd">        shadow : bool, optional, default: False</span>
<span class="sd">            Draw a shadow beneath the pie.</span>

<span class="sd">        labeldistance : float, optional, default: 1.1</span>
<span class="sd">            The radial distance at which the pie labels are drawn</span>

<span class="sd">        startangle : float, optional, default: None</span>
<span class="sd">            If not *None*, rotates the start of the pie chart by *angle*</span>
<span class="sd">            degrees counterclockwise from the x-axis.</span>

<span class="sd">        radius : float, optional, default: None</span>
<span class="sd">            The radius of the pie, if *radius* is *None* it will be set to 1.</span>

<span class="sd">        counterclock : bool, optional, default: True</span>
<span class="sd">            Specify fractions direction, clockwise or counterclockwise.</span>

<span class="sd">        wedgeprops : dict, optional, default: None</span>
<span class="sd">            Dict of arguments passed to the wedge objects making the pie.</span>
<span class="sd">            For example, you can pass in ``wedgeprops = {'linewidth': 3}``</span>
<span class="sd">            to set the width of the wedge border lines equal to 3.</span>
<span class="sd">            For more details, look at the doc/arguments of the wedge object.</span>
<span class="sd">            By default ``clip_on=False``.</span>

<span class="sd">        textprops : dict, optional, default: None</span>
<span class="sd">            Dict of arguments to pass to the text objects.</span>

<span class="sd">        center :  list of float, optional, default: (0, 0)</span>
<span class="sd">            Center position of the chart. Takes value (0, 0) or is a sequence</span>
<span class="sd">            of 2 scalars.</span>

<span class="sd">        frame : bool, optional, default: False</span>
<span class="sd">            Plot axes frame with the chart if true.</span>

<span class="sd">        rotatelabels : bool, optional, default: False</span>
<span class="sd">            Rotate each label to the angle of the corresponding slice if true.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        patches : list</span>
<span class="sd">            A sequence of :class:`matplotlib.patches.Wedge` instances</span>

<span class="sd">        texts : list</span>
<span class="sd">            A list of the label :class:`matplotlib.text.Text` instances.</span>

<span class="sd">        autotexts : list</span>
<span class="sd">            A list of :class:`~matplotlib.text.Text` instances for the numeric</span>
<span class="sd">            labels. This will only be returned if the parameter *autopct* is</span>
<span class="sd">            not *None*.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The pie chart will probably look best if the figure and axes are</span>
<span class="sd">        square, or the Axes aspect is equal.</span>
<span class="sd">        """</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">sx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">/=</span> <span class="n">sx</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">''</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">explode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">explode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'label' must be of length 'x'"</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">explode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'explode' must be of length 'x'"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">get_next_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color_cycle</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">get_next_color</span><span class="p">():</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">color_cycle</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Starting theta1 is the start fraction of the circle</span>
        <span class="k">if</span> <span class="n">startangle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">theta1</span> <span class="o">=</span> <span class="n">startangle</span> <span class="o">/</span> <span class="mf">360.0</span>

        <span class="c1"># set default values in wedge_prop</span>
        <span class="k">if</span> <span class="n">wedgeprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wedgeprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">wedgeprops</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'clip_on'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">textprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">textprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">textprops</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'clip_on'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">texts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">autotexts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">frac</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">expl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">explode</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">center</span>
            <span class="n">theta2</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">frac</span><span class="p">)</span> <span class="k">if</span> <span class="n">counterclock</span> <span class="k">else</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">-</span> <span class="n">frac</span><span class="p">)</span>
            <span class="n">thetam</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">theta2</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">expl</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">expl</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Wedge</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="mf">360.</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">),</span>
                               <span class="mf">360.</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">),</span>
                               <span class="n">facecolor</span><span class="o">=</span><span class="n">get_next_color</span><span class="p">(),</span>
                               <span class="o">**</span><span class="n">wedgeprops</span><span class="p">)</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">w</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shadow</span><span class="p">:</span>
                <span class="c1"># make sure to add a shadow after the call to</span>
                <span class="c1"># add_patch so the figure and transform props will be</span>
                <span class="c1"># set</span>
                <span class="n">shad</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Shadow</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">)</span>
                <span class="n">shad</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">get_zorder</span><span class="p">())</span>
                <span class="n">shad</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">'_nolegend_'</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">shad</span><span class="p">)</span>

            <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">labeldistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
            <span class="n">yt</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">labeldistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
            <span class="n">label_alignment_h</span> <span class="o">=</span> <span class="n">xt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s1">'left'</span> <span class="ow">or</span> <span class="s1">'right'</span>
            <span class="n">label_alignment_v</span> <span class="o">=</span> <span class="s1">'center'</span>
            <span class="n">label_rotation</span> <span class="o">=</span> <span class="s1">'horizontal'</span>
            <span class="k">if</span> <span class="n">rotatelabels</span><span class="p">:</span>
                <span class="n">label_alignment_v</span> <span class="o">=</span> <span class="n">yt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s1">'bottom'</span> <span class="ow">or</span> <span class="s1">'top'</span>
                <span class="n">label_rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">xt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">180</span><span class="p">)</span>

            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
                          <span class="n">size</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'xtick.labelsize'</span><span class="p">],</span>
                          <span class="n">horizontalalignment</span><span class="o">=</span><span class="n">label_alignment_h</span><span class="p">,</span>
                          <span class="n">verticalalignment</span><span class="o">=</span><span class="n">label_alignment_v</span><span class="p">,</span>
                          <span class="n">rotation</span><span class="o">=</span><span class="n">label_rotation</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">textprops</span><span class="p">)</span>

            <span class="n">texts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">autopct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">pctdistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="n">yt</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">pctdistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">autopct</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">autopct</span> <span class="o">%</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">autopct</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">autopct</span><span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">'autopct must be callable or a format string'</span><span class="p">)</span>

                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
                              <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">'center'</span><span class="p">,</span>
                              <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">'center'</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">textprops</span><span class="p">)</span>

                <span class="n">autotexts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="n">theta1</span> <span class="o">=</span> <span class="n">theta2</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                           <span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="k">if</span> <span class="n">autopct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">texts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">texts</span><span class="p">,</span> <span class="n">autotexts</span></div>

<div class="viewcode-block" id="Axes.errorbar"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.errorbar.html#matplotlib.axes.Axes.errorbar">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"xerr"</span><span class="p">,</span> <span class="s2">"yerr"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">"y"</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">errorbar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fmt</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">ecolor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elinewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">barsabove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lolims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">uplims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">xlolims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xuplims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">errorevery</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">capthick</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot y versus x as lines and/or markers with attached errorbars.</span>

<span class="sd">        *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar</span>
<span class="sd">        sizes. By default, this draws the data markers/lines as well the</span>
<span class="sd">        errorbars. Use fmt='none' to draw errorbars without any data markers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : scalar or array-like</span>
<span class="sd">            The data positions.</span>

<span class="sd">        xerr, yerr : scalar or array-like, shape(N,) or shape(2,N), optional</span>
<span class="sd">            The errorbar sizes:</span>

<span class="sd">            - scalar: Symmetric +/- values for all data points.</span>
<span class="sd">            - shape(N,): Symmetric +/-values for each data point.</span>
<span class="sd">            - shape(2,N): Separate + and - values for each data point.</span>
<span class="sd">            - *None*: No errorbar.</span>

<span class="sd">        fmt : plot format string, optional, default: ''</span>
<span class="sd">            The format for the data points / data lines. See `.plot` for</span>
<span class="sd">            details.</span>

<span class="sd">            Use 'none' (case insensitive) to plot errorbars without any data</span>
<span class="sd">            markers.</span>

<span class="sd">        ecolor : mpl color, optional, default: None</span>
<span class="sd">            A matplotlib color arg which gives the color the errorbar lines.</span>
<span class="sd">            If None, use the color of the line connecting the markers.</span>

<span class="sd">        elinewidth : scalar, optional, default: None</span>
<span class="sd">            The linewidth of the errorbar lines. If None, the linewidth of</span>
<span class="sd">            the current style is used.</span>

<span class="sd">        capsize : scalar, optional, default: None</span>
<span class="sd">            The length of the error bar caps in points. If None, it will take</span>
<span class="sd">            the value from :rc:`errorbar.capsize`.</span>

<span class="sd">        capthick : scalar, optional, default: None</span>
<span class="sd">            An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).</span>
<span class="sd">            This setting is a more sensible name for the property that</span>
<span class="sd">            controls the thickness of the error bar cap in points. For</span>
<span class="sd">            backwards compatibility, if *mew* or *markeredgewidth* are given,</span>
<span class="sd">            then they will over-ride *capthick*. This may change in future</span>
<span class="sd">            releases.</span>

<span class="sd">        barsabove : bool, optional, default: False</span>
<span class="sd">            If True, will plot the errorbars above the plot</span>
<span class="sd">            symbols. Default is below.</span>

<span class="sd">        lolims, uplims, xlolims, xuplims : bool, optional, default: None</span>
<span class="sd">            These arguments can be used to indicate that a value gives only</span>
<span class="sd">            upper/lower limits. In that case a caret symbol is used to</span>
<span class="sd">            indicate this. *lims*-arguments may be of the same type as *xerr*</span>
<span class="sd">            and *yerr*.  To use limits with inverted axes, :meth:`set_xlim`</span>
<span class="sd">            or :meth:`set_ylim` must be called before :meth:`errorbar`.</span>

<span class="sd">        errorevery : positive integer, optional, default: 1</span>
<span class="sd">            Subsamples the errorbars. e.g., if errorevery=5, errorbars for</span>
<span class="sd">            every 5-th datapoint will be plotted. The data plot itself still</span>
<span class="sd">            shows all data points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.container.ErrorbarContainer`</span>
<span class="sd">            The container contains:</span>

<span class="sd">            - plotline: :class:`~matplotlib.lines.Line2D` instance of</span>
<span class="sd">              x, y plot markers and/or line.</span>
<span class="sd">            - caplines: A tuple of :class:`~matplotlib.lines.Line2D` instances</span>
<span class="sd">              of the error bar caps.</span>
<span class="sd">            - barlinecols: A tuple of</span>
<span class="sd">              :class:`~matplotlib.collections.LineCollection` with the</span>
<span class="sd">              horizontal and vertical error ranges.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            All other keyword arguments are passed on to the plot</span>
<span class="sd">            command for the markers. For example, this code makes big red</span>
<span class="sd">            squares with thick green edges::</span>

<span class="sd">                x,y,yerr = rand(3,10)</span>
<span class="sd">                errorbar(x, y, yerr, marker='s', mfc='red',</span>
<span class="sd">                         mec='green', ms=20, mew=4)</span>

<span class="sd">            where *mfc*, *mec*, *ms* and *mew* are aliases for the longer</span>
<span class="sd">            property names, *markerfacecolor*, *markeredgecolor*, *markersize*</span>
<span class="sd">            and *markeredgewidth*.</span>

<span class="sd">            Valid kwargs for the marker properties are `.Lines2D` properties:</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [Notes section required for data comment. See #10189.]</span>

<span class="sd">        """</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">_alias_map</span><span class="p">)</span>
        <span class="c1"># anything that comes in as 'None', drop so the default thing</span>
        <span class="c1"># happens down stream</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'zorder'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errorevery</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">'errorevery has to be a strictly positive integer'</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">holdstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">plot_line</span> <span class="o">=</span> <span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">'none'</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"label"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">''</span><span class="p">:</span>
            <span class="n">fmt_style_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fmt_style_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                            <span class="nb">zip</span><span class="p">((</span><span class="s1">'linestyle'</span><span class="p">,</span> <span class="s1">'marker'</span><span class="p">,</span> <span class="s1">'color'</span><span class="p">),</span>
                                <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">'none'</span><span class="p">:</span>
            <span class="c1"># Remove alpha=0 color that _process_plot_format returns</span>
            <span class="n">fmt_style_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'color'</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">'color'</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="s1">'color'</span> <span class="ow">in</span> <span class="n">fmt_style_kwargs</span> <span class="ow">or</span>
                <span class="n">ecolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">base_style</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s1">'color'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">base_style</span><span class="p">[</span><span class="s1">'color'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'color'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_style</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">prop_cycler</span><span class="p">)</span>

        <span class="n">base_style</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'_nolegend_'</span>
        <span class="n">base_style</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fmt_style_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">'color'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base_style</span><span class="p">:</span>
            <span class="n">base_style</span><span class="p">[</span><span class="s1">'color'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'C0'</span>
        <span class="k">if</span> <span class="n">ecolor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ecolor</span> <span class="o">=</span> <span class="n">base_style</span><span class="p">[</span><span class="s1">'color'</span><span class="p">]</span>
        <span class="c1"># make sure all the args are iterable; use lists not arrays to</span>
        <span class="c1"># preserve units</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xerr</span><span class="p">):</span>
                <span class="n">xerr</span> <span class="o">=</span> <span class="p">[</span><span class="n">xerr</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">yerr</span><span class="p">):</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="p">[</span><span class="n">yerr</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># make the style dict for the 'normal' plot line</span>
        <span class="n">plot_line_style</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">base_style</span><span class="p">)</span>
        <span class="n">plot_line_style</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">barsabove</span><span class="p">:</span>
            <span class="n">plot_line_style</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">-</span> <span class="o">.</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plot_line_style</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">1</span>

        <span class="c1"># make the style dict for the line collections (the bars)</span>
        <span class="n">eb_lines_style</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">base_style</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'marker'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'linestyle'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="p">[</span><span class="s1">'color'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ecolor</span>

        <span class="k">if</span> <span class="n">elinewidth</span><span class="p">:</span>
            <span class="n">eb_lines_style</span><span class="p">[</span><span class="s1">'linewidth'</span><span class="p">]</span> <span class="o">=</span> <span class="n">elinewidth</span>
        <span class="k">elif</span> <span class="s1">'linewidth'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">eb_lines_style</span><span class="p">[</span><span class="s1">'linewidth'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'linewidth'</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'transform'</span><span class="p">,</span> <span class="s1">'alpha'</span><span class="p">,</span> <span class="s1">'zorder'</span><span class="p">,</span> <span class="s1">'rasterized'</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">eb_lines_style</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># set up cap style dictionary</span>
        <span class="n">eb_cap_style</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">base_style</span><span class="p">)</span>
        <span class="c1"># eject any marker information from format string</span>
        <span class="n">eb_cap_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'marker'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'markerfacecolor'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'markeredgewidth'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'markeredgecolor'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_cap_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'ls'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">'linestyle'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'none'</span>
        <span class="k">if</span> <span class="n">capsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">capsize</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">"errorbar.capsize"</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">'markersize'</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">capsize</span>
        <span class="k">if</span> <span class="n">capthick</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">'markeredgewidth'</span><span class="p">]</span> <span class="o">=</span> <span class="n">capthick</span>

        <span class="c1"># For backwards-compat, allow explicit setting of</span>
        <span class="c1"># 'markeredgewidth' to over-ride capthick.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'markeredgewidth'</span><span class="p">,</span> <span class="s1">'transform'</span><span class="p">,</span> <span class="s1">'alpha'</span><span class="p">,</span>
                    <span class="s1">'zorder'</span><span class="p">,</span> <span class="s1">'rasterized'</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">eb_cap_style</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">'color'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ecolor</span>

        <span class="n">data_line</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">plot_line</span><span class="p">:</span>
            <span class="n">data_line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_line_style</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">data_line</span><span class="p">)</span>

        <span class="n">barcols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">caplines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># arrays fine here, they are booleans and hence not units</span>
        <span class="k">def</span> <span class="nf">_bool_asarray_helper</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">expected</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="n">expected</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="n">lolims</span> <span class="o">=</span> <span class="n">_bool_asarray_helper</span><span class="p">(</span><span class="n">lolims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">uplims</span> <span class="o">=</span> <span class="n">_bool_asarray_helper</span><span class="p">(</span><span class="n">uplims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">xlolims</span> <span class="o">=</span> <span class="n">_bool_asarray_helper</span><span class="p">(</span><span class="n">xlolims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">xuplims</span> <span class="o">=</span> <span class="n">_bool_asarray_helper</span><span class="p">(</span><span class="n">xuplims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="n">everymask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">%</span> <span class="n">errorevery</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">xywhere</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
            <span class="sd">"""</span>
<span class="sd">            return xs[mask], ys[mask] where mask is True but xs and</span>
<span class="sd">            ys are not arrays</span>
<span class="sd">            """</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="k">for</span> <span class="n">thisx</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisy</span> <span class="k">for</span> <span class="n">thisy</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span>

        <span class="k">def</span> <span class="nf">extract_err</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="sd">'''private function to compute error bars</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            err : iterable</span>
<span class="sd">                xerr or yerr from errorbar</span>
<span class="sd">            data : iterable</span>
<span class="sd">                x or y from errorbar</span>
<span class="sd">            '''</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">err</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">iterable</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="c1"># using list comps rather than arrays to preserve units</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="o">-</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                           <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="o">+</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                            <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
                    <span class="k">return</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span>
            <span class="c1"># Check if xerr is scalar or symmetric. Asymmetric is handled</span>
            <span class="c1"># above. This prevents Nx2 arrays from accidentally</span>
            <span class="c1"># being accepted, when the user meant the 2xN transpose.</span>
            <span class="c1"># special case for empty lists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fe</span> <span class="o">=</span> <span class="n">safe_first_element</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fe</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"err must be [ scalar | N, Nx1 "</span>
                                     <span class="s2">"or 2xN array-like ]"</span><span class="p">)</span>
            <span class="c1"># using list comps rather than arrays to preserve units</span>
            <span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="o">-</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                   <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">err</span><span class="p">)]</span>
            <span class="n">high</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="o">+</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                    <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">err</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">extract_err</span><span class="p">(</span><span class="n">xerr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="c1"># select points without upper/lower limits in x and</span>
            <span class="c1"># draw normal errorbars for these points</span>
            <span class="n">noxlims</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">xlolims</span> <span class="o">|</span> <span class="n">xuplims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">noxlims</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">noxlims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">noxlims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">noxlims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">'|'</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">'|'</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">xlolims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="n">rightup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETLEFTBASE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETRIGHTBASE</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">rightup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">'None'</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">'|'</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">xuplims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="n">leftlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETRIGHTBASE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETLEFTBASE</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">leftlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">'None'</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">'|'</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">extract_err</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># select points without upper/lower limits in y and</span>
            <span class="c1"># draw normal errorbars for these points</span>
            <span class="n">noylims</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">lolims</span> <span class="o">|</span> <span class="n">uplims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">noylims</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">noylims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">noylims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">noylims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">'_'</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">'_'</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">lolims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="n">xup</span><span class="p">,</span> <span class="n">upperup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETDOWNBASE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETUPBASE</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">upperup</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">'None'</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">'_'</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">uplims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="n">xlo</span><span class="p">,</span> <span class="n">lowerlo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETUPBASE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETDOWNBASE</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">lowerlo</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">'None'</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">'_'</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">caplines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">holdstate</span>

        <span class="n">errorbar_container</span> <span class="o">=</span> <span class="n">ErrorbarContainer</span><span class="p">((</span><span class="n">data_line</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">caplines</span><span class="p">),</span>
                                                <span class="nb">tuple</span><span class="p">(</span><span class="n">barcols</span><span class="p">)),</span>
                                               <span class="n">has_xerr</span><span class="o">=</span><span class="p">(</span><span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
                                               <span class="n">has_yerr</span><span class="o">=</span><span class="p">(</span><span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
                                               <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">containers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errorbar_container</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">errorbar_container</span>  <span class="c1"># (l0, caplines, barcols)</span></div>

<div class="viewcode-block" id="Axes.boxplot"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.boxplot.html#matplotlib.axes.Axes.boxplot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">boxplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">notch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usermedians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conf_intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">meanline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showcaps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">showbox</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">boxprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">medianprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">meanprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">manage_xticks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">autorange</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Make a box and whisker plot.</span>

<span class="sd">        Make a box and whisker plot for each column of ``x`` or each</span>
<span class="sd">        vector in sequence ``x``.  The box extends from the lower to</span>
<span class="sd">        upper quartile values of the data, with a line at the median.</span>
<span class="sd">        The whiskers extend from the box to show the range of the</span>
<span class="sd">        data.  Flier points are those past the end of the whiskers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : Array or a sequence of vectors.</span>
<span class="sd">            The input data.</span>

<span class="sd">        notch : bool, optional (False)</span>
<span class="sd">            If `True`, will produce a notched box plot. Otherwise, a</span>
<span class="sd">            rectangular boxplot is produced. The notches represent the</span>
<span class="sd">            confidence interval (CI) around the median. See the entry</span>
<span class="sd">            for the ``bootstrap`` parameter for information regarding</span>
<span class="sd">            how the locations of the notches are computed.</span>

<span class="sd">            .. note::</span>

<span class="sd">                In cases where the values of the CI are less than the</span>
<span class="sd">                lower quartile or greater than the upper quartile, the</span>
<span class="sd">                notches will extend beyond the box, giving it a</span>
<span class="sd">                distinctive "flipped" appearance. This is expected</span>
<span class="sd">                behavior and consistent with other statistical</span>
<span class="sd">                visualization packages.</span>

<span class="sd">        sym : str, optional</span>
<span class="sd">            The default symbol for flier points. Enter an empty string</span>
<span class="sd">            ('') if you don't want to show fliers. If `None`, then the</span>
<span class="sd">            fliers default to 'b+'  If you want more control use the</span>
<span class="sd">            flierprops kwarg.</span>

<span class="sd">        vert : bool, optional (True)</span>
<span class="sd">            If `True` (default), makes the boxes vertical. If `False`,</span>
<span class="sd">            everything is drawn horizontally.</span>

<span class="sd">        whis : float, sequence, or string (default = 1.5)</span>
<span class="sd">            As a float, determines the reach of the whiskers to the beyond the</span>
<span class="sd">            first and third quartiles. In other words, where IQR is the</span>
<span class="sd">            interquartile range (`Q3-Q1`), the upper whisker will extend to</span>
<span class="sd">            last datum less than `Q3 + whis*IQR`). Similarly, the lower whisker</span>
<span class="sd">            will extend to the first datum greater than `Q1 - whis*IQR`.</span>
<span class="sd">            Beyond the whiskers, data</span>
<span class="sd">            are considered outliers and are plotted as individual</span>
<span class="sd">            points. Set this to an unreasonably high value to force the</span>
<span class="sd">            whiskers to show the min and max values. Alternatively, set</span>
<span class="sd">            this to an ascending sequence of percentile (e.g., [5, 95])</span>
<span class="sd">            to set the whiskers at specific percentiles of the data.</span>
<span class="sd">            Finally, ``whis`` can be the string ``'range'`` to force the</span>
<span class="sd">            whiskers to the min and max of the data.</span>

<span class="sd">        bootstrap : int, optional</span>
<span class="sd">            Specifies whether to bootstrap the confidence intervals</span>
<span class="sd">            around the median for notched boxplots. If ``bootstrap`` is</span>
<span class="sd">            None, no bootstrapping is performed, and notches are</span>
<span class="sd">            calculated using a Gaussian-based asymptotic approximation</span>
<span class="sd">            (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and</span>
<span class="sd">            Kendall and Stuart, 1967). Otherwise, bootstrap specifies</span>
<span class="sd">            the number of times to bootstrap the median to determine its</span>
<span class="sd">            95% confidence intervals. Values between 1000 and 10000 are</span>
<span class="sd">            recommended.</span>

<span class="sd">        usermedians : array-like, optional</span>
<span class="sd">            An array or sequence whose first dimension (or length) is</span>
<span class="sd">            compatible with ``x``. This overrides the medians computed</span>
<span class="sd">            by matplotlib for each element of ``usermedians`` that is not</span>
<span class="sd">            `None`. When an element of ``usermedians`` is None, the median</span>
<span class="sd">            will be computed by matplotlib as normal.</span>

<span class="sd">        conf_intervals : array-like, optional</span>
<span class="sd">            Array or sequence whose first dimension (or length) is</span>
<span class="sd">            compatible with ``x`` and whose second dimension is 2. When</span>
<span class="sd">            the an element of ``conf_intervals`` is not None, the</span>
<span class="sd">            notch locations computed by matplotlib are overridden</span>
<span class="sd">            (provided ``notch`` is `True`). When an element of</span>
<span class="sd">            ``conf_intervals`` is `None`, the notches are computed by the</span>
<span class="sd">            method specified by the other kwargs (e.g., ``bootstrap``).</span>

<span class="sd">        positions : array-like, optional</span>
<span class="sd">            Sets the positions of the boxes. The ticks and limits are</span>
<span class="sd">            automatically set to match the positions. Defaults to</span>
<span class="sd">            `range(1, N+1)` where N is the number of boxes to be drawn.</span>

<span class="sd">        widths : scalar or array-like</span>
<span class="sd">            Sets the width of each box either with a scalar or a</span>
<span class="sd">            sequence. The default is 0.5, or ``0.15*(distance between</span>
<span class="sd">            extreme positions)``, if that is smaller.</span>

<span class="sd">        patch_artist : bool, optional (False)</span>
<span class="sd">            If `False` produces boxes with the Line2D artist. Otherwise,</span>
<span class="sd">            boxes and drawn with Patch artists.</span>

<span class="sd">        labels : sequence, optional</span>
<span class="sd">            Labels for each dataset. Length must be compatible with</span>
<span class="sd">            dimensions  of ``x``.</span>

<span class="sd">        manage_xticks : bool, optional (True)</span>
<span class="sd">            If the function should adjust the xlim and xtick locations.</span>

<span class="sd">        autorange : bool, optional (False)</span>
<span class="sd">            When `True` and the data are distributed such that the  25th and</span>
<span class="sd">            75th percentiles are equal, ``whis`` is set to ``'range'`` such</span>
<span class="sd">            that the whisker ends are at the minimum and maximum of the</span>
<span class="sd">            data.</span>

<span class="sd">        meanline : bool, optional (False)</span>
<span class="sd">            If `True` (and ``showmeans`` is `True`), will try to render</span>
<span class="sd">            the mean as a line spanning the full width of the box</span>
<span class="sd">            according to ``meanprops`` (see below). Not recommended if</span>
<span class="sd">            ``shownotches`` is also True. Otherwise, means will be shown</span>
<span class="sd">            as points.</span>

<span class="sd">        zorder : scalar, optional (None)</span>
<span class="sd">            Sets the zorder of the boxplot.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        showcaps : bool, optional (True)</span>
<span class="sd">            Show the caps on the ends of whiskers.</span>
<span class="sd">        showbox : bool, optional (True)</span>
<span class="sd">            Show the central box.</span>
<span class="sd">        showfliers : bool, optional (True)</span>
<span class="sd">            Show the outliers beyond the caps.</span>
<span class="sd">        showmeans : bool, optional (False)</span>
<span class="sd">            Show the arithmetic means.</span>
<span class="sd">        capprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the caps.</span>
<span class="sd">        boxprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the box.</span>
<span class="sd">        whiskerprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the whiskers.</span>
<span class="sd">        flierprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the fliers.</span>
<span class="sd">        medianprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the median.</span>
<span class="sd">        meanprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the mean.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the boxplot to a list</span>
<span class="sd">          of the :class:`matplotlib.lines.Line2D` instances</span>
<span class="sd">          created. That dictionary has the following keys (assuming</span>
<span class="sd">          vertical boxplots):</span>

<span class="sd">          - ``boxes``: the main body of the boxplot showing the</span>
<span class="sd">            quartiles and the median's confidence intervals if</span>
<span class="sd">            enabled.</span>

<span class="sd">          - ``medians``: horizontal lines at the median of each box.</span>

<span class="sd">          - ``whiskers``: the vertical lines extending to the most</span>
<span class="sd">            extreme, non-outlier data points.</span>

<span class="sd">          - ``caps``: the horizontal lines at the ends of the</span>
<span class="sd">            whiskers.</span>

<span class="sd">          - ``fliers``: points representing data that extend beyond</span>
<span class="sd">            the whiskers (fliers).</span>

<span class="sd">          - ``means``: points or lines representing the means.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [Notes section required for data comment. See #10189.]</span>

<span class="sd">        """</span>

        <span class="c1"># If defined in matplotlibrc, apply the value from rc file</span>
        <span class="c1"># Overridden if argument is passed</span>
        <span class="k">if</span> <span class="n">whis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whis</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.whiskers'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bootstrap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bootstrap</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.bootstrap'</span><span class="p">]</span>

        <span class="n">bxpstats</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">boxplot_stats</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">whis</span><span class="o">=</span><span class="n">whis</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="n">bootstrap</span><span class="p">,</span>
                                       <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">autorange</span><span class="o">=</span><span class="n">autorange</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">notch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">notch</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.notch'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vert</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vert</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.vertical'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">patch_artist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">patch_artist</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.patchartist'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">meanline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meanline</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.meanline'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showmeans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showmeans</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.showmeans'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showcaps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showcaps</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.showcaps'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showbox</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.showbox'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showfliers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showfliers</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.showfliers'</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_update_dict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">rc_name</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
            <span class="sd">""" Loads properties in the dictionary from rc file if not already</span>
<span class="sd">            in the dictionary"""</span>
            <span class="n">rc_str</span> <span class="o">=</span> <span class="s1">'boxplot.</span><span class="si">{0}</span><span class="s1">.</span><span class="si">{1}</span><span class="s1">'</span>
            <span class="k">if</span> <span class="n">dictionary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dictionary</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">prop_dict</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="n">dictionary</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">prop_dict</span><span class="p">,</span>
                                <span class="n">rcParams</span><span class="p">[</span><span class="n">rc_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rc_name</span><span class="p">,</span> <span class="n">prop_dict</span><span class="p">)])</span>
            <span class="k">return</span> <span class="n">dictionary</span>

        <span class="c1"># Common property dictionnaries loading from rc</span>
        <span class="n">flier_props</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'color'</span><span class="p">,</span> <span class="s1">'marker'</span><span class="p">,</span> <span class="s1">'markerfacecolor'</span><span class="p">,</span> <span class="s1">'markeredgecolor'</span><span class="p">,</span>
                       <span class="s1">'markersize'</span><span class="p">,</span> <span class="s1">'linestyle'</span><span class="p">,</span> <span class="s1">'linewidth'</span><span class="p">]</span>
        <span class="n">default_props</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'color'</span><span class="p">,</span> <span class="s1">'linewidth'</span><span class="p">,</span> <span class="s1">'linestyle'</span><span class="p">]</span>

        <span class="n">boxprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">boxprops</span><span class="p">,</span> <span class="s1">'boxprops'</span><span class="p">,</span> <span class="n">default_props</span><span class="p">)</span>
        <span class="n">whiskerprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">whiskerprops</span><span class="p">,</span> <span class="s1">'whiskerprops'</span><span class="p">,</span>
                                                            <span class="n">default_props</span><span class="p">)</span>
        <span class="n">capprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">capprops</span><span class="p">,</span> <span class="s1">'capprops'</span><span class="p">,</span> <span class="n">default_props</span><span class="p">)</span>
        <span class="n">medianprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">medianprops</span><span class="p">,</span> <span class="s1">'medianprops'</span><span class="p">,</span> <span class="n">default_props</span><span class="p">)</span>
        <span class="n">meanprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">meanprops</span><span class="p">,</span> <span class="s1">'meanprops'</span><span class="p">,</span> <span class="n">default_props</span><span class="p">)</span>
        <span class="n">flierprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">flierprops</span><span class="p">,</span> <span class="s1">'flierprops'</span><span class="p">,</span> <span class="n">flier_props</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
            <span class="n">boxprops</span><span class="p">[</span><span class="s1">'linestyle'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'solid'</span>
            <span class="n">boxprops</span><span class="p">[</span><span class="s1">'edgecolor'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boxprops</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'color'</span><span class="p">)</span>

        <span class="c1"># if non-default sym value, put it into the flier dictionary</span>
        <span class="c1"># the logic for providing the default symbol ('b+') now lives</span>
        <span class="c1"># in bxp in the initial value of final_flierprops</span>
        <span class="c1"># handle all of the `sym` related logic here so we only have to pass</span>
        <span class="c1"># on the flierprops dict.</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no-flier case, which should really be done with</span>
            <span class="c1"># 'showfliers=False' but none-the-less deal with it to keep back</span>
            <span class="c1"># compatibility</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">''</span><span class="p">:</span>
                <span class="c1"># blow away existing dict and make one for invisible markers</span>
                <span class="n">flierprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">'none'</span><span class="p">)</span>
                <span class="c1"># turn the fliers off just to be safe</span>
                <span class="n">showfliers</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># now process the symbol string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># process the symbol string</span>
                <span class="c1"># discarded linestyle</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
                <span class="c1"># if we have a marker, use it</span>
                <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">'marker'</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker</span>
                <span class="c1"># if we have a color, use it</span>
                <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># assume that if color is passed in the user want</span>
                    <span class="c1"># filled symbol, if the users want more control use</span>
                    <span class="c1"># flierprops</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">'color'</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">'markerfacecolor'</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">'markeredgecolor'</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>

        <span class="c1"># replace medians if necessary:</span>
        <span class="k">if</span> <span class="n">usermedians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">usermedians</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">usermedians</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'usermedians length not compatible with x'</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># reassign medians as necessary</span>
                <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">med</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">usermedians</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">med</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">stats</span><span class="p">[</span><span class="s1">'med'</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span>

        <span class="k">if</span> <span class="n">conf_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">conf_intervals</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">):</span>
                <span class="n">err_mess</span> <span class="o">=</span> <span class="s1">'conf_intervals length not compatible with x'</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_mess</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">conf_intervals</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ci</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'each confidence interval must '</span>
                                             <span class="s1">'have two values'</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">stats</span><span class="p">[</span><span class="s1">'cilo'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">stats</span><span class="p">[</span><span class="s1">'cihi'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">artists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bxp</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span>
                           <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="n">patch_artist</span><span class="p">,</span>
                           <span class="n">shownotches</span><span class="o">=</span><span class="n">notch</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="n">showmeans</span><span class="p">,</span>
                           <span class="n">showcaps</span><span class="o">=</span><span class="n">showcaps</span><span class="p">,</span> <span class="n">showbox</span><span class="o">=</span><span class="n">showbox</span><span class="p">,</span>
                           <span class="n">boxprops</span><span class="o">=</span><span class="n">boxprops</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="n">flierprops</span><span class="p">,</span>
                           <span class="n">medianprops</span><span class="o">=</span><span class="n">medianprops</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="n">meanprops</span><span class="p">,</span>
                           <span class="n">meanline</span><span class="o">=</span><span class="n">meanline</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="n">showfliers</span><span class="p">,</span>
                           <span class="n">capprops</span><span class="o">=</span><span class="n">capprops</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="n">whiskerprops</span><span class="p">,</span>
                           <span class="n">manage_xticks</span><span class="o">=</span><span class="n">manage_xticks</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">artists</span></div>

<div class="viewcode-block" id="Axes.bxp"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.bxp.html#matplotlib.axes.Axes.bxp">[docs]</a>    <span class="k">def</span> <span class="nf">bxp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bxpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">patch_artist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shownotches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">showcaps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showbox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">boxprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">medianprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">meanline</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">manage_xticks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Drawing function for box and whisker plots.</span>

<span class="sd">        Make a box and whisker plot for each column of *x* or each</span>
<span class="sd">        vector in sequence *x*.  The box extends from the lower to</span>
<span class="sd">        upper quartile values of the data, with a line at the median.</span>
<span class="sd">        The whiskers extend from the box to show the range of the</span>
<span class="sd">        data.  Flier points are those past the end of the whiskers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bxpstats : list of dicts</span>
<span class="sd">          A list of dictionaries containing stats for each boxplot.</span>
<span class="sd">          Required keys are:</span>

<span class="sd">          - ``med``: The median (scalar float).</span>

<span class="sd">          - ``q1``: The first quartile (25th percentile) (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``q3``: The third quartile (75th percentile) (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``whislo``: Lower bound of the lower whisker (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``whishi``: Upper bound of the upper whisker (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          Optional keys are:</span>

<span class="sd">          - ``mean``: The mean (scalar float). Needed if</span>
<span class="sd">            ``showmeans=True``.</span>

<span class="sd">          - ``fliers``: Data beyond the whiskers (sequence of floats).</span>
<span class="sd">            Needed if ``showfliers=True``.</span>

<span class="sd">          - ``cilo`` &amp; ``cihi``: Lower and upper confidence intervals</span>
<span class="sd">            about the median. Needed if ``shownotches=True``.</span>

<span class="sd">          - ``label``: Name of the dataset (string). If available,</span>
<span class="sd">            this will be used a tick label for the boxplot</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the boxes. The ticks and limits</span>
<span class="sd">          are automatically set to match the positions.</span>

<span class="sd">        widths : array-like, default = None</span>
<span class="sd">          Either a scalar or a vector and sets the width of each</span>
<span class="sd">          box. The default is ``0.15*(distance between extreme</span>
<span class="sd">          positions)``, clipped to no less than 0.15 and no more than</span>
<span class="sd">          0.5.</span>

<span class="sd">        vert : bool, default = False</span>
<span class="sd">          If `True` (default), makes the boxes vertical.  If `False`,</span>
<span class="sd">          makes horizontal boxes.</span>

<span class="sd">        patch_artist : bool, default = False</span>
<span class="sd">          If `False` produces boxes with the</span>
<span class="sd">          `~matplotlib.lines.Line2D` artist.  If `True` produces boxes</span>
<span class="sd">          with the `~matplotlib.patches.Patch` artist.</span>

<span class="sd">        shownotches : bool, default = False</span>
<span class="sd">          If `False` (default), produces a rectangular box plot.</span>
<span class="sd">          If `True`, will produce a notched box plot</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If `True`, will toggle on the rendering of the means</span>

<span class="sd">        showcaps  : bool, default = True</span>
<span class="sd">          If `True`, will toggle on the rendering of the caps</span>

<span class="sd">        showbox  : bool, default = True</span>
<span class="sd">          If `True`, will toggle on the rendering of the box</span>

<span class="sd">        showfliers : bool, default = True</span>
<span class="sd">          If `True`, will toggle on the rendering of the fliers</span>

<span class="sd">        boxprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the boxes</span>

<span class="sd">        whiskerprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the whiskers</span>

<span class="sd">        capprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the caps</span>

<span class="sd">        flierprops : dict or None (default)</span>
<span class="sd">          If provided will set the plotting style of the fliers</span>

<span class="sd">        medianprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the medians</span>

<span class="sd">        meanprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the means</span>

<span class="sd">        meanline : bool, default = False</span>
<span class="sd">          If `True` (and *showmeans* is `True`), will try to render the mean</span>
<span class="sd">          as a line spanning the full width of the box according to</span>
<span class="sd">          *meanprops*. Not recommended if *shownotches* is also True.</span>
<span class="sd">          Otherwise, means will be shown as points.</span>

<span class="sd">        manage_xticks : bool, default = True</span>
<span class="sd">          If the function should adjust the xlim and xtick locations.</span>

<span class="sd">        zorder : scalar,  default = None</span>
<span class="sd">          The zorder of the resulting boxplot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the boxplot to a list</span>
<span class="sd">          of the :class:`matplotlib.lines.Line2D` instances</span>
<span class="sd">          created. That dictionary has the following keys (assuming</span>
<span class="sd">          vertical boxplots):</span>

<span class="sd">          - ``boxes``: the main body of the boxplot showing the</span>
<span class="sd">            quartiles and the median's confidence intervals if</span>
<span class="sd">            enabled.</span>

<span class="sd">          - ``medians``: horizontal lines at the median of each box.</span>

<span class="sd">          - ``whiskers``: the vertical lines extending to the most</span>
<span class="sd">            extreme, non-outlier data points.</span>

<span class="sd">          - ``caps``: the horizontal lines at the ends of the</span>
<span class="sd">            whiskers.</span>

<span class="sd">          - ``fliers``: points representing data that extend beyond</span>
<span class="sd">            the whiskers (fliers).</span>

<span class="sd">          - ``means``: points or lines representing the means.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: gallery/statistics/bxp.py</span>

<span class="sd">        """</span>
        <span class="c1"># lists of artists to be output</span>
        <span class="n">whiskers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">caps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fliers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># empty list of xticklabels</span>
        <span class="n">datalabels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Use default zorder if none specified</span>
        <span class="k">if</span> <span class="n">zorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zorder</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="o">.</span><span class="n">zorder</span>

        <span class="n">zdelta</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="c1"># box properties</span>
        <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
            <span class="n">final_boxprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.boxprops.linestyle'</span><span class="p">],</span>
                <span class="n">edgecolor</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.boxprops.color'</span><span class="p">],</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'patch.facecolor'</span><span class="p">],</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.boxprops.linewidth'</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
                <span class="n">final_boxprops</span><span class="p">[</span><span class="s1">'facecolor'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'white'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_boxprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.boxprops.linestyle'</span><span class="p">],</span>
                <span class="n">color</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.boxprops.color'</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">final_boxprops</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">=</span> <span class="n">zorder</span>
        <span class="k">if</span> <span class="n">boxprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_boxprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">boxprops</span><span class="p">)</span>

        <span class="c1"># other (cap, whisker) properties</span>
        <span class="n">final_whiskerprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.whiskerprops.linestyle'</span><span class="p">],</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.whiskerprops.linewidth'</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.whiskerprops.color'</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">final_capprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.capprops.linestyle'</span><span class="p">],</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.capprops.linewidth'</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.capprops.color'</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">final_capprops</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">=</span> <span class="n">zorder</span>
        <span class="k">if</span> <span class="n">capprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_capprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">capprops</span><span class="p">)</span>

        <span class="n">final_whiskerprops</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">=</span> <span class="n">zorder</span>
        <span class="k">if</span> <span class="n">whiskerprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_whiskerprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">whiskerprops</span><span class="p">)</span>

        <span class="c1"># set up the default flier properties</span>
        <span class="n">final_flierprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.flierprops.linestyle'</span><span class="p">],</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.flierprops.linewidth'</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.flierprops.color'</span><span class="p">],</span>
            <span class="n">marker</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.flierprops.marker'</span><span class="p">],</span>
            <span class="n">markerfacecolor</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.flierprops.markerfacecolor'</span><span class="p">],</span>
            <span class="n">markeredgecolor</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.flierprops.markeredgecolor'</span><span class="p">],</span>
            <span class="n">markersize</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.flierprops.markersize'</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">final_flierprops</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">=</span> <span class="n">zorder</span>
        <span class="c1"># flier (outlier) properties</span>
        <span class="k">if</span> <span class="n">flierprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_flierprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">flierprops</span><span class="p">)</span>

        <span class="c1"># median line properties</span>
        <span class="n">final_medianprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.medianprops.linestyle'</span><span class="p">],</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.medianprops.linewidth'</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.medianprops.color'</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">final_medianprops</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">=</span> <span class="n">zorder</span> <span class="o">+</span> <span class="n">zdelta</span>
        <span class="k">if</span> <span class="n">medianprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_medianprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">medianprops</span><span class="p">)</span>

        <span class="c1"># mean (line or point) properties</span>
        <span class="k">if</span> <span class="n">meanline</span><span class="p">:</span>
            <span class="n">final_meanprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.meanprops.linestyle'</span><span class="p">],</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.meanprops.linewidth'</span><span class="p">],</span>
                <span class="n">color</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.meanprops.color'</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_meanprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.meanprops.marker'</span><span class="p">],</span>
                <span class="n">markerfacecolor</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.meanprops.markerfacecolor'</span><span class="p">],</span>
                <span class="n">markeredgecolor</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.meanprops.markeredgecolor'</span><span class="p">],</span>
                <span class="n">markersize</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'boxplot.meanprops.markersize'</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="n">final_meanprops</span><span class="p">[</span><span class="s1">'zorder'</span><span class="p">]</span> <span class="o">=</span> <span class="n">zorder</span> <span class="o">+</span> <span class="n">zdelta</span>
        <span class="k">if</span> <span class="n">meanprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_meanprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">meanprops</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">to_vc</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
            <span class="c1"># convert arguments to verts and codes, append (0, 0) (ignored).</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]),</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">codes</span> <span class="o">=</span> <span class="p">([</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">]</span>
                     <span class="o">+</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                     <span class="o">+</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">CLOSEPOLY</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">verts</span><span class="p">,</span> <span class="n">codes</span>

        <span class="k">def</span> <span class="nf">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">verts</span><span class="p">,</span> <span class="n">codes</span> <span class="o">=</span> <span class="n">to_vc</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">patch</span><span class="p">]</span>

        <span class="c1"># vertical or horizontal plot?</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">doplot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">dopatch</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">doplot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">shuffled</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">shuffled</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">shuffled</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">dopatch</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">,</span> <span class="n">xs</span>  <span class="c1"># flip X, Y</span>
                <span class="k">return</span> <span class="n">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># input validation</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)</span>
        <span class="n">datashape_message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"List of boxplot statistics and `</span><span class="si">{0}</span><span class="s2">` "</span>
                             <span class="s2">"values must have same the length"</span><span class="p">)</span>
        <span class="c1"># check position</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">"positions"</span><span class="p">))</span>

        <span class="c1"># width</span>
        <span class="k">if</span> <span class="n">widths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.15</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">"widths"</span><span class="p">))</span>

        <span class="c1"># check and save the `hold` state of the current axes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">holdStatus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">stats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">bxpstats</span><span class="p">):</span>
            <span class="c1"># try to find a new label</span>
            <span class="n">datalabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>

            <span class="c1"># whisker coords</span>
            <span class="n">whisker_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pos</span>
            <span class="n">whiskerlo_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s1">'q1'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'whislo'</span><span class="p">]])</span>
            <span class="n">whiskerhi_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s1">'q3'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'whishi'</span><span class="p">]])</span>

            <span class="c1"># cap coords</span>
            <span class="n">cap_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.25</span>
            <span class="n">cap_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.25</span>
            <span class="n">cap_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cap_left</span><span class="p">,</span> <span class="n">cap_right</span><span class="p">])</span>
            <span class="n">cap_lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'whislo'</span><span class="p">]</span>
            <span class="n">cap_hi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'whishi'</span><span class="p">]</span>

            <span class="c1"># box and median coords</span>
            <span class="n">box_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">box_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">med_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">'med'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'med'</span><span class="p">]]</span>

            <span class="c1"># notched boxes</span>
            <span class="k">if</span> <span class="n">shownotches</span><span class="p">:</span>
                <span class="n">box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">cap_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span>
                         <span class="n">box_right</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">cap_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span>
                         <span class="n">box_left</span><span class="p">]</span>
                <span class="n">box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">'q1'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'q1'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'cilo'</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">'med'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'cihi'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'q3'</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">'q3'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'cihi'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'med'</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">'cilo'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'q1'</span><span class="p">]]</span>
                <span class="n">med_x</span> <span class="o">=</span> <span class="n">cap_x</span>

            <span class="c1"># plain boxes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">]</span>
                <span class="n">box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">'q1'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'q1'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'q3'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'q3'</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">'q1'</span><span class="p">]]</span>
                <span class="n">med_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">]</span>

            <span class="c1"># maybe draw the box:</span>
            <span class="k">if</span> <span class="n">showbox</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
                    <span class="n">boxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dopatch</span><span class="p">(</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_boxprops</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">boxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_boxprops</span><span class="p">))</span>

            <span class="c1"># draw the whiskers</span>
            <span class="n">whiskers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                <span class="n">whisker_x</span><span class="p">,</span> <span class="n">whiskerlo_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_whiskerprops</span>
            <span class="p">))</span>
            <span class="n">whiskers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                <span class="n">whisker_x</span><span class="p">,</span> <span class="n">whiskerhi_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_whiskerprops</span>
            <span class="p">))</span>

            <span class="c1"># maybe draw the caps:</span>
            <span class="k">if</span> <span class="n">showcaps</span><span class="p">:</span>
                <span class="n">caps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">cap_x</span><span class="p">,</span> <span class="n">cap_lo</span><span class="p">,</span> <span class="o">**</span><span class="n">final_capprops</span><span class="p">))</span>
                <span class="n">caps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">cap_x</span><span class="p">,</span> <span class="n">cap_hi</span><span class="p">,</span> <span class="o">**</span><span class="n">final_capprops</span><span class="p">))</span>

            <span class="c1"># draw the medians</span>
            <span class="n">medians</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">med_x</span><span class="p">,</span> <span class="n">med_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_medianprops</span><span class="p">))</span>

            <span class="c1"># maybe draw the means</span>
            <span class="k">if</span> <span class="n">showmeans</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">meanline</span><span class="p">:</span>
                    <span class="n">means</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">],</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">'mean'</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'mean'</span><span class="p">]],</span>
                        <span class="o">**</span><span class="n">final_meanprops</span>
                    <span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">means</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">'mean'</span><span class="p">]],</span> <span class="o">**</span><span class="n">final_meanprops</span>
                    <span class="p">))</span>

            <span class="c1"># maybe draw the fliers</span>
            <span class="k">if</span> <span class="n">showfliers</span><span class="p">:</span>
                <span class="c1"># fliers coords</span>
                <span class="n">flier_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">'fliers'</span><span class="p">]))</span> <span class="o">*</span> <span class="n">pos</span>
                <span class="n">flier_y</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">'fliers'</span><span class="p">]</span>

                <span class="n">fliers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                    <span class="n">flier_x</span><span class="p">,</span> <span class="n">flier_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_flierprops</span>
                <span class="p">))</span>

        <span class="c1"># fix our axes/ticks up a little</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="n">setticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_xticks</span>
            <span class="n">setlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span>
            <span class="n">setlabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_xticklabels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">setticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span>
            <span class="n">setlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span>
            <span class="n">setlabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_yticklabels</span>

        <span class="k">if</span> <span class="n">manage_xticks</span><span class="p">:</span>
            <span class="n">newlimits</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">setlim</span><span class="p">(</span><span class="n">newlimits</span><span class="p">)</span>
            <span class="n">setticks</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
            <span class="n">setlabels</span><span class="p">(</span><span class="n">datalabels</span><span class="p">)</span>

        <span class="c1"># reset hold status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">holdStatus</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">whiskers</span><span class="o">=</span><span class="n">whiskers</span><span class="p">,</span> <span class="n">caps</span><span class="o">=</span><span class="n">caps</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="n">boxes</span><span class="p">,</span>
                    <span class="n">medians</span><span class="o">=</span><span class="n">medians</span><span class="p">,</span> <span class="n">fliers</span><span class="o">=</span><span class="n">fliers</span><span class="p">,</span> <span class="n">means</span><span class="o">=</span><span class="n">means</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.scatter"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"s"</span><span class="p">,</span> <span class="s2">"linewidths"</span><span class="p">,</span>
                                     <span class="s2">"edgecolors"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">,</span> <span class="s2">"facecolor"</span><span class="p">,</span>
                                     <span class="s2">"facecolors"</span><span class="p">,</span> <span class="s2">"color"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">"y"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">verts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A scatter plot of *y* vs *x* with varying marker size and/or color.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array_like, shape (n, )</span>
<span class="sd">            The data positions.</span>

<span class="sd">        s : scalar or array_like, shape (n, ), optional</span>
<span class="sd">            The marker size in points**2.</span>
<span class="sd">            Default is ``rcParams['lines.markersize'] ** 2``.</span>

<span class="sd">        c : color, sequence, or sequence of color, optional, default: 'b'</span>
<span class="sd">            The marker color. Possible values:</span>

<span class="sd">            - A single color format string.</span>
<span class="sd">            - A sequence of color specifications of length n.</span>
<span class="sd">            - A sequence of n numbers to be mapped to colors using *cmap* and</span>
<span class="sd">              *norm*.</span>
<span class="sd">            - A 2-D array in which the rows are RGB or RGBA.</span>

<span class="sd">            Note that *c* should not be a single numeric RGB or RGBA sequence</span>
<span class="sd">            because that is indistinguishable from an array of values to be</span>
<span class="sd">            colormapped. If you want to specify the same RGB or RGBA value for</span>
<span class="sd">            all points, use a 2-D array with a single row.</span>

<span class="sd">        marker : `~matplotlib.markers.MarkerStyle`, optional, default: 'o'</span>
<span class="sd">            The marker style. *marker* can be either an instance of the class</span>
<span class="sd">            or the text shorthand for a particular marker.</span>
<span class="sd">            See `~matplotlib.markers` for more information marker styles.</span>

<span class="sd">        cmap : `~matplotlib.colors.Colormap`, optional, default: None</span>
<span class="sd">            A `.Colormap` instance or registered colormap name. *cmap* is only</span>
<span class="sd">            used if *c* is an array of floats. If ``None``, defaults to rc</span>
<span class="sd">            ``image.cmap``.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional, default: None</span>
<span class="sd">            A `.Normalize` instance is used to scale luminance data to 0, 1.</span>
<span class="sd">            *norm* is only used if *c* is an array of floats. If *None*, use</span>
<span class="sd">            the default `.colors.Normalize`.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            *vmin* and *vmax* are used in conjunction with *norm* to normalize</span>
<span class="sd">            luminance data. If None, the respective min and max of the color</span>
<span class="sd">            array is used. *vmin* and *vmax* are ignored if you pass a *norm*</span>
<span class="sd">            instance.</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        linewidths : scalar or array_like, optional, default: None</span>
<span class="sd">            The linewidth of the marker edges. Note: The default *edgecolors*</span>
<span class="sd">            is 'face'. You may want to change this as well.</span>
<span class="sd">            If *None*, defaults to rcParams ``lines.linewidth``.</span>

<span class="sd">        verts : sequence of (x, y), optional</span>
<span class="sd">            If *marker* is *None*, these vertices will be used to construct</span>
<span class="sd">            the marker.  The center of the marker is located at (0, 0) in</span>
<span class="sd">            normalized units.  The overall marker is rescaled by *s*.</span>

<span class="sd">        edgecolors : color or sequence of color, optional, default: 'face'</span>
<span class="sd">            The edge color of the marker. Possible values:</span>

<span class="sd">            - 'face': The edge color will always be the same as the face color.</span>
<span class="sd">            - 'none': No patch boundary will be drawn.</span>
<span class="sd">            - A matplotib color.</span>

<span class="sd">            For non-filled markers, the *edgecolors* kwarg is ignored and</span>
<span class="sd">            forced to 'face' internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        paths : `~matplotlib.collections.PathCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.collections.Collection` properties</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        plot : To plot scatter plots when markers are identical in size and</span>
<span class="sd">            color.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        * The `.plot` function will be faster for scatterplots where markers</span>
<span class="sd">          don't vary in size or color.</span>

<span class="sd">        * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which</span>
<span class="sd">          case all masks will be combined and only unmasked points will be</span>
<span class="sd">          plotted.</span>

<span class="sd">        * Fundamentally, scatter works with 1-D arrays; *x*, *y*, *s*, and *c*</span>
<span class="sd">          may be input as 2-D arrays, but within scatter they will be</span>
<span class="sd">          flattened. The exception is *c*, which will be flattened only if its</span>
<span class="sd">          size matches the size of *x* and *y*.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="c1"># Process **kwargs to handle aliases, conflicts with explicit kwargs:</span>

        <span class="n">facecolors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'edgecolor'</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">)</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'facecolors'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'facecolor'</span><span class="p">,</span> <span class="n">fc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">facecolors</span> <span class="o">=</span> <span class="n">fc</span>
        <span class="n">co</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'color'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">co</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"'color' kwarg must be an mpl color"</span>
                                 <span class="s2">" spec or sequence of color specs.</span><span class="se">\n</span><span class="s2">"</span>
                                 <span class="s2">"For a sequence of values to be"</span>
                                 <span class="s2">" color-mapped, use the 'c' kwarg instead."</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">co</span>
            <span class="k">if</span> <span class="n">facecolors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">facecolors</span> <span class="o">=</span> <span class="n">co</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Supply a 'c' kwarg or a 'color' kwarg"</span>
                                 <span class="s2">" but not both; they differ but"</span>
                                 <span class="s2">" their functionalities overlap."</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">facecolors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">facecolors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="s1">'b'</span>  <span class="c1"># The original default</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>
            <span class="n">c_none</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_none</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">'face'</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># np.ma.ravel yields an ndarray, not a masked array,</span>
        <span class="c1"># unless its argument is a masked array.</span>
        <span class="n">xy_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"x and y must be the same size"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'lines.markersize'</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># This doesn't have to match x, y in size.</span>

        <span class="c1"># After this block, c_array will be None unless</span>
        <span class="c1"># c is an array for mapping.  The potential ambiguity</span>
        <span class="c1"># with a sequence of 3 or 4 numbers is resolved in</span>
        <span class="c1"># favor of mapping, not rgb or rgba.</span>
        <span class="k">if</span> <span class="n">c_none</span> <span class="ow">or</span> <span class="n">co</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c_array</span><span class="o">.</span><span class="n">shape</span> <span class="ow">in</span> <span class="n">xy_shape</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">c_array</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Wrong size; it must not be intended for mapping.</span>
                    <span class="n">c_array</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># Failed to make a floating-point array; c must be color specs.</span>
                <span class="n">c_array</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">c_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># must be acceptable as PathCollection facecolors</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># c not acceptable as PathCollection facecolor</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"c of shape </span><span class="si">{}</span><span class="s2"> not acceptable as a color "</span>
                                 <span class="s2">"sequence for x with size </span><span class="si">{}</span><span class="s2">, y with size </span><span class="si">{}</span><span class="s2">"</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># use cmap, norm after collection is created</span>

        <span class="c1"># `delete_masked_points` only modifies arguments of the same length as</span>
        <span class="c1"># `x`.</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span> <span class="o">=</span>\
            <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>

        <span class="n">scales</span> <span class="o">=</span> <span class="n">s</span>   <span class="c1"># Renamed for readability below.</span>

        <span class="c1"># to be API compatible</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">verts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># load default marker from rcParams</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'scatter.marker'</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">mmarkers</span><span class="o">.</span><span class="n">MarkerStyle</span><span class="p">):</span>
            <span class="n">marker_obj</span> <span class="o">=</span> <span class="n">marker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">marker_obj</span> <span class="o">=</span> <span class="n">mmarkers</span><span class="o">.</span><span class="n">MarkerStyle</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span>
            <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_transform</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">is_filled</span><span class="p">():</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">'face'</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'lines.linewidth'</span><span class="p">]</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PathCollection</span><span class="p">(</span>
                <span class="p">(</span><span class="n">path</span><span class="p">,),</span> <span class="n">scales</span><span class="p">,</span>
                <span class="n">facecolors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
                <span class="n">transOffset</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'transform'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">),</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span>
                <span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">"'norm' must be an instance of 'mcolors.Normalize'"</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="c1"># Classic mode only:</span>
        <span class="c1"># ensure there are margins to allow for the</span>
        <span class="c1"># finite size of the symbols.  In v2.x, margins</span>
        <span class="c1"># are present by default, so we disable this</span>
        <span class="c1"># scatter-specific override.</span>
        <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmargin</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xmargin</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ymargin</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_ymargin</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.hexbin"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.hexbin.html#matplotlib.axes.Axes.hexbin">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">"y"</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">hexbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gridsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">xscale</span><span class="o">=</span><span class="s1">'linear'</span><span class="p">,</span> <span class="n">yscale</span><span class="o">=</span><span class="s1">'linear'</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">'face'</span><span class="p">,</span>
               <span class="n">reduce_C_function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">mincnt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marginals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Make a hexagonal binning plot.</span>

<span class="sd">        Make a hexagonal binning plot of *x* versus *y*, where *x*,</span>
<span class="sd">        *y* are 1-D sequences of the same length, *N*. If *C* is *None*</span>
<span class="sd">        (the default), this is a histogram of the number of occurrences</span>
<span class="sd">        of the observations at (x[i],y[i]).</span>

<span class="sd">        If *C* is specified, it specifies values at the coordinate</span>
<span class="sd">        (x[i],y[i]). These values are accumulated for each hexagonal</span>
<span class="sd">        bin and then reduced according to *reduce_C_function*, which</span>
<span class="sd">        defaults to numpy's mean function (np.mean). (If *C* is</span>
<span class="sd">        specified, it must also be a 1-D sequence of the same length</span>
<span class="sd">        as *x* and *y*.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array or masked array</span>

<span class="sd">        C : array or masked array, optional, default is *None*</span>

<span class="sd">        gridsize : int or (int, int), optional, default is 100</span>
<span class="sd">            The number of hexagons in the *x*-direction, default is</span>
<span class="sd">            100. The corresponding number of hexagons in the</span>
<span class="sd">            *y*-direction is chosen such that the hexagons are</span>
<span class="sd">            approximately regular. Alternatively, gridsize can be a</span>
<span class="sd">            tuple with two elements specifying the number of hexagons</span>
<span class="sd">            in the *x*-direction and the *y*-direction.</span>

<span class="sd">        bins : {'log'} or int or sequence, optional, default is *None*</span>
<span class="sd">            If *None*, no binning is applied; the color of each hexagon</span>
<span class="sd">            directly corresponds to its count value.</span>

<span class="sd">            If 'log', use a logarithmic scale for the color</span>
<span class="sd">            map. Internally, :math:`log_{10}(i+1)` is used to</span>
<span class="sd">            determine the hexagon color.</span>

<span class="sd">            If an integer, divide the counts in the specified number</span>
<span class="sd">            of bins, and color the hexagons accordingly.</span>

<span class="sd">            If a sequence of values, the values of the lower bound of</span>
<span class="sd">            the bins to be used.</span>

<span class="sd">        xscale : {'linear', 'log'}, optional, default is 'linear'</span>
<span class="sd">            Use a linear or log10 scale on the horizontal axis.</span>

<span class="sd">        yscale : {'linear', 'log'}, optional, default is 'linear'</span>
<span class="sd">            Use a linear or log10 scale on the vertical axis.</span>

<span class="sd">        mincnt : int &gt; 0, optional, default is *None*</span>
<span class="sd">            If not *None*, only display cells with more than *mincnt*</span>
<span class="sd">            number of points in the cell</span>

<span class="sd">        marginals : bool, optional, default is *False*</span>
<span class="sd">            if marginals is *True*, plot the marginal density as</span>
<span class="sd">            colormapped rectagles along the bottom of the x-axis and</span>
<span class="sd">            left of the y-axis</span>

<span class="sd">        extent : scalar, optional, default is *None*</span>
<span class="sd">            The limits of the bins. The default assigns the limits</span>
<span class="sd">            based on *gridsize*, *x*, *y*, *xscale* and *yscale*.</span>

<span class="sd">            If *xscale* or *yscale* is set to 'log', the limits are</span>
<span class="sd">            expected to be the exponent for a power of 10. E.g. for</span>
<span class="sd">            x-limits of 1 and 50 in 'linear' scale and y-limits</span>
<span class="sd">            of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).</span>

<span class="sd">            Order of scalars is (left, right, bottom, top).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        cmap : object, optional, default is *None*</span>
<span class="sd">            a :class:`matplotlib.colors.Colormap` instance. If *None*,</span>
<span class="sd">            defaults to rc ``image.cmap``.</span>

<span class="sd">        norm : object, optional, default is *None*</span>
<span class="sd">            :class:`matplotlib.colors.Normalize` instance is used to</span>
<span class="sd">            scale luminance data to 0,1.</span>

<span class="sd">        vmin, vmax : scalar, optional, default is *None*</span>
<span class="sd">            *vmin* and *vmax* are used in conjunction with *norm* to</span>
<span class="sd">            normalize luminance data. If *None*, the min and max of the</span>
<span class="sd">            color array *C* are used.  Note if you pass a norm instance</span>
<span class="sd">            your settings for *vmin* and *vmax* will be ignored.</span>

<span class="sd">        alpha : scalar between 0 and 1, optional, default is *None*</span>
<span class="sd">            the alpha value for the patches</span>

<span class="sd">        linewidths : scalar, optional, default is *None*</span>
<span class="sd">            If *None*, defaults to 1.0.</span>

<span class="sd">        edgecolors : {'face', 'none', *None*} or color, optional</span>

<span class="sd">            If 'face' (the default), draws the edges in the same color as the</span>
<span class="sd">            fill color.</span>

<span class="sd">            If 'none', no edge is drawn; this can sometimes lead to unsightly</span>
<span class="sd">            unpainted pixels between the hexagons.</span>

<span class="sd">            If *None*, draws outlines in the default color.</span>

<span class="sd">            If a matplotlib color arg, draws outlines in the specified color.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            a :class:`~matplotlib.collections.PolyCollection` instance; use</span>
<span class="sd">            :meth:`~matplotlib.collections.PolyCollection.get_array` on</span>
<span class="sd">            this :class:`~matplotlib.collections.PolyCollection` to get</span>
<span class="sd">            the counts in each hexagon.</span>

<span class="sd">            If *marginals* is *True*, horizontal</span>
<span class="sd">            bar and vertical bar (both PolyCollections) will be attached</span>
<span class="sd">            to the return collection as attributes *hbar* and *vbar*.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The standard descriptions of all the</span>
<span class="sd">        :class:`~matplotlib.collections.Collection` parameters:</span>

<span class="sd">            %(Collection)s</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

        <span class="c1"># Set the size of the hexagon grid</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">gridsize</span><span class="p">):</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">gridsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">gridsize</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nx</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Count the number of data in each hexagon</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">'log'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"x contains non-positive values, so can not"</span>
                                 <span class="s2">" be log-scaled"</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">'log'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"y contains non-positive values, so can not"</span>
                                 <span class="s2">" be log-scaled"</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># to avoid issues with singular data, expand the min/max pairs</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># In the x-direction, the hexagons exactly cover the region from</span>
        <span class="c1"># xmin to xmax. Need some padding to avoid roundoff errors.</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="mf">1.e-9</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">-=</span> <span class="n">padding</span>
        <span class="n">xmax</span> <span class="o">+=</span> <span class="n">padding</span>
        <span class="n">sx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">ny</span>

        <span class="k">if</span> <span class="n">marginals</span><span class="p">:</span>
            <span class="n">xorig</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">yorig</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">sx</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">sy</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">iy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">iy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">nx1</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ny1</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nx2</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="n">ny2</span> <span class="o">=</span> <span class="n">ny</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span> <span class="o">+</span> <span class="n">nx2</span> <span class="o">*</span> <span class="n">ny2</span>

        <span class="n">d1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">ix1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">iy1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">ix2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">iy2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">bdist</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lattice1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx1</span><span class="p">,</span> <span class="n">ny1</span><span class="p">))</span>
            <span class="n">lattice2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx2</span><span class="p">,</span> <span class="n">ny2</span><span class="p">))</span>

            <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ix1</span> <span class="o">&lt;</span> <span class="n">nx1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iy1</span> <span class="o">&lt;</span> <span class="n">ny1</span><span class="p">)</span>
            <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ix2</span> <span class="o">&lt;</span> <span class="n">nx2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iy2</span> <span class="o">&lt;</span> <span class="n">ny2</span><span class="p">)</span>

            <span class="n">cond1</span> <span class="o">*=</span> <span class="n">bdist</span>
            <span class="n">cond2</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bdist</span><span class="p">)</span>
            <span class="n">ix1</span><span class="p">,</span> <span class="n">iy1</span> <span class="o">=</span> <span class="n">ix1</span><span class="p">[</span><span class="n">cond1</span><span class="p">],</span> <span class="n">iy1</span><span class="p">[</span><span class="n">cond1</span><span class="p">]</span>
            <span class="n">ix2</span><span class="p">,</span> <span class="n">iy2</span> <span class="o">=</span> <span class="n">ix2</span><span class="p">[</span><span class="n">cond2</span><span class="p">],</span> <span class="n">iy2</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ix1</span><span class="p">,</span> <span class="n">iy1</span><span class="p">):</span>
                <span class="n">lattice1</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy2</span><span class="p">):</span>
                <span class="n">lattice2</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># threshold</span>
            <span class="k">if</span> <span class="n">mincnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lattice1</span><span class="p">[</span><span class="n">lattice1</span> <span class="o">&lt;</span> <span class="n">mincnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">lattice2</span><span class="p">[</span><span class="n">lattice2</span> <span class="o">&lt;</span> <span class="n">mincnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">lattice1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                               <span class="n">lattice2</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="n">good_idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mincnt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mincnt</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># create accumulation arrays</span>
            <span class="n">lattice1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nx1</span><span class="p">,</span> <span class="n">ny1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nx1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">ny1</span><span class="p">):</span>
                    <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lattice2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nx2</span><span class="p">,</span> <span class="n">ny2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nx2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">ny2</span><span class="p">):</span>
                    <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">bdist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nx1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ny1</span><span class="p">:</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nx2</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ny2</span><span class="p">:</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nx1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">ny1</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mincnt</span><span class="p">:</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nx2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">ny2</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mincnt</span><span class="p">:</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">lattice1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                               <span class="n">lattice2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="n">good_idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx1</span><span class="p">),</span> <span class="n">ny1</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny1</span><span class="p">),</span> <span class="n">nx1</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ny2</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny2</span><span class="p">),</span> <span class="n">nx2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sx</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sy</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xmin</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ymin</span>
        <span class="c1"># remove accumulation bins with no data</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="n">accum</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">]</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span>

        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">'log'</span> <span class="ow">or</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">'log'</span><span class="p">:</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">'log'</span><span class="p">:</span>
                <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">xmin</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">xmax</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="n">xscale</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">'log'</span><span class="p">:</span>
                <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">ymin</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">ymax</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="n">yscale</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="n">polygons</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="p">[</span><span class="n">polygon</span><span class="p">],</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
                <span class="n">transOffset</span><span class="o">=</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">(),</span>
                <span class="n">offset_position</span><span class="o">=</span><span class="s2">"data"</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">accum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># make sure we have not zeros</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># autoscale the norm with curren accum values if it hasn't</span>
        <span class="c1"># been set</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">norm</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="c1"># Transform accum if needed</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="o">==</span> <span class="s1">'log'</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">accum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
                <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">accum</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>
                <span class="n">bins</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># one less edge than bins</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">minimum</span> <span class="o">+</span> <span class="p">(</span><span class="n">maximum</span> <span class="o">-</span> <span class="n">minimum</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">bins</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"'norm' must be an instance of 'mcolors.Normalize'"</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="p">((</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">]</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># add the collection last</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marginals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collection</span>

        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">coarse_bin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coarse</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">coarse</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)):</span>
                <span class="n">yi</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">mus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>
            <span class="k">return</span> <span class="n">mus</span>

        <span class="n">coarse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">gridsize</span><span class="p">)</span>

        <span class="n">xcoarse</span> <span class="o">=</span> <span class="n">coarse_bin</span><span class="p">(</span><span class="n">xorig</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xcoarse</span><span class="p">)</span>
        <span class="n">verts</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xcoarse</span><span class="p">):</span>
            <span class="n">thismin</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">thismin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coarse</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">thismin</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismin</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismax</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismax</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">'grid'</span><span class="p">)</span>

        <span class="n">hbar</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">'face'</span><span class="p">)</span>

        <span class="n">hbar</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">hbar</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">coarse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">gridsize</span><span class="p">)</span>
        <span class="n">ycoarse</span> <span class="o">=</span> <span class="n">coarse_bin</span><span class="p">(</span><span class="n">yorig</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ycoarse</span><span class="p">)</span>
        <span class="n">verts</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ycoarse</span><span class="p">):</span>
            <span class="n">thismin</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">thismin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coarse</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">thismin</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">thismax</span><span class="p">),</span>
                          <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">thismax</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">thismin</span><span class="p">)])</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">'grid'</span><span class="p">)</span>

        <span class="n">vbar</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">'face'</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">vbar</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">hbar</span> <span class="o">=</span> <span class="n">hbar</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">vbar</span> <span class="o">=</span> <span class="n">vbar</span>

        <span class="k">def</span> <span class="nf">on_changed</span><span class="p">(</span><span class="n">collection</span><span class="p">):</span>
            <span class="n">hbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">())</span>
            <span class="n">hbar</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_clim</span><span class="p">())</span>
            <span class="n">vbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">())</span>
            <span class="n">vbar</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_clim</span><span class="p">())</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">callbacksSM</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">'changed'</span><span class="p">,</span> <span class="n">on_changed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.arrow"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.arrow.html#matplotlib.axes.Axes.arrow">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">arrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add an arrow to the axes.</span>

<span class="sd">        This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : float</span>
<span class="sd">            The x/y-coordinate of the arrow base.</span>
<span class="sd">        dx, dy : float</span>
<span class="sd">            The length of the arrow along x/y-direction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arrow : `.FancyArrow`</span>
<span class="sd">            The created `.FancyArrow` object.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Optional kwargs (inherited from `.FancyArrow` patch) control the</span>
<span class="sd">            arrow construction and properties:</span>

<span class="sd">        %(FancyArrow)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The resulting arrow is affected by the axes aspect ratio and limits.</span>
<span class="sd">        This may produce an arrow whose head is not square with its stem. To</span>
<span class="sd">        create an arrow whose head is square with its stem,</span>
<span class="sd">        use :meth:`annotate` for example:</span>

<span class="sd">        &gt;&gt;&gt; ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),</span>
<span class="sd">        ...             arrowprops=dict(arrowstyle="-&gt;"))</span>

<span class="sd">        """</span>
        <span class="c1"># Strip away units for the underlying patch since units</span>
        <span class="c1"># do not make sense to most patch-like code</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">FancyArrow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Axes.quiverkey"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.quiverkey.html#matplotlib.axes.Axes.quiverkey">[docs]</a>    <span class="k">def</span> <span class="nf">quiverkey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">qk</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">QuiverKey</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qk</span></div>
    <span class="n">quiverkey</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">QuiverKey</span><span class="o">.</span><span class="n">quiverkey_doc</span>

    <span class="c1"># Handle units for x and y, if they've been passed</span>
    <span class="k">def</span> <span class="nf">_quiver_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="c1"># args can by a combination if X, Y, U, V, C and all should be replaced</span>
<div class="viewcode-block" id="Axes.quiver"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.quiver.html#matplotlib.axes.Axes.quiver">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_all_args</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="c1"># Make sure units are handled for x and y values</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quiver_units</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span></div>
    <span class="n">quiver</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Quiver</span><span class="o">.</span><span class="n">quiver_doc</span>

    <span class="c1"># args can by either Y or y1,y2,... and all should be replaced</span>
<div class="viewcode-block" id="Axes.stackplot"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.stackplot.html#matplotlib.axes.Axes.stackplot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_all_args</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stackplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mstack</span><span class="o">.</span><span class="n">stackplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">stackplot</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mstack</span><span class="o">.</span><span class="n">stackplot</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Axes.streamplot"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.streamplot.html#matplotlib.axes.Axes.streamplot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"u"</span><span class="p">,</span> <span class="s2">"v"</span><span class="p">,</span> <span class="s2">"start_points"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">streamplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">arrowstyle</span><span class="o">=</span><span class="s1">'-|&gt;'</span><span class="p">,</span>
                   <span class="n">minlength</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">start_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxlength</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
                   <span class="n">integration_direction</span><span class="o">=</span><span class="s1">'both'</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">stream_container</span> <span class="o">=</span> <span class="n">mstream</span><span class="o">.</span><span class="n">streamplot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
            <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">arrowsize</span><span class="o">=</span><span class="n">arrowsize</span><span class="p">,</span>
            <span class="n">arrowstyle</span><span class="o">=</span><span class="n">arrowstyle</span><span class="p">,</span>
            <span class="n">minlength</span><span class="o">=</span><span class="n">minlength</span><span class="p">,</span>
            <span class="n">start_points</span><span class="o">=</span><span class="n">start_points</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>
            <span class="n">maxlength</span><span class="o">=</span><span class="n">maxlength</span><span class="p">,</span>
            <span class="n">integration_direction</span><span class="o">=</span><span class="n">integration_direction</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream_container</span></div>
    <span class="n">streamplot</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mstream</span><span class="o">.</span><span class="n">streamplot</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="c1"># args can be some combination of X, Y, U, V, C and all should be replaced</span>
<div class="viewcode-block" id="Axes.barbs"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.barbs.html#matplotlib.axes.Axes.barbs">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_all_args</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">barbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        %(barbs_doc)s</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="c1"># Make sure units are handled for x and y values</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quiver_units</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Barbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">b</span></div>

<div class="viewcode-block" id="Axes.fill"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.fill.html#matplotlib.axes.Axes.fill">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">positional_parameter_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot filled polygons.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : sequence of x, y, [color]</span>
<span class="sd">            Each polygon is defined by the lists of *x* and *y* positions of</span>
<span class="sd">            its nodes, optionally followed by by a *color* specifier. See</span>
<span class="sd">            :mod:`matplotlib.colors` for supported color specifiers. The</span>
<span class="sd">            standard color cycle is used for polygons without a color</span>
<span class="sd">            specifier.</span>

<span class="sd">            You can plot multiple polygons by providing multiple *x*, *y*,</span>
<span class="sd">            *[color]* groups.</span>

<span class="sd">            For example, each of the following is legal::</span>

<span class="sd">                ax.fill(x, y)                    # a polygon with default color</span>
<span class="sd">                ax.fill(x, y, "b")               # a blue polygon</span>
<span class="sd">                ax.fill(x, y, x2, y2)            # two polygons</span>
<span class="sd">                ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a list of :class:`~matplotlib.patches.Polygon`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : :class:`~matplotlib.patches.Polygon` properties</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Use :meth:`fill_between` if you would like to fill the region between</span>
<span class="sd">        two curves.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">_alias_map</span><span class="p">)</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">patches</span></div>

<div class="viewcode-block" id="Axes.fill_between"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.fill_between.html#matplotlib.axes.Axes.fill_between">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y1"</span><span class="p">,</span> <span class="s2">"y2"</span><span class="p">,</span> <span class="s2">"where"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">fill_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fill the area between two horizontal curves.</span>

<span class="sd">        The curves are defined by the points (*x*, *y1*) and (*x*, *y2*). This</span>
<span class="sd">        creates one or multiple polygons describing the filled area.</span>

<span class="sd">        You may exclude some horizontal sections from filling using *where*.</span>

<span class="sd">        By default, the edges connect the given points directly. Use *step* if</span>
<span class="sd">        the filling should be a step function, i.e. constant in between *x*.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array (length N)</span>
<span class="sd">            The x coordinates of the nodes defining the curves.</span>

<span class="sd">        y1 : array (length N) or scalar</span>
<span class="sd">            The y coordinates of the nodes defining the first curve.</span>

<span class="sd">        y2 : array (length N) or scalar, optional, default: 0</span>
<span class="sd">            The y coordinates of the nodes defining the second curve.</span>

<span class="sd">        where : array of bool (length N), optional, default: None</span>
<span class="sd">            Define *where* to exclude some horizontal regions from being</span>
<span class="sd">            filled. The filled regions are defined by the coordinates</span>
<span class="sd">            ``x[where]``.  More precisely, fill between ``x[i]`` and ``x[i+1]``</span>
<span class="sd">            if ``where[i] and where[i+1]``.  Note that this definition implies</span>
<span class="sd">            that an isolated *True* value between two *False* values in</span>
<span class="sd">            *where* will not result in filling.  Both sides of the *True*</span>
<span class="sd">            position remain unfilled due to the adjacent *False* values.</span>

<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            This option is only relvant if *where* is used and the two curves</span>
<span class="sd">            are crossing each other.</span>

<span class="sd">            Semantically, *where* is often used for *y1* &gt; *y2* or similar.</span>
<span class="sd">            By default, the nodes of the polygon defining the filled region</span>
<span class="sd">            will only be placed at the positions in the *x* array.  Such a</span>
<span class="sd">            polygon cannot describe the above semantics close to the</span>
<span class="sd">            intersection.  The x-sections containing the intersecion are</span>
<span class="sd">            simply clipped.</span>

<span class="sd">            Setting *interpolate* to *True* will calculate the actual</span>
<span class="sd">            interscection point and extend the filled region up to this point.</span>

<span class="sd">        step : {'pre', 'post', 'mid'}, optional</span>
<span class="sd">            Define *step* if the filling should be a step function,</span>
<span class="sd">            i.e. constant in between *x*. The value determines where the</span>
<span class="sd">            step will occur:</span>

<span class="sd">            - 'pre': The y value is continued constantly to the left from</span>
<span class="sd">              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - 'post': The y value is continued constantly to the right from</span>
<span class="sd">              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - 'mid': Steps occur half-way between the *x* positions.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments are passed on to `.PolyCollection`.</span>
<span class="sd">            They control the `.Polygon` properties:</span>

<span class="sd">            %(PolyCollection)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.PolyCollection`</span>
<span class="sd">            A `.PolyCollection` containing the plotted polygons.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fill_betweenx : Fill between two sets of x-values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [notes section required to get data note injection right]</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
            <span class="n">color_aliases</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">_color_aliases</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">color_aliases</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'color'</span><span class="p">,</span> <span class="s1">'facecolors'</span><span class="p">)):</span>
                <span class="n">fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">'facecolors'</span><span class="p">]</span> <span class="o">=</span> <span class="n">fc</span>

        <span class="c1"># Handle united data, such as dates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y2</span><span class="p">)</span>

        <span class="c1"># Convert the arrays so we can work with them</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">'x'</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s1">'y1'</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="s1">'y2'</span><span class="p">,</span> <span class="n">y2</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Input passed into argument "</span><span class="si">%r</span><span class="s1">"'</span> <span class="o">%</span> <span class="n">name</span> <span class="o">+</span>
                                 <span class="s1">'is not 1-dimensional.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">where</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
                                          <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">]))</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">xslice</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">y1slice</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">y2slice</span> <span class="o">=</span> <span class="n">y2</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">step_func</span> <span class="o">=</span> <span class="n">STEP_LOOKUP_MAP</span><span class="p">[</span><span class="s2">"steps-"</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span>
                <span class="n">xslice</span><span class="p">,</span> <span class="n">y1slice</span><span class="p">,</span> <span class="n">y2slice</span> <span class="o">=</span> <span class="n">step_func</span><span class="p">(</span><span class="n">xslice</span><span class="p">,</span> <span class="n">y1slice</span><span class="p">,</span> <span class="n">y2slice</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">get_interp_point</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                    <span class="n">im1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">x_values</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">diff_values</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y2</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1_values</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">im1</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

                    <span class="n">diff_order</span> <span class="o">=</span> <span class="n">diff_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">diff_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">],</span> <span class="n">x_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">])</span>
                    <span class="n">x_order</span> <span class="o">=</span> <span class="n">x_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">diff_root_x</span><span class="p">,</span> <span class="n">x_values</span><span class="p">[</span><span class="n">x_order</span><span class="p">],</span>
                                            <span class="n">y1_values</span><span class="p">[</span><span class="n">x_order</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">diff_root_x</span><span class="p">,</span> <span class="n">diff_root_y</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind0</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the purpose of the next two lines is for when y2 is a</span>
                <span class="c1"># scalar like 0 and we want the fill to go all the way</span>
                <span class="c1"># down to 0 even if none of the y1 sample points do</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y2slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y2slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>

            <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xslice</span>
            <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1slice</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y2slice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now update the datalim and autoscale</span>
        <span class="n">XY1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">XY2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">XY1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">XY2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.fill_betweenx"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.fill_betweenx.html#matplotlib.axes.Axes.fill_betweenx">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"y"</span><span class="p">,</span> <span class="s2">"x1"</span><span class="p">,</span> <span class="s2">"x2"</span><span class="p">,</span> <span class="s2">"where"</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">fill_betweenx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fill the area between two vertical curves.</span>

<span class="sd">        The curves are defined by the points (*x1*, *y*) and (*x2*, *y*). This</span>
<span class="sd">        creates one or multiple polygons describing the filled area.</span>

<span class="sd">        You may exclude some vertical sections from filling using *where*.</span>

<span class="sd">        By default, the edges connect the given points directly. Use *step* if</span>
<span class="sd">        the filling should be a step function, i.e. constant in between *y*.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array (length N)</span>
<span class="sd">            The y coordinates of the nodes defining the curves.</span>

<span class="sd">        x1 : array (length N) or scalar</span>
<span class="sd">            The x coordinates of the nodes defining the first curve.</span>

<span class="sd">        x2 : array (length N) or scalar, optional, default: 0</span>
<span class="sd">            The x coordinates of the nodes defining the second curve.</span>

<span class="sd">        where : array of bool (length N), optional, default: None</span>
<span class="sd">            Define *where* to exclude some vertical regions from being</span>
<span class="sd">            filled. The filled regions are defined by the coordinates</span>
<span class="sd">            ``y[where]``.  More precisely, fill between ``y[i]`` and ``y[i+1]``</span>
<span class="sd">            if ``where[i] and where[i+1]``.  Note that this definition implies</span>
<span class="sd">            that an isolated *True* value between two *False* values in</span>
<span class="sd">            *where* will not result in filling.  Both sides of the *True*</span>
<span class="sd">            position remain unfilled due to the adjacent *False* values.</span>

<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            This option is only relvant if *where* is used and the two curves</span>
<span class="sd">            are crossing each other.</span>

<span class="sd">            Semantically, *where* is often used for *x1* &gt; *x2* or similar.</span>
<span class="sd">            By default, the nodes of the polygon defining the filled region</span>
<span class="sd">            will only be placed at the positions in the *y* array.  Such a</span>
<span class="sd">            polygon cannot describe the above semantics close to the</span>
<span class="sd">            intersection.  The y-sections containing the intersecion are</span>
<span class="sd">            simply clipped.</span>

<span class="sd">            Setting *interpolate* to *True* will calculate the actual</span>
<span class="sd">            interscection point and extend the filled region up to this point.</span>

<span class="sd">        step : {'pre', 'post', 'mid'}, optional</span>
<span class="sd">            Define *step* if the filling should be a step function,</span>
<span class="sd">            i.e. constant in between *y*. The value determines where the</span>
<span class="sd">            step will occur:</span>

<span class="sd">            - 'pre': The y value is continued constantly to the left from</span>
<span class="sd">              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - 'post': The y value is continued constantly to the right from</span>
<span class="sd">              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - 'mid': Steps occur half-way between the *x* positions.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments are passed on to `.PolyCollection`.</span>
<span class="sd">            They control the `.Polygon` properties:</span>

<span class="sd">            %(PolyCollection)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.PolyCollection`</span>
<span class="sd">            A `.PolyCollection` containing the plotted polygons.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fill_between : Fill between two sets of y-values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [notes section required to get data note injection right]</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
            <span class="n">color_aliases</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">_color_aliases</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">color_aliases</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'color'</span><span class="p">,</span> <span class="s1">'facecolors'</span><span class="p">)):</span>
                <span class="n">fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">'facecolors'</span><span class="p">]</span> <span class="o">=</span> <span class="n">fc</span>
        <span class="c1"># Handle united data, such as dates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">xdata</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x2</span><span class="p">)</span>

        <span class="c1"># Convert the arrays so we can work with them</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">'y'</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="s1">'x1'</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="p">(</span><span class="s1">'x2'</span><span class="p">,</span> <span class="n">x2</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Input passed into argument "</span><span class="si">%r</span><span class="s1">"'</span> <span class="o">%</span> <span class="n">name</span> <span class="o">+</span>
                                 <span class="s1">'is not 1-dimensional.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">where</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
                                          <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]))</span>

        <span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">yslice</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">x1slice</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">x2slice</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">step_func</span> <span class="o">=</span> <span class="n">STEP_LOOKUP_MAP</span><span class="p">[</span><span class="s2">"steps-"</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span>
                <span class="n">yslice</span><span class="p">,</span> <span class="n">x1slice</span><span class="p">,</span> <span class="n">x2slice</span> <span class="o">=</span> <span class="n">step_func</span><span class="p">(</span><span class="n">yslice</span><span class="p">,</span> <span class="n">x1slice</span><span class="p">,</span> <span class="n">x2slice</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">yslice</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yslice</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">get_interp_point</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                    <span class="n">im1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">y_values</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">diff_values</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">x1_values</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x1</span><span class="p">[</span><span class="n">im1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x1</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

                    <span class="n">diff_order</span> <span class="o">=</span> <span class="n">diff_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">diff_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">],</span> <span class="n">y_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">])</span>
                    <span class="n">y_order</span> <span class="o">=</span> <span class="n">y_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">diff_root_y</span><span class="p">,</span> <span class="n">y_values</span><span class="p">[</span><span class="n">y_order</span><span class="p">],</span>
                                            <span class="n">x1_values</span><span class="p">[</span><span class="n">y_order</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">diff_root_x</span><span class="p">,</span> <span class="n">diff_root_y</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind0</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the purpose of the next two lines is for when x2 is a</span>
                <span class="c1"># scalar like 0 and we want the fill to go all the way</span>
                <span class="c1"># down to 0 even if none of the x1 sample points do</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yslice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>

            <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1slice</span>
            <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yslice</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yslice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now update the datalim and autoscale</span>
        <span class="n">X1Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X2Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x2</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">X1Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">X2Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span></div>

    <span class="c1">#### plotting z(x,y): imshow, pcolor and relatives, contour</span>
<div class="viewcode-block" id="Axes.imshow"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.imshow.html#matplotlib.axes.Axes.imshow">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">imshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filternorm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">filterrad</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">imlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Display an image on the axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like, shape (n, m) or (n, m, 3) or (n, m, 4)</span>
<span class="sd">            Display the image in `X` to current axes.  `X` may be an</span>
<span class="sd">            array or a PIL image. If `X` is an array, it</span>
<span class="sd">            can have the following shapes and types:</span>

<span class="sd">            - MxN -- values to be mapped (float or int)</span>
<span class="sd">            - MxNx3 -- RGB (float or uint8)</span>
<span class="sd">            - MxNx4 -- RGBA (float or uint8)</span>

<span class="sd">            MxN arrays are mapped to colors based on the `norm` (mapping</span>
<span class="sd">            scalar to scalar) and the `cmap` (mapping the normed scalar to</span>
<span class="sd">            a color).</span>

<span class="sd">            Elements of RGB and RGBA arrays represent pixels of an MxN image.</span>
<span class="sd">            All values should be in the range [0 .. 1] for floats or</span>
<span class="sd">            [0 .. 255] for integers.  Out-of-range values will be clipped to</span>
<span class="sd">            these bounds.</span>

<span class="sd">        cmap : `~matplotlib.colors.Colormap`, optional, default: None</span>
<span class="sd">            If None, default to rc `image.cmap` value. `cmap` is ignored</span>
<span class="sd">            if `X` is 3-D, directly specifying RGB(A) values.</span>

<span class="sd">        aspect : ['auto' | 'equal' | scalar], optional, default: None</span>
<span class="sd">            If 'auto', changes the image aspect ratio to match that of the</span>
<span class="sd">            axes.</span>

<span class="sd">            If 'equal', and `extent` is None, changes the axes aspect ratio to</span>
<span class="sd">            match that of the image. If `extent` is not `None`, the axes</span>
<span class="sd">            aspect ratio is changed to match that of the extent.</span>

<span class="sd">            If None, default to rc ``image.aspect`` value.</span>

<span class="sd">        interpolation : string, optional, default: None</span>
<span class="sd">            Acceptable values are 'none', 'nearest', 'bilinear', 'bicubic',</span>
<span class="sd">            'spline16', 'spline36', 'hanning', 'hamming', 'hermite', 'kaiser',</span>
<span class="sd">            'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc',</span>
<span class="sd">            'lanczos'</span>

<span class="sd">            If `interpolation` is None, default to rc `image.interpolation`.</span>
<span class="sd">            See also the `filternorm` and `filterrad` parameters.</span>
<span class="sd">            If `interpolation` is 'none', then no interpolation is performed</span>
<span class="sd">            on the Agg, ps and pdf backends. Other backends will fall back to</span>
<span class="sd">            'nearest'.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional, default: None</span>
<span class="sd">            A `~matplotlib.colors.Normalize` instance is used to scale</span>
<span class="sd">            a 2-D float `X` input to the (0, 1) range for input to the</span>
<span class="sd">            `cmap`. If `norm` is None, use the default func:`normalize`.</span>
<span class="sd">            If `norm` is an instance of `~matplotlib.colors.NoNorm`,</span>
<span class="sd">            `X` must be an array of integers that index directly into</span>
<span class="sd">            the lookup table of the `cmap`.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            `vmin` and `vmax` are used in conjunction with norm to normalize</span>
<span class="sd">            luminance data.  Note if you pass a `norm` instance, your</span>
<span class="sd">            settings for `vmin` and `vmax` will be ignored.</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>
<span class="sd">            The ``alpha`` argument is ignored for RGBA input data.</span>

<span class="sd">        origin : ['upper' | 'lower'], optional, default: None</span>
<span class="sd">            Place the [0,0] index of the array in the upper left or lower left</span>
<span class="sd">            corner of the axes. If None, default to rc `image.origin`.</span>

<span class="sd">        extent : scalars (left, right, bottom, top), optional, default: None</span>
<span class="sd">            The location, in data-coordinates, of the lower-left and</span>
<span class="sd">            upper-right corners. If `None`, the image is positioned such that</span>
<span class="sd">            the pixel centers fall on zero-based (row, column) indices.</span>

<span class="sd">        shape : scalars (columns, rows), optional, default: None</span>
<span class="sd">            For raw buffer images</span>

<span class="sd">        filternorm : scalar, optional, default: 1</span>
<span class="sd">            A parameter for the antigrain image resize filter.  From the</span>
<span class="sd">            antigrain documentation, if `filternorm` = 1, the filter</span>
<span class="sd">            normalizes integer values and corrects the rounding errors. It</span>
<span class="sd">            doesn't do anything with the source floating point values, it</span>
<span class="sd">            corrects only integers according to the rule of 1.0 which means</span>
<span class="sd">            that any sum of pixel weights must be equal to 1.0.  So, the</span>
<span class="sd">            filter function must produce a graph of the proper shape.</span>

<span class="sd">        filterrad : scalar, optional, default: 4.0</span>
<span class="sd">            The filter radius for filters that have a radius parameter, i.e.</span>
<span class="sd">            when interpolation is one of: 'sinc', 'lanczos' or 'blackman'</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : `~matplotlib.image.AxesImage`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.artist.Artist` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        matshow : Plot a matrix or an array as an image.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unless *extent* is used, pixel centers will be located at integer</span>
<span class="sd">        coordinates. In other words: the origin will coincide with the center</span>
<span class="sd">        of pixel (0, 0).</span>

<span class="sd">        Two typical representations are used for RGB images with an alpha</span>
<span class="sd">        channel:</span>

<span class="sd">        -   Straight (unassociated) alpha: R, G, and B channels represent the</span>
<span class="sd">            color of the pixel, disregarding its opacity.</span>
<span class="sd">        -   Premultiplied (associated) alpha: R, G, and B channels represent</span>
<span class="sd">            the color of the pixel, adjusted for its opacity by multiplication.</span>

<span class="sd">        `~matplotlib.pyplot.imshow` expects RGB images adopting the straight</span>
<span class="sd">        (unassociated) alpha representation.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"'norm' must be an instance of 'mcolors.Normalize'"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aspect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aspect</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'image.aspect'</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">AxesImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span>
                              <span class="n">filternorm</span><span class="o">=</span><span class="n">filternorm</span><span class="p">,</span> <span class="n">filterrad</span><span class="o">=</span><span class="n">filterrad</span><span class="p">,</span>
                              <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># image does not already have clipping set, clip to axes patch</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="c1">#if norm is None and shape is None:</span>
        <span class="c1">#    im.set_clim(vmin, vmax)</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

        <span class="c1"># update ax.dataLim, and, if autoscaling, set viewLim</span>
        <span class="c1"># to tightly fit the image, regardless of dataLim.</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_extent</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_extent</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pcolorargs</span><span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># This takes one kwarg, allmatch.</span>
        <span class="c1"># If allmatch is True, then the incoming X, Y, C must</span>
        <span class="c1"># have matching dimensions, taking into account that</span>
        <span class="c1"># X and Y can be 1-D rather than 2-D.  This perfect</span>
        <span class="c1"># match is required for Gouroud shading.  For flat</span>
        <span class="c1"># shading, X and Y specify boundaries, so we need</span>
        <span class="c1"># one more boundary than color in each direction.</span>
        <span class="c1"># For convenience, and consistent with Matlab, we</span>
        <span class="c1"># discard the last row and/or column of C if necessary</span>
        <span class="c1"># to meet this condition.  This is done if allmatch</span>
        <span class="c1"># is False.</span>

        <span class="n">allmatch</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"allmatch"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">allmatch</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numCols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numRows</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numCols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numRows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Check x and y for bad data...</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">funcname</span> <span class="o">==</span> <span class="s1">'pcolormesh'</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">'x and y arguments to pcolormesh cannot have '</span>
                        <span class="s1">'non-finite values or be of type '</span>
                        <span class="s1">'numpy.ma.core.MaskedArray with masked values'</span><span class="p">)</span>
                <span class="c1"># safe_masked_invalid() returns an ndarray for dtypes other</span>
                <span class="c1"># than floating point.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># strip mask as downstream doesn't like it...</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">data</span>
            <span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">'Illegal arguments to </span><span class="si">%s</span><span class="s1">; see help(</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>

        <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">'Incompatible X, Y inputs to </span><span class="si">%s</span><span class="s1">; see help(</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">funcname</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">allmatch</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">==</span> <span class="n">numCols</span> <span class="ow">and</span> <span class="n">Ny</span> <span class="o">==</span> <span class="n">numRows</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'Dimensions of C </span><span class="si">%s</span><span class="s1"> are incompatible with'</span>
                                <span class="s1">' X (</span><span class="si">%d</span><span class="s1">) and/or Y (</span><span class="si">%d</span><span class="s1">); see help(</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">numCols</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">numRows</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'Dimensions of C </span><span class="si">%s</span><span class="s1"> are incompatible with'</span>
                                <span class="s1">' X (</span><span class="si">%d</span><span class="s1">) and/or Y (</span><span class="si">%d</span><span class="s1">); see help(</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span>

<div class="viewcode-block" id="Axes.pcolor"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.pcolor.html#matplotlib.axes.Axes.pcolor">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a pseudocolor plot of a 2-D array.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            pcolor(C, **kwargs)</span>
<span class="sd">            pcolor(X, Y, C, **kwargs)</span>

<span class="sd">        pcolor can be very slow for large arrays; consider</span>
<span class="sd">        using the similar but much faster</span>
<span class="sd">        :func:`~matplotlib.pyplot.pcolormesh` instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C : array_like</span>
<span class="sd">            An array of color values.</span>

<span class="sd">        X, Y : array_like, optional</span>
<span class="sd">            If given, specify the (x, y) coordinates of the colored</span>
<span class="sd">            quadrilaterals; the quadrilateral for ``C[i,j]`` has corners at::</span>

<span class="sd">                (X[i,   j],   Y[i,   j]),</span>
<span class="sd">                (X[i,   j+1], Y[i,   j+1]),</span>
<span class="sd">                (X[i+1, j],   Y[i+1, j]),</span>
<span class="sd">                (X[i+1, j+1], Y[i+1, j+1])</span>

<span class="sd">            Ideally the dimensions of ``X`` and ``Y`` should be one greater</span>
<span class="sd">            than those of ``C``; if the dimensions are the same, then the last</span>
<span class="sd">            row and column of ``C`` will be ignored.</span>

<span class="sd">            Note that the column index corresponds to the</span>
<span class="sd">            x-coordinate, and the row index corresponds to y; for</span>
<span class="sd">            details, see the :ref:`Grid Orientation</span>
<span class="sd">            &lt;axes-pcolor-grid-orientation&gt;` section below.</span>

<span class="sd">            If either or both of ``X`` and ``Y`` are 1-D arrays or column</span>
<span class="sd">            vectors, they will be expanded as needed into the appropriate 2-D</span>
<span class="sd">            arrays, making a rectangular grid.</span>

<span class="sd">        cmap : `~matplotlib.colors.Colormap`, optional, default: None</span>
<span class="sd">            If `None`, default to rc settings.</span>

<span class="sd">        norm : `matplotlib.colors.Normalize`, optional, default: None</span>
<span class="sd">            An instance is used to scale luminance data to (0, 1).</span>
<span class="sd">            If `None`, defaults to :func:`normalize`.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            ``vmin`` and ``vmax`` are used in conjunction with ``norm`` to</span>
<span class="sd">            normalize luminance data.  If either is `None`, it is autoscaled to</span>
<span class="sd">            the respective min or max of the color array ``C``.  If not `None`,</span>
<span class="sd">            ``vmin`` or ``vmax`` passed in here override any pre-existing</span>
<span class="sd">            values supplied in the ``norm`` instance.</span>

<span class="sd">        edgecolors : {None, 'none', color, color sequence}</span>
<span class="sd">            If None, the rc setting is used by default.</span>
<span class="sd">            If 'none', edges will not be visible.</span>
<span class="sd">            An mpl color or sequence of colors will set the edge color.</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        snap : bool, optional, default: False</span>
<span class="sd">            Whether to snap the mesh to pixel boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        collection : `matplotlib.collections.Collection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        antialiaseds : bool, optional, default: False</span>
<span class="sd">            The default ``antialiaseds`` is False if the default</span>
<span class="sd">            ``edgecolors="none"`` is used.  This eliminates artificial lines</span>
<span class="sd">            at patch boundaries, and works regardless of the value of alpha.</span>
<span class="sd">            If ``edgecolors`` is not "none", then the default ``antialiaseds``</span>
<span class="sd">            is taken from :rc:`patch.antialiased`, which defaults to True.</span>
<span class="sd">            Stroking the edges may be preferred if ``alpha`` is 1, but will</span>
<span class="sd">            cause artifacts otherwise.</span>

<span class="sd">        **kwargs :</span>

<span class="sd">            Any unused keyword arguments are passed along to the</span>
<span class="sd">            `~matplotlib.collections.PolyCollection` constructor:</span>

<span class="sd">        %(PolyCollection)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pcolormesh : for an explanation of the differences between</span>
<span class="sd">            pcolor and pcolormesh.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. _axes-pcolor-grid-orientation:</span>

<span class="sd">        ``X``, ``Y`` and ``C`` may be masked arrays. If either C[i, j], or one</span>
<span class="sd">        of the vertices surrounding C[i,j] (``X`` or ``Y`` at [i, j], [i+1, j],</span>
<span class="sd">        [i, j+1], [i+1, j+1]) is masked, nothing is plotted.</span>

<span class="sd">        The grid orientation follows the MATLAB convention: an array ``C`` with</span>
<span class="sd">        shape (nrows, ncolumns) is plotted with the column number as ``X`` and</span>
<span class="sd">        the row number as ``Y``, increasing up; hence it is plotted the way the</span>
<span class="sd">        array would be printed, except that the ``Y`` axis is reversed. That</span>
<span class="sd">        is, ``C`` is taken as ``C`` (y, x).</span>

<span class="sd">        Similarly for :func:`meshgrid`::</span>

<span class="sd">            x = np.arange(5)</span>
<span class="sd">            y = np.arange(3)</span>
<span class="sd">            X, Y = np.meshgrid(x, y)</span>

<span class="sd">        is equivalent to::</span>

<span class="sd">            X = array([[0, 1, 2, 3, 4],</span>
<span class="sd">                       [0, 1, 2, 3, 4],</span>
<span class="sd">                       [0, 1, 2, 3, 4]])</span>

<span class="sd">            Y = array([[0, 0, 0, 0, 0],</span>
<span class="sd">                       [1, 1, 1, 1, 1],</span>
<span class="sd">                       [2, 2, 2, 2, 2]])</span>

<span class="sd">        so if you have::</span>

<span class="sd">            C = rand(len(x), len(y))</span>

<span class="sd">        then you need to transpose C::</span>

<span class="sd">            pcolor(X, Y, C.T)</span>

<span class="sd">        or::</span>

<span class="sd">            pcolor(C.T)</span>

<span class="sd">        MATLAB :func:`pcolor` always discards the last row and column of ``C``,</span>
<span class="sd">        but Matplotlib displays the last row and column if ``X`` and ``Y`` are</span>
<span class="sd">        not specified, or if ``X`` and ``Y`` have one more row and column than</span>
<span class="sd">        ``C``.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'alpha'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'norm'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'cmap'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'vmin'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'vmax'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcolorargs</span><span class="p">(</span><span class="s1">'pcolor'</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allmatch</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># unit conversion allows e.g. datetime objects as axis values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="c1"># convert to MA, if necessary.</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">xymask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span>
                  <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># don't plot if C or any of the surrounding vertices are masked.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">+</span> <span class="n">xymask</span>

        <span class="n">newaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
        <span class="n">compress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span>

        <span class="n">ravelmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">X1</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">Y1</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">X2</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">Y2</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">X3</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">Y3</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">X4</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">Y4</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">npoly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X1</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">X2</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y2</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">X3</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y3</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">X4</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y4</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">X1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">]),</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">npoly</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,)</span>
        <span class="k">if</span> <span class="s1">'linewidth'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'linewidths'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'linewidth'</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'linewidths'</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">'edgecolor'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'edgecolors'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'edgecolor'</span><span class="p">)</span>
        <span class="n">ec</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'edgecolors'</span><span class="p">,</span> <span class="s1">'none'</span><span class="p">)</span>

        <span class="c1"># aa setting will default via collections to patch.antialiased</span>
        <span class="c1"># unless the boundary is not stroked, in which case the</span>
        <span class="c1"># default will be False; with unstroked boundaries, aa</span>
        <span class="c1"># makes artifacts that are often disturbing.</span>
        <span class="k">if</span> <span class="s1">'antialiased'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'antialiaseds'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'antialiased'</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">'antialiaseds'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ec</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"none"</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'antialiaseds'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'snap'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"'norm' must be an instance of 'mcolors.Normalize'"</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>

        <span class="c1"># Transform from native to data coordinates?</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">_transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">'_as_mpl_transform'</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">)):</span>
            <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">minx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">]</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">]</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.pcolormesh"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.pcolormesh.html#matplotlib.axes.Axes.pcolormesh">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolormesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot a quadrilateral mesh.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">          pcolormesh(C)</span>
<span class="sd">          pcolormesh(X, Y, C)</span>
<span class="sd">          pcolormesh(C, **kwargs)</span>

<span class="sd">        Create a pseudocolor plot of a 2-D array.</span>

<span class="sd">        pcolormesh is similar to :func:`~matplotlib.pyplot.pcolor`,</span>
<span class="sd">        but uses a different mechanism and returns a different</span>
<span class="sd">        object; pcolor returns a</span>
<span class="sd">        :class:`~matplotlib.collections.PolyCollection` but pcolormesh</span>
<span class="sd">        returns a</span>
<span class="sd">        :class:`~matplotlib.collections.QuadMesh`.  It is much faster,</span>
<span class="sd">        so it is almost always preferred for large arrays.</span>

<span class="sd">        *C* may be a masked array, but *X* and *Y* may not.  Masked</span>
<span class="sd">        array support is implemented via *cmap* and *norm*; in</span>
<span class="sd">        contrast, :func:`~matplotlib.pyplot.pcolor` simply does not</span>
<span class="sd">        draw quadrilaterals with masked colors or vertices.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        cmap : Colormap, optional</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance. If ``None``, use</span>
<span class="sd">            rc settings.</span>

<span class="sd">        norm : Normalize, optional</span>
<span class="sd">            A :class:`matplotlib.colors.Normalize` instance is used to</span>
<span class="sd">            scale luminance data to 0,1. If ``None``, defaults to</span>
<span class="sd">            :func:`normalize`.</span>

<span class="sd">        vmin, vmax : scalar, optional</span>
<span class="sd">            *vmin* and *vmax* are used in conjunction with *norm* to</span>
<span class="sd">            normalize luminance data. If either is ``None``, it is autoscaled</span>
<span class="sd">            to the respective min or max of the color array *C*.</span>
<span class="sd">            If not ``None``, *vmin* or *vmax* passed in here override any</span>
<span class="sd">            pre-existing values supplied in the *norm* instance.</span>

<span class="sd">        shading : [ 'flat' | 'gouraud' ], optional</span>
<span class="sd">            'flat' indicates a solid color for each quad. When</span>
<span class="sd">            'gouraud', each quad will be Gouraud shaded. When gouraud</span>
<span class="sd">            shading, *edgecolors* is ignored.</span>

<span class="sd">        edgecolors : string, color, color sequence, optional</span>
<span class="sd">            - If ``None``, the rc setting is used by default.</span>
<span class="sd">            - If ``'None'``, edges will not be visible.</span>
<span class="sd">            - If ``'face'``, edges will have the same color as the faces.</span>

<span class="sd">            An mpl color or sequence of colors will also set the edge color.</span>

<span class="sd">        alpha : scalar, optional</span>
<span class="sd">            Alpha blending value. Must be between 0 and 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.collections.QuadMesh</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        matplotlib.pyplot.pcolor :</span>
<span class="sd">            For an explanation of the grid orientation</span>
<span class="sd">            (:ref:`Grid Orientation &lt;axes-pcolor-grid-orientation&gt;`)</span>
<span class="sd">            and the expansion of 1-D *X* and/or *Y* to 2-D arrays.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        kwargs can be used to control the</span>
<span class="sd">        :class:`matplotlib.collections.QuadMesh` properties:</span>

<span class="sd">        %(QuadMesh)s</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'alpha'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'norm'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'cmap'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'vmin'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'vmax'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">shading</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'shading'</span><span class="p">,</span> <span class="s1">'flat'</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">antialiased</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'antialiased'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'edgecolors'</span><span class="p">,</span> <span class="s1">'None'</span><span class="p">)</span>

        <span class="n">allmatch</span> <span class="o">=</span> <span class="p">(</span><span class="n">shading</span> <span class="o">==</span> <span class="s1">'gouraud'</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcolorargs</span><span class="p">(</span><span class="s1">'pcolormesh'</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allmatch</span><span class="o">=</span><span class="n">allmatch</span><span class="p">)</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># unit conversion allows e.g. datetime objects as axis values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="c1"># convert to one dimensional arrays</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">QuadMesh</span><span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span>
                                    <span class="n">antialiased</span><span class="o">=</span><span class="n">antialiased</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="n">shading</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"'norm' must be an instance of 'mcolors.Normalize'"</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Transform from native to data coordinates?</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">_transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">'_as_mpl_transform'</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">)):</span>
            <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">]</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">]</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.pcolorfast"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.pcolorfast.html#matplotlib.axes.Axes.pcolorfast">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolorfast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        pseudocolor plot of a 2-D array</span>

<span class="sd">        Experimental; this is a pcolor-type method that</span>
<span class="sd">        provides the fastest possible rendering with the Agg</span>
<span class="sd">        backend, and that can handle any quadrilateral grid.</span>
<span class="sd">        It supports only flat shading (no outlines), it lacks</span>
<span class="sd">        support for log scaling of the axes, and it does not</span>
<span class="sd">        have a pyplot wrapper.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">          ax.pcolorfast(C, **kwargs)</span>
<span class="sd">          ax.pcolorfast(xr, yr, C, **kwargs)</span>
<span class="sd">          ax.pcolorfast(x, y, C, **kwargs)</span>
<span class="sd">          ax.pcolorfast(X, Y, C, **kwargs)</span>

<span class="sd">        C is the 2D array of color values corresponding to quadrilateral</span>
<span class="sd">        cells. Let (nr, nc) be its shape.  C may be a masked array.</span>

<span class="sd">        ``ax.pcolorfast(C, **kwargs)`` is equivalent to</span>
<span class="sd">        ``ax.pcolorfast([0,nc], [0,nr], C, **kwargs)``</span>

<span class="sd">        *xr*, *yr* specify the ranges of *x* and *y* corresponding to the</span>
<span class="sd">        rectangular region bounding *C*.  If::</span>

<span class="sd">            xr = [x0, x1]</span>

<span class="sd">        and::</span>

<span class="sd">            yr = [y0,y1]</span>

<span class="sd">        then *x* goes from *x0* to *x1* as the second index of *C* goes</span>
<span class="sd">        from 0 to *nc*, etc.  (*x0*, *y0*) is the outermost corner of</span>
<span class="sd">        cell (0,0), and (*x1*, *y1*) is the outermost corner of cell</span>
<span class="sd">        (*nr*-1, *nc*-1).  All cells are rectangles of the same size.</span>
<span class="sd">        This is the fastest version.</span>

<span class="sd">        *x*, *y* are monotonic 1D arrays of length *nc* +1 and *nr* +1,</span>
<span class="sd">        respectively, giving the x and y boundaries of the cells.  Hence</span>
<span class="sd">        the cells are rectangular but the grid may be nonuniform.  The</span>
<span class="sd">        speed is intermediate.  (The grid is checked, and if found to be</span>
<span class="sd">        uniform the fast version is used.)</span>

<span class="sd">        *X* and *Y* are 2D arrays with shape (*nr* +1, *nc* +1) that specify</span>
<span class="sd">        the (x,y) coordinates of the corners of the colored</span>
<span class="sd">        quadrilaterals; the quadrilateral for C[i,j] has corners at</span>
<span class="sd">        (X[i,j],Y[i,j]), (X[i,j+1],Y[i,j+1]), (X[i+1,j],Y[i+1,j]),</span>
<span class="sd">        (X[i+1,j+1],Y[i+1,j+1]).  The cells need not be rectangular.</span>
<span class="sd">        This is the most general, but the slowest to render.  It may</span>
<span class="sd">        produce faster and more compact output using ps, pdf, and</span>
<span class="sd">        svg backends, however.</span>

<span class="sd">        Note that the column index corresponds to the x-coordinate,</span>
<span class="sd">        and the row index corresponds to y; for details, see</span>
<span class="sd">        :ref:`Grid Orientation &lt;axes-pcolor-grid-orientation&gt;`.</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">          *cmap*: [ *None* | Colormap ]</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance from cm. If *None*,</span>
<span class="sd">            use rc settings.</span>

<span class="sd">          *norm*: [ *None* | Normalize ]</span>
<span class="sd">            A :class:`matplotlib.colors.Normalize` instance is used to scale</span>
<span class="sd">            luminance data to 0,1. If *None*, defaults to normalize()</span>

<span class="sd">          *vmin*/*vmax*: [ *None* | scalar ]</span>
<span class="sd">            *vmin* and *vmax* are used in conjunction with norm to normalize</span>
<span class="sd">            luminance data.  If either are *None*, the min and max</span>
<span class="sd">            of the color array *C* is used.  If you pass a norm instance,</span>
<span class="sd">            *vmin* and *vmax* will be *None*.</span>

<span class="sd">          *alpha*: ``0 &lt;= scalar &lt;= 1``  or *None*</span>
<span class="sd">            the alpha blending value</span>

<span class="sd">        Return value is an image if a regular or rectangular grid</span>
<span class="sd">        is specified, and a :class:`~matplotlib.collections.QuadMesh`</span>
<span class="sd">        collection in the general quadrilateral case.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'alpha'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'norm'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'cmap'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'vmin'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'vmax'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"'norm' must be an instance of 'mcolors.Normalize'"</span><span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">style</span> <span class="o">=</span> <span class="s2">"image"</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">style</span> <span class="o">=</span> <span class="s2">"image"</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="ow">and</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="o">.</span><span class="n">mean</span><span class="p">())):</span>
                        <span class="n">style</span> <span class="o">=</span> <span class="s2">"image"</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">style</span> <span class="o">=</span> <span class="s2">"pcolorimage"</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">style</span> <span class="o">=</span> <span class="s2">"quadmesh"</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"arguments do not match valid signatures"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"need 1 argument or 3 arguments"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">"quadmesh"</span><span class="p">:</span>

            <span class="c1"># convert to one dimensional arrays</span>
            <span class="c1"># This should also be moved to the QuadMesh class</span>

            <span class="c1"># data point in each cell is value at lower left corner</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">Nx</span> <span class="o">=</span> <span class="n">nc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">Ny</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># The following needs to be cleaned up; the renderer</span>
            <span class="c1"># requires separate contiguous arrays for X and Y,</span>
            <span class="c1"># but the QuadMesh class requires the 2D array.</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="n">Nx</span> <span class="o">*</span> <span class="n">Ny</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y</span>

            <span class="c1"># The QuadMesh class can also be changed to</span>
            <span class="c1"># handle relevant superclass kwargs; the initializer</span>
            <span class="c1"># should do much more than it does now.</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">QuadMesh</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">"None"</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">collection</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># It's one of the two image styles.</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">"image"</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">AxesImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span>
                                      <span class="n">interpolation</span><span class="o">=</span><span class="s1">'nearest'</span><span class="p">,</span>
                                      <span class="n">origin</span><span class="o">=</span><span class="s1">'lower'</span><span class="p">,</span>
                                      <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span><span class="p">),</span>
                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
                <span class="n">im</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">"pcolorimage"</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">PcolorImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span>
                                        <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                                        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">im</span><span class="o">.</span><span class="n">set_extent</span><span class="p">((</span><span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">im</span>

        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">]</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">yb</span><span class="p">,</span> <span class="n">yt</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xl</span><span class="p">,</span> <span class="n">yb</span><span class="p">],</span> <span class="p">[</span><span class="n">xr</span><span class="p">,</span> <span class="n">yt</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Axes.contour"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.contour.html#matplotlib.axes.Axes.contour">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'filled'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contours</span></div>
    <span class="n">contour</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="o">.</span><span class="n">_contour_doc</span>

<div class="viewcode-block" id="Axes.contourf"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.contourf.html#matplotlib.axes.Axes.contourf">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">contourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'filled'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contours</span></div>
    <span class="n">contourf</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="o">.</span><span class="n">_contour_doc</span>

<div class="viewcode-block" id="Axes.clabel"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.clabel.html#matplotlib.axes.Axes.clabel">[docs]</a>    <span class="k">def</span> <span class="nf">clabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CS</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CS</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">clabel</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">ContourSet</span><span class="o">.</span><span class="n">clabel</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Axes.table"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.table.html#matplotlib.axes.Axes.table">[docs]</a>    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a table to the current axes.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          table(cellText=None, cellColours=None,</span>
<span class="sd">                cellLoc='right', colWidths=None,</span>
<span class="sd">                rowLabels=None, rowColours=None, rowLoc='left',</span>
<span class="sd">                colLabels=None, colColours=None, colLoc='center',</span>
<span class="sd">                loc='bottom', bbox=None)</span>

<span class="sd">        Returns a :class:`matplotlib.table.Table` instance. Either `cellText`</span>
<span class="sd">        or `cellColours` must be provided. For finer grained control over</span>
<span class="sd">        tables, use the :class:`~matplotlib.table.Table` class and add it to</span>
<span class="sd">        the axes with :meth:`~matplotlib.axes.Axes.add_table`.</span>

<span class="sd">        Thanks to John Gill for providing the class and table.</span>

<span class="sd">        kwargs control the :class:`~matplotlib.table.Table`</span>
<span class="sd">        properties:</span>

<span class="sd">        %(Table)s</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">mtable</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">#### Data analysis</span>

<div class="viewcode-block" id="Axes.hist"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.hist.html#matplotlib.axes.Axes.hist">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s1">'weights'</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">"x"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">'mid'</span><span class="p">,</span>
             <span class="n">orientation</span><span class="o">=</span><span class="s1">'vertical'</span><span class="p">,</span> <span class="n">rwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stacked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot a histogram.</span>

<span class="sd">        Compute and draw the histogram of *x*. The return value is a</span>
<span class="sd">        tuple (*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*,</span>
<span class="sd">        [*patches0*, *patches1*,...]) if the input contains multiple</span>
<span class="sd">        data.</span>

<span class="sd">        Multiple data can be provided via *x* as a list of datasets</span>
<span class="sd">        of potentially different length ([*x0*, *x1*, ...]), or as</span>
<span class="sd">        a 2-D ndarray in which each column is a dataset.  Note that</span>
<span class="sd">        the ndarray form is transposed relative to the list form.</span>

<span class="sd">        Masked arrays are not supported at present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : (n,) array or sequence of (n,) arrays</span>
<span class="sd">            Input values, this takes either a single array or a sequence of</span>
<span class="sd">            arrays which are not required to be of the same length</span>

<span class="sd">        bins : integer or sequence or 'auto', optional</span>
<span class="sd">            If an integer is given, ``bins + 1`` bin edges are calculated and</span>
<span class="sd">            returned, consistent with :func:`numpy.histogram`.</span>

<span class="sd">            If `bins` is a sequence, gives bin edges, including left edge of</span>
<span class="sd">            first bin and right edge of last bin.  In this case, `bins` is</span>
<span class="sd">            returned unmodified.</span>

<span class="sd">            All but the last (righthand-most) bin is half-open.  In other</span>
<span class="sd">            words, if `bins` is::</span>

<span class="sd">                [1, 2, 3, 4]</span>

<span class="sd">            then the first bin is ``[1, 2)`` (including 1, but excluding 2) and</span>
<span class="sd">            the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which</span>
<span class="sd">            *includes* 4.</span>

<span class="sd">            Unequally spaced bins are supported if *bins* is a sequence.</span>

<span class="sd">            If Numpy 1.11 is installed, may also be ``'auto'``.</span>

<span class="sd">            Default is taken from the rcParam ``hist.bins``.</span>

<span class="sd">        range : tuple or None, optional</span>
<span class="sd">            The lower and upper range of the bins. Lower and upper outliers</span>
<span class="sd">            are ignored. If not provided, *range* is ``(x.min(), x.max())``.</span>
<span class="sd">            Range has no effect if *bins* is a sequence.</span>

<span class="sd">            If *bins* is a sequence or *range* is specified, autoscaling</span>
<span class="sd">            is based on the specified bin range instead of the</span>
<span class="sd">            range of x.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        density : boolean, optional</span>
<span class="sd">            If ``True``, the first element of the return tuple will</span>
<span class="sd">            be the counts normalized to form a probability density, i.e.,</span>
<span class="sd">            the area (or integral) under the histogram will sum to 1.</span>
<span class="sd">            This is achieved by dividing the count by the number of</span>
<span class="sd">            observations times the bin width and not dividing by the total</span>
<span class="sd">            number of observations. If *stacked* is also ``True``, the sum of</span>
<span class="sd">            the histograms is normalized to 1.</span>

<span class="sd">            Default is ``None`` for both *normed* and *density*. If either is</span>
<span class="sd">            set, then that value will be used. If neither are set, then the</span>
<span class="sd">            args will be treated as ``False``.</span>

<span class="sd">            If both *density* and *normed* are set an error is raised.</span>

<span class="sd">        weights : (n, ) array_like or None, optional</span>
<span class="sd">            An array of weights, of the same shape as *x*.  Each value in *x*</span>
<span class="sd">            only contributes its associated weight towards the bin count</span>
<span class="sd">            (instead of 1).  If *normed* or *density* is ``True``,</span>
<span class="sd">            the weights are normalized, so that the integral of the density</span>
<span class="sd">            over the range remains 1.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        cumulative : boolean, optional</span>
<span class="sd">            If ``True``, then a histogram is computed where each bin gives the</span>
<span class="sd">            counts in that bin plus all bins for smaller values. The last bin</span>
<span class="sd">            gives the total number of datapoints. If *normed* or *density*</span>
<span class="sd">            is also ``True`` then the histogram is normalized such that the</span>
<span class="sd">            last bin equals 1. If *cumulative* evaluates to less than 0</span>
<span class="sd">            (e.g., -1), the direction of accumulation is reversed.</span>
<span class="sd">            In this case, if *normed* and/or *density* is also ``True``, then</span>
<span class="sd">            the histogram is normalized such that the first bin equals 1.</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        bottom : array_like, scalar, or None</span>
<span class="sd">            Location of the bottom baseline of each bin.  If a scalar,</span>
<span class="sd">            the base line for each bin is shifted by the same amount.</span>
<span class="sd">            If an array, each bin is shifted independently and the length</span>
<span class="sd">            of bottom must match the number of bins.  If None, defaults to 0.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        histtype : {'bar', 'barstacked', 'step',  'stepfilled'}, optional</span>
<span class="sd">            The type of histogram to draw.</span>

<span class="sd">            - 'bar' is a traditional bar-type histogram.  If multiple data</span>
<span class="sd">              are given the bars are arranged side by side.</span>

<span class="sd">            - 'barstacked' is a bar-type histogram where multiple</span>
<span class="sd">              data are stacked on top of each other.</span>

<span class="sd">            - 'step' generates a lineplot that is by default</span>
<span class="sd">              unfilled.</span>

<span class="sd">            - 'stepfilled' generates a lineplot that is by default</span>
<span class="sd">              filled.</span>

<span class="sd">            Default is 'bar'</span>

<span class="sd">        align : {'left', 'mid', 'right'}, optional</span>
<span class="sd">            Controls how the histogram is plotted.</span>

<span class="sd">                - 'left': bars are centered on the left bin edges.</span>

<span class="sd">                - 'mid': bars are centered between the bin edges.</span>

<span class="sd">                - 'right': bars are centered on the right bin edges.</span>

<span class="sd">            Default is 'mid'</span>

<span class="sd">        orientation : {'horizontal', 'vertical'}, optional</span>
<span class="sd">            If 'horizontal', `~matplotlib.pyplot.barh` will be used for</span>
<span class="sd">            bar-type histograms and the *bottom* kwarg will be the left edges.</span>

<span class="sd">        rwidth : scalar or None, optional</span>
<span class="sd">            The relative width of the bars as a fraction of the bin width.  If</span>
<span class="sd">            ``None``, automatically compute the width.</span>

<span class="sd">            Ignored if *histtype* is 'step' or 'stepfilled'.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        log : boolean, optional</span>
<span class="sd">            If ``True``, the histogram axis will be set to a log scale. If</span>
<span class="sd">            *log* is ``True`` and *x* is a 1D array, empty bins will be</span>
<span class="sd">            filtered out and only the non-empty ``(n, bins, patches)``</span>
<span class="sd">            will be returned.</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        color : color or array_like of colors or None, optional</span>
<span class="sd">            Color spec or sequence of color specs, one per dataset.  Default</span>
<span class="sd">            (``None``) uses the standard line color sequence.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        label : string or None, optional</span>
<span class="sd">            String, or sequence of strings to match multiple datasets.  Bar</span>
<span class="sd">            charts yield multiple patches per dataset, but only the first gets</span>
<span class="sd">            the label, so that the legend command will work as expected.</span>

<span class="sd">            default is ``None``</span>

<span class="sd">        stacked : boolean, optional</span>
<span class="sd">            If ``True``, multiple data are stacked on top of each other If</span>
<span class="sd">            ``False`` multiple data are arranged side by side if histtype is</span>
<span class="sd">            'bar' or on top of each other if histtype is 'step'</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        normed : bool, optional</span>
<span class="sd">            Deprecated; use the density keyword argument instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : array or list of arrays</span>
<span class="sd">            The values of the histogram bins. See *normed* or *density*</span>
<span class="sd">            and *weights* for a description of the possible semantics.</span>
<span class="sd">            If input *x* is an array, then this is an array of length</span>
<span class="sd">            *nbins*. If input is a sequence arrays</span>
<span class="sd">            ``[data1, data2,..]``, then this is a list of arrays with</span>
<span class="sd">            the values of the histograms for each of the arrays in the</span>
<span class="sd">            same order.</span>

<span class="sd">        bins : array</span>
<span class="sd">            The edges of the bins. Length nbins + 1 (nbins left edges and right</span>
<span class="sd">            edge of last bin).  Always a single array even when multiple data</span>
<span class="sd">            sets are passed in.</span>

<span class="sd">        patches : list or list of lists</span>
<span class="sd">            Silent list of individual patches used to create the histogram</span>
<span class="sd">            or list of such list if multiple input datasets.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.patches.Patch` properties</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hist2d : 2D histograms</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [Notes section required for data comment. See #10189.]</span>

<span class="sd">        """</span>
        <span class="c1"># Avoid shadowing the builtin.</span>
        <span class="n">bin_range</span> <span class="o">=</span> <span class="nb">range</span>
        <span class="k">del</span> <span class="nb">range</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'hist.bins'</span><span class="p">]</span>

        <span class="c1"># Validate string inputs here so we don't have to clutter</span>
        <span class="c1"># subsequent code.</span>
        <span class="k">if</span> <span class="n">histtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'bar'</span><span class="p">,</span> <span class="s1">'barstacked'</span><span class="p">,</span> <span class="s1">'step'</span><span class="p">,</span> <span class="s1">'stepfilled'</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"histtype </span><span class="si">%s</span><span class="s2"> is not recognized"</span> <span class="o">%</span> <span class="n">histtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">align</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'left'</span><span class="p">,</span> <span class="s1">'mid'</span><span class="p">,</span> <span class="s1">'right'</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"align kwarg </span><span class="si">%s</span><span class="s2"> is not recognized"</span> <span class="o">%</span> <span class="n">align</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'horizontal'</span><span class="p">,</span> <span class="s1">'vertical'</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"orientation kwarg </span><span class="si">%s</span><span class="s2"> is not recognized"</span> <span class="o">%</span> <span class="n">orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">'barstacked'</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">stacked</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">density</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">normed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"kwargs 'density' and 'normed' cannot be used "</span>
                             <span class="s2">"simultaneously. "</span>
                             <span class="s2">"Please only use 'density', since 'normed'"</span>
                             <span class="s2">"is deprecated."</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"The 'normed' kwarg is deprecated, and has been "</span>
                          <span class="s2">"replaced by the 'density' kwarg."</span><span class="p">)</span>

        <span class="c1"># basic input validation</span>
        <span class="n">input_empty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1"># Massage 'x' for processing.</span>
        <span class="k">if</span> <span class="n">input_empty</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_reshape_2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># number of datasets</span>

        <span class="c1"># Process unit information</span>
        <span class="c1"># Unit conversion is done individually on each dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bin_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">bin_range</span><span class="p">)</span>

        <span class="c1"># Check whether bins or range are given explicitly.</span>
        <span class="n">binsgiven</span> <span class="o">=</span> <span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="ow">or</span> <span class="n">bin_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># We need to do to 'weights' what was done to 'x'</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_reshape_2D</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="s1">'weights'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nx</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'weights should have the same shape as x'</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">wi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">'weights should have the same shape as x'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nx</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"color kwarg must have one color per dataset"</span><span class="p">)</span>

        <span class="c1"># If bins are not specified either explicitly or via range,</span>
        <span class="c1"># we need to figure out the range required for all datasets,</span>
        <span class="c1"># and supply that to np.histogram.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">binsgiven</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">input_empty</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xi</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
                    <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">xi</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">bin_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
        <span class="n">density</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">density</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">(</span><span class="n">normed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">density</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">hist_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="n">bin_range</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hist_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="n">bin_range</span><span class="p">)</span>

        <span class="c1"># List to store all the top coordinates of the histograms</span>
        <span class="n">tops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mlast</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Loop through datasets</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="c1"># this will automatically overwrite bins,</span>
            <span class="c1"># so that each histogram uses the same bins</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">hist_kwargs</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># causes problems later if it's an int</span>
            <span class="k">if</span> <span class="n">mlast</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mlast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="n">mlast</span>
                <span class="n">mlast</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># If a stacked density plot, normalize so the area of all the stacked</span>
        <span class="c1"># histograms together is 1</span>
        <span class="k">if</span> <span class="n">stacked</span> <span class="ow">and</span> <span class="n">density</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">db</span><span class="p">)</span> <span class="o">/</span> <span class="n">tops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">cumulative</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cumulative</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
                <span class="n">tops</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">))[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()[</span><span class="n">slc</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tops</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()[</span><span class="n">slc</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">]</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Save autoscale state for later restoration; turn autoscaling</span>
        <span class="c1"># off so we can do it all a single time at the end, instead</span>
        <span class="c1"># of having it done by bar or fill and then having to be redone.</span>
        <span class="n">_saved_autoscalex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_autoscalex_on</span><span class="p">()</span>
        <span class="n">_saved_autoscaley</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_autoscaley_on</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscalex_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscaley_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">):</span>

            <span class="n">totwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">rwidth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                  <span class="p">((</span><span class="ow">not</span> <span class="n">stacked</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">])):</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">0.8</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="k">if</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">'bar'</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span> <span class="o">/</span> <span class="n">nx</span>
                <span class="n">dw</span> <span class="o">=</span> <span class="n">width</span>
                <span class="n">boffset</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nx</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">'barstacked'</span> <span class="ow">or</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span>
                <span class="n">boffset</span><span class="p">,</span> <span class="n">dw</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">'mid'</span> <span class="ow">or</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">'edge'</span><span class="p">:</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">totwidth</span>
            <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">'right'</span><span class="p">:</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="n">totwidth</span>

            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
                <span class="n">_barfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">barh</span>
                <span class="n">bottom_kwarg</span> <span class="o">=</span> <span class="s1">'left'</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># orientation == 'vertical'</span>
                <span class="n">_barfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span>
                <span class="n">bottom_kwarg</span> <span class="o">=</span> <span class="s1">'bottom'</span>

            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tops</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">bottom</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">_barfunc</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">boffset</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span>
                                 <span class="n">align</span><span class="o">=</span><span class="s1">'center'</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                                 <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">bottom_kwarg</span><span class="p">:</span> <span class="n">bottom</span><span class="p">})</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="n">bottom</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="n">dw</span>

        <span class="k">elif</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'step'</span><span class="p">):</span>
            <span class="c1"># these define the perimeter of the polygon</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bins</span><span class="p">,</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="n">nonposx</span><span class="o">=</span><span class="s1">'clip'</span><span class="p">)</span>
                    <span class="n">logbase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">base</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># orientation == 'vertical'</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="n">nonposy</span><span class="o">=</span><span class="s1">'clip'</span><span class="p">)</span>
                    <span class="n">logbase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">base</span>

                <span class="c1"># Setting a minimum of 0 results in problems for log plots</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">density</span> <span class="ow">or</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># For data that is normed to form a probability density,</span>
                    <span class="c1"># set to minimum data value / logbase</span>
                    <span class="c1"># (gives 1 full tick-label unit for the lowest filled bin)</span>
                    <span class="n">ndata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ndata</span><span class="p">[</span><span class="n">ndata</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="n">logbase</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For non-normed (density = False) data,</span>
                    <span class="c1"># set the min to 1 / log base,</span>
                    <span class="c1"># again so that there is 1 full tick-label unit</span>
                    <span class="c1"># for the lowest bin</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">logbase</span>

                <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">minimum</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">'left'</span> <span class="ow">or</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">'center'</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">-=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">'right'</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># If fill kwarg is set, it will be passed to the patch collection,</span>
            <span class="c1"># overriding this</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="p">(</span><span class="n">histtype</span> <span class="o">==</span> <span class="s1">'stepfilled'</span><span class="p">)</span>

            <span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="c1"># starting point for drawing polygon</span>
                    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># top of the previous polygon becomes the bottom</span>
                    <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># set the top of this polygon</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">,</span>
                                                            <span class="n">m</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                    <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="c1"># stepfill is closed, step is not</span>
            <span class="n">split</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="c1"># add patches in reverse order so that when stacking,</span>
            <span class="c1"># items lower in the stack are plotted on top of</span>
            <span class="c1"># items higher in the stack</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">color</span><span class="p">))):</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span>
                    <span class="n">closed</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                    <span class="n">edgecolor</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="n">c</span><span class="p">,</span>
                    <span class="n">fill</span><span class="o">=</span><span class="n">fill</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">patch_list</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">patch_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'vertical'</span><span class="p">:</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minimum</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">'horizontal'</span><span class="p">:</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minimum</span><span class="p">)</span>

            <span class="c1"># we return patches, so put it back in the expected order</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscalex_on</span><span class="p">(</span><span class="n">_saved_autoscalex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscaley_on</span><span class="p">(</span><span class="n">_saved_autoscaley</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">label</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">patch</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">patch</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">patch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">p</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patch</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">'_nolegend_'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">'Patch'</span><span class="p">,</span> <span class="n">patches</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tops</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">'Lists of Patches'</span><span class="p">,</span> <span class="n">patches</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.hist2d"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.hist2d.html#matplotlib.axes.Axes.hist2d">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"weights"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hist2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">cmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Make a 2D histogram plot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y: array_like, shape (n, )</span>
<span class="sd">            Input values</span>

<span class="sd">        bins: [None | int | [int, int] | array_like | [array, array]]</span>

<span class="sd">            The bin specification:</span>

<span class="sd">                - If int, the number of bins for the two dimensions</span>
<span class="sd">                  (nx=ny=bins).</span>

<span class="sd">                - If [int, int], the number of bins in each dimension</span>
<span class="sd">                  (nx, ny = bins).</span>

<span class="sd">                - If array_like, the bin edges for the two dimensions</span>
<span class="sd">                  (x_edges=y_edges=bins).</span>

<span class="sd">                - If [array, array], the bin edges in each dimension</span>
<span class="sd">                  (x_edges, y_edges = bins).</span>

<span class="sd">            The default value is 10.</span>

<span class="sd">        range : array_like shape(2, 2), optional, default: None</span>
<span class="sd">             The leftmost and rightmost edges of the bins along each dimension</span>
<span class="sd">             (if not specified explicitly in the bins parameters): [[xmin,</span>
<span class="sd">             xmax], [ymin, ymax]]. All values outside of this range will be</span>
<span class="sd">             considered outliers and not tallied in the histogram.</span>

<span class="sd">        normed : boolean, optional, default: False</span>
<span class="sd">             Normalize histogram.</span>

<span class="sd">        weights : array_like, shape (n, ), optional, default: None</span>
<span class="sd">            An array of values w_i weighing each sample (x_i, y_i).</span>

<span class="sd">        cmin : scalar, optional, default: None</span>
<span class="sd">             All bins that has count less than cmin will not be displayed and</span>
<span class="sd">             these count values in the return value count histogram will also</span>
<span class="sd">             be set to nan upon return</span>

<span class="sd">        cmax : scalar, optional, default: None</span>
<span class="sd">             All bins that has count more than cmax will not be displayed (set</span>
<span class="sd">             to none before passing to imshow) and these count values in the</span>
<span class="sd">             return value count histogram will also be set to nan upon return</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : 2D array</span>
<span class="sd">            The bi-dimensional histogram of samples x and y. Values in x are</span>
<span class="sd">            histogrammed along the first dimension and values in y are</span>
<span class="sd">            histogrammed along the second dimension.</span>
<span class="sd">        xedges : 1D array</span>
<span class="sd">            The bin edges along the x axis.</span>
<span class="sd">        yedges : 1D array</span>
<span class="sd">            The bin edges along the y axis.</span>
<span class="sd">        image : AxesImage</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        cmap : {Colormap, string}, optional</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance.  If not set, use rc</span>
<span class="sd">            settings.</span>

<span class="sd">        norm : Normalize, optional</span>
<span class="sd">            A :class:`matplotlib.colors.Normalize` instance is used to</span>
<span class="sd">            scale luminance data to ``[0, 1]``. If not set, defaults to</span>
<span class="sd">            ``Normalize()``.</span>

<span class="sd">        vmin/vmax : {None, scalar}, optional</span>
<span class="sd">            Arguments passed to the `Normalize` instance.</span>

<span class="sd">        alpha : ``0 &lt;= scalar &lt;= 1`` or ``None``, optional</span>
<span class="sd">            The alpha blending value.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hist : 1D histogram</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Rendering the histogram with a logarithmic color scale is</span>
<span class="sd">        accomplished by passing a :class:`colors.LogNorm` instance to</span>
<span class="sd">        the *norm* keyword argument. Likewise, power-law normalization</span>
<span class="sd">        (similar in effect to gamma correction) can be accomplished with</span>
<span class="sd">        :class:`colors.PowerNorm`.</span>
<span class="sd">        """</span>

        <span class="n">h</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span>
                                           <span class="n">normed</span><span class="o">=</span><span class="n">normed</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">cmin</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">cmax</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcolorfast</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">yedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">,</span> <span class="n">pc</span></div>

<div class="viewcode-block" id="Axes.psd"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.psd.html#matplotlib.axes.Axes.psd">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_line</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Plot the power spectral density.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          psd(x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,</span>
<span class="sd">              window=mlab.window_hanning, noverlap=0, pad_to=None,</span>
<span class="sd">              sides='default', scale_by_freq=None, return_line=None, **kwargs)</span>

<span class="sd">        The power spectral density :math:`P_{xx}` by Welch's average</span>
<span class="sd">        periodogram method.  The vector *x* is divided into *NFFT* length</span>
<span class="sd">        segments.  Each segment is detrended by function *detrend* and</span>
<span class="sd">        windowed by function *window*.  *noverlap* gives the length of</span>
<span class="sd">        the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`</span>
<span class="sd">        of each segment :math:`i` are averaged to compute :math:`P_{xx}`,</span>
<span class="sd">        with a scaling to correct for power loss due to windowing.</span>

<span class="sd">        If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : integer</span>
<span class="sd">            The number of points of overlap between segments.</span>
<span class="sd">            The default value is 0 (no overlap).</span>

<span class="sd">        Fc : integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        return_line : bool</span>
<span class="sd">            Whether to include the line object plotted in the returned values.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pxx : 1-D array</span>
<span class="sd">            The values for the power spectrum `P_{xx}` before scaling</span>
<span class="sd">            (real valued)</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *Pxx*</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>
<span class="sd">            Only returned if *return_line* is True.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`specgram`</span>
<span class="sd">            :func:`specgram` differs in the default overlap; in not returning</span>
<span class="sd">            the mean of the segment periodograms; in returning the times of the</span>
<span class="sd">            segments; and in plotting a colormap instead of a line.</span>

<span class="sd">        :func:`magnitude_spectrum`</span>
<span class="sd">            :func:`magnitude_spectrum` plots the magnitude spectrum.</span>

<span class="sd">        :func:`csd`</span>
<span class="sd">            :func:`csd` plots the spectral density between two signals.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For plotting, the power is plotted as</span>
<span class="sd">        :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself</span>
<span class="sd">        is returned.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                              <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="k">if</span> <span class="n">scale_by_freq</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">psd_units</span> <span class="o">=</span> <span class="s1">'dB/Hz'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psd_units</span> <span class="o">=</span> <span class="s1">'dB'</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pxx</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">'Frequency'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">'Power Spectral Density (</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="n">psd_units</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="n">intv</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span>
        <span class="n">logi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">intv</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">logi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logi</span> <span class="o">=</span> <span class="o">.</span><span class="mi">1</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">logi</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span></div>

<div class="viewcode-block" id="Axes.csd"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.csd.html#matplotlib.axes.Axes.csd">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">"y"</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">csd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_line</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot the cross-spectral density.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          csd(x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,</span>
<span class="sd">              window=mlab.window_hanning, noverlap=0, pad_to=None,</span>
<span class="sd">              sides='default', scale_by_freq=None, return_line=None, **kwargs)</span>

<span class="sd">        The cross spectral density :math:`P_{xy}` by Welch's average</span>
<span class="sd">        periodogram method.  The vectors *x* and *y* are divided into</span>
<span class="sd">        *NFFT* length segments.  Each segment is detrended by function</span>
<span class="sd">        *detrend* and windowed by function *window*.  *noverlap* gives</span>
<span class="sd">        the length of the overlap between segments.  The product of</span>
<span class="sd">        the direct FFTs of *x* and *y* are averaged over each segment</span>
<span class="sd">        to compute :math:`P_{xy}`, with a scaling to correct for power</span>
<span class="sd">        loss due to windowing.</span>

<span class="sd">        If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero</span>
<span class="sd">        padded to *NFFT*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : 1-D arrays or sequences</span>
<span class="sd">            Arrays or sequences containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : integer</span>
<span class="sd">            The number of points of overlap between segments.</span>
<span class="sd">            The default value is 0 (no overlap).</span>

<span class="sd">        Fc : integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        return_line : bool</span>
<span class="sd">            Whether to include the line object plotted in the returned values.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pxy : 1-D array</span>
<span class="sd">            The values for the cross spectrum `P_{xy}` before scaling</span>
<span class="sd">            (complex valued)</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *Pxy*</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>
<span class="sd">            Only returned if *return_line* is True.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`psd`</span>
<span class="sd">            :func:`psd` is the equivalent to setting y=x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For plotting, the power is plotted as</span>
<span class="sd">        :math:`10\\log_{10}(P_{xy})` for decibels, though `P_{xy}` itself</span>
<span class="sd">        is returned.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                              <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="c1"># pxy is complex</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pxy</span><span class="p">)),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">'Frequency'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">'Cross Spectrum Magnitude (dB)'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">intervaly</span>

        <span class="n">intv</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">intv</span><span class="p">))</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span></div>

<div class="viewcode-block" id="Axes.magnitude_spectrum"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.magnitude_spectrum.html#matplotlib.axes.Axes.magnitude_spectrum">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">magnitude_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot the magnitude spectrum.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          magnitude_spectrum(x, Fs=2, Fc=0,  window=mlab.window_hanning,</span>
<span class="sd">                             pad_to=None, sides='default', **kwargs)</span>

<span class="sd">        Compute the magnitude spectrum of *x*.  Data is padded to a</span>
<span class="sd">        length of *pad_to* and the windowing function *window* is applied to</span>
<span class="sd">        the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        scale : [ 'default' | 'linear' | 'dB' ]</span>
<span class="sd">            The scaling of the values in the *spec*.  'linear' is no scaling.</span>
<span class="sd">            'dB' returns the values in dB scale, i.e., the dB amplitude</span>
<span class="sd">            (20 * log10). 'default' is 'linear'.</span>

<span class="sd">        Fc : integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the magnitude spectrum before scaling (real valued)</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`psd`</span>
<span class="sd">            :func:`psd` plots the power spectral density.`.</span>

<span class="sd">        :func:`angle_spectrum`</span>
<span class="sd">            :func:`angle_spectrum` plots the angles of the corresponding</span>
<span class="sd">            frequencies.</span>

<span class="sd">        :func:`phase_spectrum`</span>
<span class="sd">            :func:`phase_spectrum` plots the phase (unwrapped angle) of the</span>
<span class="sd">            corresponding frequencies.</span>

<span class="sd">        :func:`specgram`</span>
<span class="sd">            :func:`specgram` can plot the magnitude spectrum of segments within</span>
<span class="sd">            the signal in a colormap.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [Notes section required for data comment. See #10189.]</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">'default'</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="s1">'linear'</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">magnitude_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                              <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">'linear'</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="n">yunits</span> <span class="o">=</span> <span class="s1">'energy'</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">'dB'</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="n">yunits</span> <span class="o">=</span> <span class="s1">'dB'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Unknown scale </span><span class="si">%s</span><span class="s1">'</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">'Frequency'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">'Magnitude (</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="n">yunits</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Axes.angle_spectrum"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.angle_spectrum.html#matplotlib.axes.Axes.angle_spectrum">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">angle_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot the angle spectrum.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          angle_spectrum(x, Fs=2, Fc=0,  window=mlab.window_hanning,</span>
<span class="sd">                         pad_to=None, sides='default', **kwargs)</span>

<span class="sd">        Compute the angle spectrum (wrapped phase spectrum) of *x*.</span>
<span class="sd">        Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">        *window* is applied to the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        Fc : integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the angle spectrum in radians (real valued)</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`magnitude_spectrum`</span>
<span class="sd">            :func:`angle_spectrum` plots the magnitudes of the corresponding</span>
<span class="sd">            frequencies.</span>

<span class="sd">        :func:`phase_spectrum`</span>
<span class="sd">            :func:`phase_spectrum` plots the unwrapped version of this</span>
<span class="sd">            function.</span>

<span class="sd">        :func:`specgram`</span>
<span class="sd">            :func:`specgram` can plot the angle spectrum of segments within the</span>
<span class="sd">            signal in a colormap.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [Notes section required for data comment. See #10189.]</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">angle_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                          <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">'Frequency'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">'Angle (radians)'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Axes.phase_spectrum"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.phase_spectrum.html#matplotlib.axes.Axes.phase_spectrum">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">phase_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot the phase spectrum.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          phase_spectrum(x, Fs=2, Fc=0,  window=mlab.window_hanning,</span>
<span class="sd">                         pad_to=None, sides='default', **kwargs)</span>

<span class="sd">        Compute the phase spectrum (unwrapped angle spectrum) of *x*.</span>
<span class="sd">        Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">        *window* is applied to the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        Fc : integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the phase spectrum in radians (real valued)</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`magnitude_spectrum`</span>
<span class="sd">            :func:`magnitude_spectrum` plots the magnitudes of the</span>
<span class="sd">            corresponding frequencies.</span>

<span class="sd">        :func:`angle_spectrum`</span>
<span class="sd">            :func:`angle_spectrum` plots the wrapped version of this function.</span>

<span class="sd">        :func:`specgram`</span>
<span class="sd">            :func:`specgram` can plot the phase spectrum of segments within the</span>
<span class="sd">            signal in a colormap.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [Notes section required for data comment. See #10189.]</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">phase_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                          <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">'Frequency'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">'Phase (radians)'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Axes.cohere"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.cohere.html#matplotlib.axes.Axes.cohere">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">cohere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
               <span class="n">window</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">window_hanning</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">sides</span><span class="o">=</span><span class="s1">'default'</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot the coherence between *x* and *y*.</span>

<span class="sd">        Plot the coherence between *x* and *y*.  Coherence is the</span>
<span class="sd">        normalized cross spectral density:</span>

<span class="sd">        .. math::</span>

<span class="sd">          C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : integer</span>
<span class="sd">            The number of points of overlap between blocks.  The</span>
<span class="sd">            default value is 0 (no overlap).</span>

<span class="sd">        Fc : integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The return value is a tuple (*Cxy*, *f*), where *f* are the</span>
<span class="sd">        frequencies of the coherence vector.</span>

<span class="sd">        kwargs are applied to the lines.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">            %(Line2D)s</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">cxy</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">cohere</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                                 <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                                 <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">cxy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">'Frequency'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">'Coherence'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cxy</span><span class="p">,</span> <span class="n">freqs</span></div>

<div class="viewcode-block" id="Axes.specgram"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.specgram.html#matplotlib.axes.Axes.specgram">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"x"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">specgram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xextent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot a spectrogram.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          specgram(x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,</span>
<span class="sd">                   window=mlab.window_hanning, noverlap=128,</span>
<span class="sd">                   cmap=None, xextent=None, pad_to=None, sides='default',</span>
<span class="sd">                   scale_by_freq=None, mode='default', scale='default',</span>
<span class="sd">                   **kwargs)</span>

<span class="sd">        Compute and plot a spectrogram of data in *x*.  Data are split into</span>
<span class="sd">        *NFFT* length segments and the spectrum of each section is</span>
<span class="sd">        computed.  The windowing function *window* is applied to each</span>
<span class="sd">        segment, and the amount of overlap of each segment is</span>
<span class="sd">        specified with *noverlap*. The spectrogram is plotted as a colormap</span>
<span class="sd">        (using imshow).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        mode : [ 'default' | 'psd' | 'magnitude' | 'angle' | 'phase' ]</span>
<span class="sd">            What sort of spectrum to use.  Default is 'psd', which takes</span>
<span class="sd">            the power spectral density.  'complex' returns the complex-valued</span>
<span class="sd">            frequency spectrum.  'magnitude' returns the magnitude spectrum.</span>
<span class="sd">            'angle' returns the phase spectrum without unwrapping.  'phase'</span>
<span class="sd">            returns the phase spectrum with unwrapping.</span>

<span class="sd">        noverlap : integer</span>
<span class="sd">            The number of points of overlap between blocks.  The</span>
<span class="sd">            default value is 128.</span>

<span class="sd">        scale : [ 'default' | 'linear' | 'dB' ]</span>
<span class="sd">            The scaling of the values in the *spec*.  'linear' is no scaling.</span>
<span class="sd">            'dB' returns the values in dB scale.  When *mode* is 'psd',</span>
<span class="sd">            this is dB power (10 * log10).  Otherwise this is dB amplitude</span>
<span class="sd">            (20 * log10). 'default' is 'dB' if *mode* is 'psd' or</span>
<span class="sd">            'magnitude' and 'linear' otherwise.  This must be 'linear'</span>
<span class="sd">            if *mode* is 'angle' or 'phase'.</span>

<span class="sd">        Fc : integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        cmap :</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance; if *None*, use</span>
<span class="sd">            default determined by rc</span>

<span class="sd">        xextent : [None | (xmin, xmax)]</span>
<span class="sd">            The image extent along the x-axis. The default sets *xmin* to the</span>
<span class="sd">            left border of the first bin (*spectrum* column) and *xmax* to the</span>
<span class="sd">            right border of the last bin. Note that for *noverlap&gt;0* the width</span>
<span class="sd">            of the bins is smaller than those of the segments.</span>

<span class="sd">        **kwargs :</span>
<span class="sd">            Additional kwargs are passed on to imshow which makes the</span>
<span class="sd">            specgram image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 2-D array</span>
<span class="sd">            Columns are the periodograms of successive segments.</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the rows in *spectrum*.</span>

<span class="sd">        t : 1-D array</span>
<span class="sd">            The times corresponding to midpoints of segments (i.e., the columns</span>
<span class="sd">            in *spectrum*).</span>

<span class="sd">        im : instance of class :class:`~matplotlib.image.AxesImage`</span>
<span class="sd">            The image created by imshow containing the spectrogram</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`psd`</span>
<span class="sd">            :func:`psd` differs in the default overlap; in returning the mean</span>
<span class="sd">            of the segment periodograms; in not returning times; and in</span>
<span class="sd">            generating a line plot instead of colormap.</span>

<span class="sd">        :func:`magnitude_spectrum`</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is 'magnitude'. Plots a line instead of a colormap.</span>

<span class="sd">        :func:`angle_spectrum`</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is 'angle'. Plots a line instead of a colormap.</span>

<span class="sd">        :func:`phase_spectrum`</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is 'phase'. Plots a line instead of a colormap.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The parameters *detrend* and *scale_by_freq* do only apply when *mode*</span>
<span class="sd">        is set to 'psd'.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>  <span class="c1"># same default as in mlab.specgram()</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># same default as in mlab._spectral_helper()</span>
        <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1"># same default as in mlab.specgram()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">'complex'</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot plot a complex specgram'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">'default'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'angle'</span><span class="p">,</span> <span class="s1">'phase'</span><span class="p">]:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="s1">'linear'</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="s1">'dB'</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'angle'</span><span class="p">,</span> <span class="s1">'phase'</span><span class="p">]</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">'dB'</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot use dB scale with angle or phase mode'</span><span class="p">)</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">specgram</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                       <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                       <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                       <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                       <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">'linear'</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">'dB'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">'default'</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">'psd'</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Unknown scale </span><span class="si">%s</span><span class="s1">'</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xextent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># padding is needed for first and last segment:</span>
            <span class="n">pad_xextent</span> <span class="o">=</span> <span class="p">(</span><span class="n">NFFT</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span> <span class="o">/</span> <span class="n">Fs</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">xextent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">pad_xextent</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">pad_xextent</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">xextent</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'auto'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">im</span></div>

<div class="viewcode-block" id="Axes.spy"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.spy.html#matplotlib.axes.Axes.spy">[docs]</a>    <span class="k">def</span> <span class="nf">spy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">aspect</span><span class="o">=</span><span class="s1">'equal'</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">"upper"</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot the sparsity pattern on a 2-D array.</span>

<span class="sd">        ``spy(Z)`` plots the sparsity pattern of the 2-D array *Z*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Z : sparse array (n, m)</span>
<span class="sd">            The array to be plotted.</span>

<span class="sd">        precision : float, optional, default: 0</span>
<span class="sd">            If *precision* is 0, any non-zero value will be plotted; else,</span>
<span class="sd">            values of :math:`|Z| &gt; precision` will be plotted.</span>

<span class="sd">            For :class:`scipy.sparse.spmatrix` instances, there is a special</span>
<span class="sd">            case: if *precision* is 'present', any value present in the array</span>
<span class="sd">            will be plotted, even if it is identically zero.</span>

<span class="sd">        origin : ["upper", "lower"], optional, default: "upper"</span>
<span class="sd">            Place the [0,0] index of the array in the upper left or lower left</span>
<span class="sd">            corner of the axes.</span>

<span class="sd">        aspect : ['auto' | 'equal' | scalar], optional, default: "equal"</span>

<span class="sd">            If 'equal', and `extent` is None, changes the axes aspect ratio to</span>
<span class="sd">            match that of the image. If `extent` is not `None`, the axes</span>
<span class="sd">            aspect ratio is changed to match that of the extent.</span>


<span class="sd">            If 'auto', changes the image aspect ratio to match that of the</span>
<span class="sd">            axes.</span>

<span class="sd">            If None, default to rc ``image.aspect`` value.</span>

<span class="sd">        Two plotting styles are available: image or marker. Both</span>
<span class="sd">        are available for full arrays, but only the marker style</span>
<span class="sd">        works for :class:`scipy.sparse.spmatrix` instances.</span>

<span class="sd">        If *marker* and *markersize* are *None*, an image will be</span>
<span class="sd">        returned and any remaining kwargs are passed to</span>
<span class="sd">        :func:`~matplotlib.pyplot.imshow`; else, a</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D` object will be returned with</span>
<span class="sd">        the value of marker determining the marker type, and any</span>
<span class="sd">        remaining kwargs passed to the</span>
<span class="sd">        :meth:`~matplotlib.axes.Axes.plot` method.</span>

<span class="sd">        If *marker* and *markersize* are *None*, useful kwargs include:</span>

<span class="sd">        * *cmap*</span>
<span class="sd">        * *alpha*</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        imshow : for image options.</span>
<span class="sd">        plot : for plotting options</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="s1">'tocoo'</span><span class="p">):</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">'s'</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>

            <span class="k">if</span> <span class="s1">'cmap'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">'cmap'</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">([</span><span class="s1">'w'</span><span class="p">,</span> <span class="s1">'k'</span><span class="p">],</span>
                                                        <span class="n">name</span><span class="o">=</span><span class="s1">'binary'</span><span class="p">)</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">nc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">nr</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">'nearest'</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect</span><span class="p">,</span>
                                <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="s1">'tocoo'</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">precision</span> <span class="o">==</span> <span class="s1">'present'</span><span class="p">:</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">row</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">col</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
                <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">marker</span> <span class="o">=</span> <span class="s1">'s'</span>
            <span class="k">if</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">markersize</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">marks</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">'None'</span><span class="p">,</span>
                         <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xmin</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">nc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">nr</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">marks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_y</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">'both'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Axes.matshow"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.matshow.html#matplotlib.axes.Axes.matshow">[docs]</a>    <span class="k">def</span> <span class="nf">matshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot a matrix or array as an image.</span>

<span class="sd">        The matrix will be shown the way it would be printed, with the first</span>
<span class="sd">        row at the top.  Row and column numbering is zero-based.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Z : array_like shape (n, m)</span>
<span class="sd">            The matrix to be displayed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : `~matplotlib.image.AxesImage`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.axes.Axes.imshow` arguments</span>
<span class="sd">            Sets `origin` to 'upper', 'interpolation' to 'nearest' and</span>
<span class="sd">            'aspect' to equal.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        imshow : plot an image</span>

<span class="sd">        """</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'origin'</span><span class="p">:</span> <span class="s1">'upper'</span><span class="p">,</span>
              <span class="s1">'interpolation'</span><span class="p">:</span> <span class="s1">'nearest'</span><span class="p">,</span>
              <span class="s1">'aspect'</span><span class="p">:</span> <span class="s1">'equal'</span><span class="p">}</span>          <span class="c1"># (already the imshow default)</span>
        <span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_y</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">'both'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">im</span></div>

<div class="viewcode-block" id="Axes.violinplot"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.violinplot.html#matplotlib.axes.Axes.violinplot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"dataset"</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">violinplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                   <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Make a violin plot.</span>

<span class="sd">        Make a violin plot for each column of *dataset* or each vector in</span>
<span class="sd">        sequence *dataset*.  Each filled area extends to represent the</span>
<span class="sd">        entire data range, with optional lines at the mean, the median,</span>
<span class="sd">        the minimum, and the maximum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataset : Array or a sequence of vectors.</span>
<span class="sd">          The input data.</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the violins. The ticks and limits are</span>
<span class="sd">          automatically set to match the positions.</span>

<span class="sd">        vert : bool, default = True.</span>
<span class="sd">          If true, creates a vertical violin plot.</span>
<span class="sd">          Otherwise, creates a horizontal violin plot.</span>

<span class="sd">        widths : array-like, default = 0.5</span>
<span class="sd">          Either a scalar or a vector that sets the maximal width of</span>
<span class="sd">          each violin. The default is 0.5, which uses about half of the</span>
<span class="sd">          available horizontal space.</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If `True`, will toggle rendering of the means.</span>

<span class="sd">        showextrema : bool, default = True</span>
<span class="sd">          If `True`, will toggle rendering of the extrema.</span>

<span class="sd">        showmedians : bool, default = False</span>
<span class="sd">          If `True`, will toggle rendering of the medians.</span>

<span class="sd">        points : scalar, default = 100</span>
<span class="sd">          Defines the number of points to evaluate each of the</span>
<span class="sd">          gaussian kernel density estimations at.</span>

<span class="sd">        bw_method : str, scalar or callable, optional</span>
<span class="sd">          The method used to calculate the estimator bandwidth.  This can be</span>
<span class="sd">          'scott', 'silverman', a scalar constant or a callable.  If a</span>
<span class="sd">          scalar, this will be used directly as `kde.factor`.  If a</span>
<span class="sd">          callable, it should take a `GaussianKDE` instance as its only</span>
<span class="sd">          parameter and return a scalar. If None (default), 'scott' is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the violinplot to a</span>
<span class="sd">          list of the corresponding collection instances created. The</span>
<span class="sd">          dictionary has the following keys:</span>

<span class="sd">            - ``bodies``: A list of the</span>
<span class="sd">              :class:`matplotlib.collections.PolyCollection` instances</span>
<span class="sd">              containing the filled area of each violin.</span>

<span class="sd">            - ``cmeans``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the mean values of each of the</span>
<span class="sd">              violin's distribution.</span>

<span class="sd">            - ``cmins``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the bottom of each violin's</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmaxes``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the top of each violin's</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cbars``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the centers of each violin's</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmedians``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the median values of each of the</span>
<span class="sd">              violin's distribution.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [Notes section required for data comment. See #10189.]</span>

<span class="sd">        """</span>

        <span class="k">def</span> <span class="nf">_kde_method</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
            <span class="c1"># fallback gracefully if the vector contains only one value</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">X</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">kde</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">GaussianKDE</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bw_method</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kde</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">vpstats</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">violin_stats</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">_kde_method</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">violin</span><span class="p">(</span><span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">,</span>
                           <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="n">showmeans</span><span class="p">,</span>
                           <span class="n">showextrema</span><span class="o">=</span><span class="n">showextrema</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="n">showmedians</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.violin"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.violin.html#matplotlib.axes.Axes.violin">[docs]</a>    <span class="k">def</span> <span class="nf">violin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
               <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""Drawing function for violin plots.</span>

<span class="sd">        Draw a violin plot for each column of `vpstats`. Each filled area</span>
<span class="sd">        extends to represent the entire data range, with optional lines at the</span>
<span class="sd">        mean, the median, the minimum, and the maximum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        vpstats : list of dicts</span>
<span class="sd">          A list of dictionaries containing stats for each violin plot.</span>
<span class="sd">          Required keys are:</span>

<span class="sd">          - ``coords``: A list of scalars containing the coordinates that</span>
<span class="sd">            the violin's kernel density estimate were evaluated at.</span>

<span class="sd">          - ``vals``: A list of scalars containing the values of the</span>
<span class="sd">            kernel density estimate at each of the coordinates given</span>
<span class="sd">            in *coords*.</span>

<span class="sd">          - ``mean``: The mean value for this violin's dataset.</span>

<span class="sd">          - ``median``: The median value for this violin's dataset.</span>

<span class="sd">          - ``min``: The minimum value for this violin's dataset.</span>

<span class="sd">          - ``max``: The maximum value for this violin's dataset.</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the violins. The ticks and limits are</span>
<span class="sd">          automatically set to match the positions.</span>

<span class="sd">        vert : bool, default = True.</span>
<span class="sd">          If true, plots the violins veritcally.</span>
<span class="sd">          Otherwise, plots the violins horizontally.</span>

<span class="sd">        widths : array-like, default = 0.5</span>
<span class="sd">          Either a scalar or a vector that sets the maximal width of</span>
<span class="sd">          each violin. The default is 0.5, which uses about half of the</span>
<span class="sd">          available horizontal space.</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If true, will toggle rendering of the means.</span>

<span class="sd">        showextrema : bool, default = True</span>
<span class="sd">          If true, will toggle rendering of the extrema.</span>

<span class="sd">        showmedians : bool, default = False</span>
<span class="sd">          If true, will toggle rendering of the medians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the violinplot to a</span>
<span class="sd">          list of the corresponding collection instances created. The</span>
<span class="sd">          dictionary has the following keys:</span>

<span class="sd">            - ``bodies``: A list of the</span>
<span class="sd">              :class:`matplotlib.collections.PolyCollection` instances</span>
<span class="sd">              containing the filled area of each violin.</span>

<span class="sd">            - ``cmeans``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the mean values of each of the</span>
<span class="sd">              violin's distribution.</span>

<span class="sd">            - ``cmins``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the bottom of each violin's</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmaxes``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the top of each violin's</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cbars``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the centers of each violin's</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmedians``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the median values of each of the</span>
<span class="sd">              violin's distribution.</span>

<span class="sd">        """</span>

        <span class="c1"># Statistical quantities to be plotted on the violins</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">maxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Collections to be returned</span>
        <span class="n">artists</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vpstats</span><span class="p">)</span>
        <span class="n">datashape_message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"List of violinplot statistics and `</span><span class="si">{0}</span><span class="s2">` "</span>
                             <span class="s2">"values must have the same length"</span><span class="p">)</span>

        <span class="c1"># Validate positions</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">"positions"</span><span class="p">))</span>

        <span class="c1"># Validate widths</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">"widths"</span><span class="p">))</span>

        <span class="c1"># Calculate ranges for statistics lines</span>
        <span class="n">pmins</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">+</span> <span class="n">positions</span>
        <span class="n">pmaxes</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">+</span> <span class="n">positions</span>

        <span class="c1"># Check whether we are rendering vertically or horizontally</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_betweenx</span>
            <span class="n">perp_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hlines</span>
            <span class="n">par_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_between</span>
            <span class="n">perp_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span>
            <span class="n">par_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hlines</span>

        <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">'_internal.classic_mode'</span><span class="p">]:</span>
            <span class="n">fillcolor</span> <span class="o">=</span> <span class="s1">'y'</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">'r'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fillcolor</span> <span class="o">=</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>

        <span class="c1"># Render violins</span>
        <span class="n">bodies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">):</span>
            <span class="c1"># The 0.5 factor reflects the fact that we plot from v-p to</span>
            <span class="c1"># v+p</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">'vals'</span><span class="p">])</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">width</span> <span class="o">*</span> <span class="n">vals</span> <span class="o">/</span> <span class="n">vals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">bodies</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fill</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">'coords'</span><span class="p">],</span>
                            <span class="o">-</span><span class="n">vals</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
                            <span class="n">vals</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
                            <span class="n">facecolor</span><span class="o">=</span><span class="n">fillcolor</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)]</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">'mean'</span><span class="p">])</span>
            <span class="n">mins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">'min'</span><span class="p">])</span>
            <span class="n">maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">'max'</span><span class="p">])</span>
            <span class="n">medians</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">'median'</span><span class="p">])</span>
        <span class="n">artists</span><span class="p">[</span><span class="s1">'bodies'</span><span class="p">]</span> <span class="o">=</span> <span class="n">bodies</span>

        <span class="c1"># Render means</span>
        <span class="k">if</span> <span class="n">showmeans</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">'cmeans'</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span>
                                           <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>

        <span class="c1"># Render extrema</span>
        <span class="k">if</span> <span class="n">showextrema</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">'cmaxes'</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">maxes</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span>
                                           <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">'cmins'</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">mins</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span>
                                          <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">'cbars'</span><span class="p">]</span> <span class="o">=</span> <span class="n">par_lines</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">mins</span><span class="p">,</span> <span class="n">maxes</span><span class="p">,</span>
                                         <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>

        <span class="c1"># Render medians</span>
        <span class="k">if</span> <span class="n">showmedians</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">'cmedians'</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">medians</span><span class="p">,</span>
                                             <span class="n">pmins</span><span class="p">,</span>
                                             <span class="n">pmaxes</span><span class="p">,</span>
                                             <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">artists</span></div>

<div class="viewcode-block" id="Axes.tricontour"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.tricontour.html#matplotlib.axes.Axes.tricontour">[docs]</a>    <span class="k">def</span> <span class="nf">tricontour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">tricontour</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontour</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Axes.tricontourf"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.tricontourf.html#matplotlib.axes.Axes.tricontourf">[docs]</a>    <span class="k">def</span> <span class="nf">tricontourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">tricontourf</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontour</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Axes.tripcolor"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.tripcolor.html#matplotlib.axes.Axes.tripcolor">[docs]</a>    <span class="k">def</span> <span class="nf">tripcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tripcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">tripcolor</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tripcolor</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Axes.triplot"><a class="viewcode-back" href="../../../api/_as_gen/matplotlib.axes.Axes.triplot.html#matplotlib.axes.Axes.triplot">[docs]</a>    <span class="k">def</span> <span class="nf">triplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mtri</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">triplot</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">triplot</span><span class="o">.</span><span class="vm">__doc__</span></div>
</pre></div>
</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="footer">
        © Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br/>
      Last updated on Jun 28, 2018.
	Created using
	<ahref>Sphinx 1.7.5.
	Doc version v2.2.2-101-g15e1eadd0.
    </ahref></div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
<!--Flipcause Integration v3.0// Flipcause Integration Instructions:
Install the following code block once in the website Header (after <head> tag) -->
<style>

.fc-black_overlay{
display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;
background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;
}

.fc-white_content {
opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;
position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;
}

.fc-main-box{
opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;
}

.fc-widget_close{
opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);
position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;
}

.floating_button{
display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;
position:fixed; z-index:999999; overflow: auto;
}

@keyframes backfadesin {
   from { opacity:0; }
   to {opacity:.5;}
}

@-moz-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-webkit-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-o-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}


@-ms-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; transform: translateY(20px);}
   100% {opacity: 1; transform: translateY(0);}
}

@-moz-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -moz-transform: translateY(20px);}
   100% {opacity: 1; -moz-transform: translateY(0);}
}

@-webkit-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -webkit-transform: translateY(20px);}
   100% {opacity: 1; -webkit-transform: translateY(0);}
}

@-o-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -o-transform: translateY(20px);}
   100% {opacity: 1; -o-transform: translateY(0);}
}

@-ms-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -ms-transform: translateY(20px);}
   100% {opacity: 1; -ms-transform: translateY(0);}
}

</style>
<div class="fc-black_overlay" id="fc-fade" onclick="close_window()"></div>
<div class="fc-white_content" id="fc-light">
<div class="fc-main-box" id="fc-main">
<div class="fc-widget_close" id="fc-close" onclick="close_window()">
</div><iframe height="580" id="fc-myFrame" iframe="" scrolling="no" src="" style="border: 0;
border-radius:5px 5px 5px 5px; box-shadow:0 0 8px rgba(0, 0, 0, 0.5);" width="925"></iframe></div>
</div>
<!--END Flipcause Main Integration Code-->
</footer>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>matplotlib.contour — Matplotlib 2.2.2 documentation</title>
<link href="../../_static/mpl.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/gallery.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<link href="../../_static/opensearch.xml" rel="search" title="Search within Matplotlib 2.2.2 documentation" type="application/opensearchdescription+xml"/>
<link href="../../_static/favicon.ico" rel="shortcut icon"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="../../index.html" rel="top" title="Matplotlib 2.2.2 documentation"/>
<link href="../matplotlib.html" rel="up" title="matplotlib"/>
<link href="https://matplotlib.org/_modules/matplotlib/contour.html" rel="canonical"/>
<link href="https://matplotlib.org/_modules/matplotlib/contour.html" rel="canonical"/></head>
<body><div id="old-version-banner">
            You are reading documentation for a static version of Matplotlib.
            <a href="https://matplotlib.org/_modules/matplotlib/contour.html">This page may have been updated.</a>
</div>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../../index.html">
<div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 2.2.2</span></div>
<img alt="matplotlib" border="0" height="125px" src="../../_static/logo2.png"/></a>
<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li><a href="../../index.html">home</a>| </li>
<li><a href="../../gallery/index.html">examples</a>| </li>
<li><a href="../../tutorials/index.html">tutorials</a>| </li>
<li><a href="../../api/pyplot_summary.html">pyplot</a>| </li>
<li><a href="../../contents.html">docs</a> »</li>
<li><a href="../index.html">Module code</a> »</li>
<li><a accesskey="U" href="../matplotlib.html">matplotlib</a> »</li>
</ul>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div id="searchbox" role="search" style="display: none">
<h3>Quick search</h3>
<div class="searchformwrapper">
<form action="../../search.html" class="search" method="get">
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="../../contents.html">Documentation overview</a><ul>
<li><a href="../index.html">Module code</a><ul>
<li><a href="../matplotlib.html">matplotlib</a><ul>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<h1>Source code for matplotlib.contour</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">These are classes to support contour plotting and labelling for the Axes class.</span>
<span class="sd">"""</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">xrange</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">ma</span>
<span class="kn">import</span> <span class="nn">matplotlib._contour</span> <span class="k">as</span> <span class="nn">_contour</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">ticker</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="k">as</span> <span class="nn">mcoll</span>
<span class="kn">import</span> <span class="nn">matplotlib.font_manager</span> <span class="k">as</span> <span class="nn">font_manager</span>
<span class="kn">import</span> <span class="nn">matplotlib.text</span> <span class="k">as</span> <span class="nn">text</span>
<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">import</span> <span class="nn">matplotlib.mathtext</span> <span class="k">as</span> <span class="nn">mathtext</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.texmanager</span> <span class="k">as</span> <span class="nn">texmanager</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">mtransforms</span>

<span class="c1"># Import needed for adding manual selection capability to clabel</span>
<span class="kn">from</span> <span class="nn">matplotlib.blocking_input</span> <span class="k">import</span> <span class="n">BlockingContourLabeler</span>

<span class="c1"># We can't use a single line collection for contour because a line</span>
<span class="c1"># collection can have only a single line style, and we want to be able to have</span>
<span class="c1"># dashed negative contours, for example, and solid positive contours.</span>
<span class="c1"># We could use a single polygon collection for filled contours, but it</span>
<span class="c1"># seems better to keep line and filled contours similar, with one collection</span>
<span class="c1"># per level.</span>


<div class="viewcode-block" id="ClabelText"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ClabelText">[docs]</a><span class="k">class</span> <span class="nc">ClabelText</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Unlike the ordinary text, the get_rotation returns an updated</span>
<span class="sd">    angle in the pixel coordinate assuming that the input rotation is</span>
<span class="sd">    an angle in data coordinate (or whatever transform set).</span>
<span class="sd">    """</span>
<div class="viewcode-block" id="ClabelText.get_rotation"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ClabelText.get_rotation">[docs]</a>    <span class="k">def</span> <span class="nf">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
        <span class="n">new_angles</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform_angles</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">angle</span><span class="p">]),</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]]))</span>
        <span class="k">return</span> <span class="n">new_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="ContourLabeler"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler">[docs]</a><span class="k">class</span> <span class="nc">ContourLabeler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""Mixin to provide labelling capability to ContourSet"""</span>

<div class="viewcode-block" id="ContourLabeler.clabel"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.clabel">[docs]</a>    <span class="k">def</span> <span class="nf">clabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Label a contour plot.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          clabel(cs, **kwargs)</span>

<span class="sd">        Adds labels to line contours in *cs*, where *cs* is a</span>
<span class="sd">        :class:`~matplotlib.contour.ContourSet` object returned by</span>
<span class="sd">        contour.</span>

<span class="sd">        ::</span>

<span class="sd">          clabel(cs, v, **kwargs)</span>

<span class="sd">        only labels contours listed in *v*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fontsize : string or float, optional</span>
<span class="sd">            Size in points or relative size e.g., 'smaller', 'x-large'.</span>
<span class="sd">            See `Text.set_size` for accepted string values.</span>

<span class="sd">        colors :</span>
<span class="sd">            Color of each label</span>

<span class="sd">            - if *None*, the color of each label matches the color of</span>
<span class="sd">              the corresponding contour</span>

<span class="sd">            - if one string color, e.g., *colors* = 'r' or *colors* =</span>
<span class="sd">              'red', all labels will be plotted in this color</span>

<span class="sd">            - if a tuple of matplotlib color args (string, float, rgb, etc),</span>
<span class="sd">              different labels will be plotted in different colors in the order</span>
<span class="sd">              specified</span>

<span class="sd">        inline : bool, optional</span>
<span class="sd">            If ``True`` the underlying contour is removed where the label is</span>
<span class="sd">            placed. Default is ``True``.</span>

<span class="sd">        inline_spacing : float, optional</span>
<span class="sd">            Space in pixels to leave on each side of label when</span>
<span class="sd">            placing inline. Defaults to 5.</span>

<span class="sd">            This spacing will be exact for labels at locations where the</span>
<span class="sd">            contour is straight, less so for labels on curved contours.</span>

<span class="sd">        fmt : string or dict, optional</span>
<span class="sd">            A format string for the label. Default is '%1.3f'</span>

<span class="sd">            Alternatively, this can be a dictionary matching contour</span>
<span class="sd">            levels with arbitrary strings to use for each contour level</span>
<span class="sd">            (i.e., fmt[level]=string), or it can be any callable, such</span>
<span class="sd">            as a :class:`~matplotlib.ticker.Formatter` instance, that</span>
<span class="sd">            returns a string when called with a numeric contour level.</span>

<span class="sd">        manual : bool or iterable, optional</span>
<span class="sd">            If ``True``, contour labels will be placed manually using</span>
<span class="sd">            mouse clicks. Click the first button near a contour to</span>
<span class="sd">            add a label, click the second button (or potentially both</span>
<span class="sd">            mouse buttons at once) to finish adding labels. The third</span>
<span class="sd">            button can be used to remove the last label added, but</span>
<span class="sd">            only if labels are not inline. Alternatively, the keyboard</span>
<span class="sd">            can be used to select label locations (enter to end label</span>
<span class="sd">            placement, delete or backspace act like the third mouse button,</span>
<span class="sd">            and any other key will select a label location).</span>

<span class="sd">            *manual* can also be an iterable object of x,y tuples.</span>
<span class="sd">            Contour labels will be created as if mouse is clicked at each</span>
<span class="sd">            x,y positions.</span>

<span class="sd">        rightside_up : bool, optional</span>
<span class="sd">            If ``True``, label rotations will always be plus</span>
<span class="sd">            or minus 90 degrees from level. Default is ``True``.</span>

<span class="sd">        use_clabeltext : bool, optional</span>
<span class="sd">            If ``True``, `ClabelText` class (instead of `Text`) is used to</span>
<span class="sd">            create labels. `ClabelText` recalculates rotation angles</span>
<span class="sd">            of texts during the drawing time, therefore this can be used if</span>
<span class="sd">            aspect of the axes changes. Default is ``False``.</span>
<span class="sd">        """</span>

        <span class="sd">"""</span>
<span class="sd">        NOTES on how this all works:</span>

<span class="sd">        clabel basically takes the input arguments and uses them to</span>
<span class="sd">        add a list of "label specific" attributes to the ContourSet</span>
<span class="sd">        object.  These attributes are all of the form label* and names</span>
<span class="sd">        should be fairly self explanatory.</span>

<span class="sd">        Once these attributes are set, clabel passes control to the</span>
<span class="sd">        labels method (case of automatic label placement) or</span>
<span class="sd">        `BlockingContourLabeler` (case of manual label placement).</span>
<span class="sd">        """</span>

        <span class="n">fontsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fontsize'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">inline</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'inline'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">inline_spacing</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'inline_spacing'</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fmt'</span><span class="p">,</span> <span class="s1">'</span><span class="si">%1.3f</span><span class="s1">'</span><span class="p">)</span>
        <span class="n">_colors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'colors'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_use_clabeltext</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'use_clabeltext'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Detect if manual selection is desired and remove from argument list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'manual'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rightside_up</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'rightside_up'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">levlabs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">levlabs</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">levlabs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Specified levels </span><span class="si">{}</span><span class="s2"> don't match available "</span>
                                 <span class="s2">"levels </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">levlabs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Illegal arguments to clabel, see help(clabel)"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span> <span class="o">=</span> <span class="n">levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span> <span class="o">=</span> <span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="o">.</span><span class="n">set_size</span><span class="p">(</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">font_size_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="o">.</span><span class="n">get_size_in_points</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">font_size_pts</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">_colors</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                                   <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">NoNorm</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_label_near</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inline</span><span class="p">,</span>
                                    <span class="n">inline_spacing</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'Select label locations manually using first mouse button.'</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'End manual selection with second mouse button.'</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inline</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">'Remove last label by clicking third mouse button.'</span><span class="p">)</span>

            <span class="n">blocking_contour_labeler</span> <span class="o">=</span> <span class="n">BlockingContourLabeler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">blocking_contour_labeler</span><span class="p">(</span><span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">(</span><span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>

        <span class="c1"># Hold on to some old attribute names.  These are deprecated and will</span>
        <span class="c1"># be removed in the near future (sometime after 2008-08-01), but</span>
        <span class="c1"># keeping for now for backwards compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cl_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cl_cvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelTextsList</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">'text.Text'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTextsList</span></div>

<div class="viewcode-block" id="ContourLabeler.print_label"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.print_label">[docs]</a>    <span class="k">def</span> <span class="nf">print_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linecontour</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">):</span>
        <span class="s2">"Return *False* if contours are too short for a label."</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">linecontour</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">labelwidth</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">linecontour</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">labelwidth</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span></div>

<div class="viewcode-block" id="ContourLabeler.too_close"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.too_close">[docs]</a>    <span class="k">def</span> <span class="nf">too_close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="s2">"Return *True* if a label is already near this location."</span>
        <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">lw</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="ContourLabeler.get_label_coords"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.get_label_coords">[docs]</a>    <span class="k">def</span> <span class="nf">get_label_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return x, y, and the index of a label location.</span>

<span class="sd">        Labels are plotted at a location with the smallest</span>
<span class="sd">        deviation of the contour from a straight line</span>
<span class="sd">        unless there is another label nearby, in which case</span>
<span class="sd">        the next best place on the contour is picked up.</span>
<span class="sd">        If all such candidates are rejected, the beginning</span>
<span class="sd">        of the contour is chosen.</span>
<span class="sd">        """</span>
        <span class="n">hysize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ysize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">adist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">adist</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">],</span> <span class="n">YY</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">too_close</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">adist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">],</span> <span class="n">YY</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span></div>

<div class="viewcode-block" id="ContourLabeler.get_label_width"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.get_label_width">[docs]</a>    <span class="k">def</span> <span class="nf">get_label_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">fsize</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the width of the label in points.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>

        <span class="n">lev</span><span class="p">,</span> <span class="n">ismath</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="o">.</span><span class="n">is_math_text</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ismath</span> <span class="o">==</span> <span class="s1">'TeX'</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_TeX_manager'</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_TeX_manager</span> <span class="o">=</span> <span class="n">texmanager</span><span class="o">.</span><span class="n">TexManager</span><span class="p">()</span>
            <span class="n">lw</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TeX_manager</span><span class="o">.</span><span class="n">get_text_width_height_descent</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span>
                                                                       <span class="n">fsize</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ismath</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_mathtext_parser'</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mathtext_parser</span> <span class="o">=</span> <span class="n">mathtext</span><span class="o">.</span><span class="n">MathTextParser</span><span class="p">(</span><span class="s1">'bitmap'</span><span class="p">)</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mathtext_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">72</span><span class="p">,</span>
                                                 <span class="n">prop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="p">)</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span>  <span class="c1"># at dpi=72, the units are PostScript points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># width is much less than "font size"</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lev</span><span class="p">))</span> <span class="o">*</span> <span class="n">fsize</span> <span class="o">*</span> <span class="mf">0.6</span>

        <span class="k">return</span> <span class="n">lw</span></div>

<div class="viewcode-block" id="ContourLabeler.get_real_label_width"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.get_real_label_width">[docs]</a>    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">"2.2"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_real_label_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">fsize</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        This computes actual onscreen label width.</span>
<span class="sd">        This uses some black magic to determine onscreen extent of non-drawn</span>
<span class="sd">        label.  This magic may not be very robust.</span>

<span class="sd">        This method is not being used, and may be modified or removed.</span>
<span class="sd">        """</span>
        <span class="c1"># Find middle of axes</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Temporarily create text object</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_label_props</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">),</span> <span class="s1">'k'</span><span class="p">)</span>

        <span class="c1"># Some black magic to get onscreen extent</span>
        <span class="c1"># NOTE: This will only work for already drawn figures, as the canvas</span>
        <span class="c1"># does not have a renderer otherwise.  This is the reason this function</span>
        <span class="c1"># can't be integrated into the rest of the code.</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">(</span><span class="n">renderer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="p">)</span>

        <span class="c1"># difference in pixel extent of image</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">corners</span><span class="p">()[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lw</span></div>

<div class="viewcode-block" id="ContourLabeler.set_label_props"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.set_label_props">[docs]</a>    <span class="k">def</span> <span class="nf">set_label_props</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="s2">"set the label properties - color, fontsize, text"</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_fontproperties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_clip_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContourLabeler.get_text"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.get_text">[docs]</a>    <span class="k">def</span> <span class="nf">get_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="s2">"get the text of the label"</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lev</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="s1">'</span><span class="si">%1.3f</span><span class="s1">'</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">fmt</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fmt</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">lev</span></div>

<div class="viewcode-block" id="ContourLabeler.locate_label"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.locate_label">[docs]</a>    <span class="k">def</span> <span class="nf">locate_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linecontour</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Find good place to draw a label (relatively flat part of the contour).</span>
<span class="sd">        """</span>

        <span class="c1"># Number of contour points</span>
        <span class="n">nsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">linecontour</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labelwidth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsize</span> <span class="o">/</span> <span class="n">labelwidth</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xsize</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">xsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ysize</span> <span class="o">=</span> <span class="n">nsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ysize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labelwidth</span><span class="p">)</span>

        <span class="n">XX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">))</span>
        <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">))</span>
        <span class="c1"># I might have fouled up the following:</span>
        <span class="n">yfirst</span> <span class="o">=</span> <span class="n">YY</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ylast</span> <span class="o">=</span> <span class="n">YY</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">xfirst</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xlast</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">yfirst</span> <span class="o">-</span> <span class="n">YY</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xlast</span> <span class="o">-</span> <span class="n">xfirst</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">xfirst</span> <span class="o">-</span> <span class="n">XX</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ylast</span> <span class="o">-</span> <span class="n">yfirst</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xlast</span> <span class="o">-</span> <span class="n">xfirst</span><span class="p">,</span> <span class="n">ylast</span> <span class="o">-</span> <span class="n">yfirst</span><span class="p">)</span>
        <span class="c1"># Ignore warning that divide by zero throws, as this is a valid option</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">L</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_coords</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">)</span>

        <span class="c1"># There must be a more efficient way...</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">linecontour</span><span class="p">]</span>
        <span class="n">dind</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dind</span></div>

<div class="viewcode-block" id="ContourLabeler.calc_label_rot_and_inline"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.calc_label_rot_and_inline">[docs]</a>    <span class="k">def</span> <span class="nf">calc_label_rot_and_inline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slc</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        This function calculates the appropriate label rotation given</span>
<span class="sd">        the linecontour coordinates in screen units, the index of the</span>
<span class="sd">        label location and the label width.</span>

<span class="sd">        It will also break contour and calculate inlining if *lc* is</span>
<span class="sd">        not empty (lc defaults to the empty list if None).  *spacing*</span>
<span class="sd">        is the space around the label in pixels to leave empty.</span>

<span class="sd">        Do both of these tasks at once to avoid calculating path lengths</span>
<span class="sd">        multiple times, which is relatively costly.</span>

<span class="sd">        The method used here involves calculating the path length</span>
<span class="sd">        along the contour in pixel coordinates and then looking</span>
<span class="sd">        approximately label width / 2 away from central point to</span>
<span class="sd">        determine rotation and then to break contour if desired.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">lc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Half the label width</span>
        <span class="n">hlw</span> <span class="o">=</span> <span class="n">lw</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># Check if closed and, if so, rotate contour so label is at edge</span>
        <span class="n">closed</span> <span class="o">=</span> <span class="n">_is_closed_polygon</span><span class="p">(</span><span class="n">slc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">slc</span><span class="p">[</span><span class="n">ind</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">slc</span><span class="p">[:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>  <span class="c1"># Rotate lc also if not empty</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">lc</span><span class="p">[</span><span class="n">ind</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lc</span><span class="p">[:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Calculate path lengths</span>
        <span class="n">pl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">pl</span> <span class="o">=</span> <span class="n">pl</span> <span class="o">-</span> <span class="n">pl</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="c1"># Use linear interpolation to get points around label</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">hlw</span><span class="p">,</span> <span class="n">hlw</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>  <span class="c1"># Look at end also for closed contours</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

        <span class="c1"># Get angle of vector between the two ends of the label - must be</span>
        <span class="c1"># calculated in pixel space for text rotation to work correctly.</span>
        <span class="p">(</span><span class="n">dx</span><span class="p">,),</span> <span class="p">(</span><span class="n">dy</span><span class="p">,)</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dp</span> <span class="o">+</span> <span class="n">xi</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">slc_col</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">slc_col</span> <span class="ow">in</span> <span class="n">slc</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rightside_up</span><span class="p">:</span>
            <span class="c1"># Fix angle so text is never upside-down</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span> <span class="o">-</span> <span class="mi">90</span>

        <span class="c1"># Break contour if desired</span>
        <span class="n">nlc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>
            <span class="c1"># Expand range by spacing</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">dp</span> <span class="o">+</span> <span class="n">xi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">spacing</span><span class="p">,</span> <span class="n">spacing</span><span class="p">])</span>

            <span class="c1"># Get (integer) indices near points of interest; use -1 as marker</span>
            <span class="c1"># for out of bounds.</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pl</span><span class="p">)),</span> <span class="n">left</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xy1</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pl</span><span class="p">,</span> <span class="n">lc_col</span><span class="p">)</span> <span class="k">for</span> <span class="n">lc_col</span> <span class="ow">in</span> <span class="n">lc</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xy2</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pl</span><span class="p">,</span> <span class="n">lc_col</span><span class="p">)</span> <span class="k">for</span> <span class="n">lc_col</span> <span class="ow">in</span> <span class="n">lc</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

            <span class="c1"># Actually break contours</span>
            <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
                <span class="c1"># This will remove contour if shorter than label</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="p">):</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">xy2</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># These will remove pieces of contour if they have length zero</span>
                <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">lc</span><span class="p">[:</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">xy2</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]]))</span>

            <span class="c1"># The current implementation removes contours completely</span>
            <span class="c1"># covered by labels.  Uncomment line below to keep</span>
            <span class="c1"># original contour if this is the preferred behavior.</span>
            <span class="c1"># if not len(nlc): nlc = [ lc ]</span>

        <span class="k">return</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">nlc</span></div>

    <span class="k">def</span> <span class="nf">_get_label_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform_point</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                      <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">'center'</span><span class="p">,</span>
                      <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">'center'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_get_label_clabeltext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="c1"># x, y, rotation is given in pixel coordinate. Convert them to</span>
        <span class="c1"># the data coordinate and create a label using ClabelText</span>
        <span class="c1"># class. This way, the roation of the clabel is along the</span>
        <span class="c1"># contour line always.</span>
        <span class="n">transDataInv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">transDataInv</span><span class="o">.</span><span class="n">transform_point</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">drotation</span> <span class="o">=</span> <span class="n">transDataInv</span><span class="o">.</span><span class="n">transform_angles</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rotation</span><span class="p">]),</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]]))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ClabelText</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">drotation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">'center'</span><span class="p">,</span>
                       <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">'center'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_add_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">cvalue</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

        <span class="n">_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_label_props</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_text</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cvalue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="c1"># Add label to plot here - useful for manual mode label selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<div class="viewcode-block" id="ContourLabeler.add_label"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.add_label">[docs]</a>    <span class="k">def</span> <span class="nf">add_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add contour label using :class:`~matplotlib.text.Text` class.</span>
<span class="sd">        """</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_label_text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_label</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContourLabeler.add_label_clabeltext"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.add_label_clabeltext">[docs]</a>    <span class="k">def</span> <span class="nf">add_label_clabeltext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add contour label using :class:`ClabelText` class.</span>
<span class="sd">        """</span>
        <span class="c1"># x, y, rotation is given in pixel coordinate. Convert them to</span>
        <span class="c1"># the data coordinate and create a label using ClabelText</span>
        <span class="c1"># class. This way, the roation of the clabel is along the</span>
        <span class="c1"># contour line always.</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_label_clabeltext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_label</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContourLabeler.add_label_near"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.add_label_near">[docs]</a>    <span class="k">def</span> <span class="nf">add_label_near</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                       <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Add a label near the point (x, y). If transform is None</span>
<span class="sd">        (default), (x, y) is in data coordinates; if transform is</span>
<span class="sd">        False, (x, y) is in display coordinates; otherwise, the</span>
<span class="sd">        specified transform will be used to translate (x, y) into</span>
<span class="sd">        display coordinates.</span>

<span class="sd">        *inline*:</span>
<span class="sd">          controls whether the underlying contour is removed or</span>
<span class="sd">          not. Default is *True*.</span>

<span class="sd">        *inline_spacing*:</span>
<span class="sd">          space in pixels to leave on each side of label when</span>
<span class="sd">          placing inline.  Defaults to 5.  This spacing will be</span>
<span class="sd">          exact for labels at locations where the contour is</span>
<span class="sd">          straight, less so for labels on curved contours.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span>

        <span class="k">if</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform_point</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="c1"># find the nearest contour _in screen units_</span>
        <span class="n">conmin</span><span class="p">,</span> <span class="n">segmin</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_contour</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>

        <span class="c1"># The calc_label_rot_and_inline routine requires that (xmin,ymin)</span>
        <span class="c1"># be a vertex in the path. So, if it isn't, add a vertex here</span>

        <span class="c1"># grab the paths from the collections</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">conmin</span><span class="p">]</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
        <span class="c1"># grab the correct segment</span>
        <span class="n">active_path</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span>
        <span class="c1"># grab its vertices</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">active_path</span><span class="o">.</span><span class="n">vertices</span>
        <span class="c1"># sort out where the new vertex should be added data-units</span>
        <span class="n">xcmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">])</span>
        <span class="c1"># if there isn't a vertex close enough</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xcmin</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="n">imin</span><span class="p">]):</span>
            <span class="c1"># insert new data into the vertex list</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">lc</span><span class="p">[:</span><span class="n">imin</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xcmin</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lc</span><span class="p">[</span><span class="n">imin</span><span class="p">:]]</span>
            <span class="c1"># replace the path with the new one</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="c1"># Get index of nearest level in subset of levels used for labeling</span>
        <span class="n">lmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">conmin</span><span class="p">)</span>

        <span class="c1"># Coordinates of contour</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">conmin</span><span class="p">]</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span>

        <span class="c1"># In pixel/screen space</span>
        <span class="n">slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="c1"># Get label width for rotating labels and breaking contours</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_width</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">[</span><span class="n">lmin</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span><span class="p">[</span><span class="n">lmin</span><span class="p">])</span>
        <span class="c1"># lw is in points.</span>
        <span class="n">lw</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span> <span class="o">/</span> <span class="mf">72.0</span>  <span class="c1"># scale to screen coordinates</span>
        <span class="c1"># now lw in pixels</span>

        <span class="c1"># Figure out label rotation.</span>
        <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
            <span class="n">lcarg</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lcarg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rotation</span><span class="p">,</span> <span class="n">nlc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_label_rot_and_inline</span><span class="p">(</span>
            <span class="n">slc</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lcarg</span><span class="p">,</span>
            <span class="n">inline_spacing</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">[</span><span class="n">lmin</span><span class="p">],</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span><span class="p">[</span><span class="n">lmin</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
            <span class="c1"># Remove old, not looping over paths so we can do this up front</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">segmin</span><span class="p">)</span>

            <span class="c1"># Add paths if not empty or single point</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nlc</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="ContourLabeler.pop_label"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.pop_label">[docs]</a>    <span class="k">def</span> <span class="nf">pop_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">"""Defaults to removing last label, but any index can be supplied"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span></div>

<div class="viewcode-block" id="ContourLabeler.labels"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.labels">[docs]</a>    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_clabeltext</span><span class="p">:</span>
            <span class="n">add_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_label_clabeltext</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span>

        <span class="k">for</span> <span class="n">icon</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fsize</span><span class="p">,</span> <span class="n">cvalue</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span><span class="p">):</span>

            <span class="n">con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">icon</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_width</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">,</span> <span class="n">fsize</span><span class="p">)</span>
            <span class="n">lw</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span> <span class="o">/</span> <span class="mf">72.0</span>  <span class="c1"># scale to screen coordinates</span>
            <span class="n">additions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">segNum</span><span class="p">,</span> <span class="n">linepath</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">linepath</span><span class="o">.</span><span class="n">vertices</span>  <span class="c1"># Line contour</span>
                <span class="n">slc0</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>  <span class="c1"># Line contour in screen coords</span>

                <span class="c1"># For closed polygons, add extra point to avoid division by</span>
                <span class="c1"># zero in print_label and locate_label.  Other than these</span>
                <span class="c1"># functions, this is not necessary and should probably be</span>
                <span class="c1"># eventually removed.</span>
                <span class="k">if</span> <span class="n">_is_closed_polygon</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>
                    <span class="n">slc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">slc0</span><span class="p">,</span> <span class="n">slc0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slc</span> <span class="o">=</span> <span class="n">slc0</span>

                <span class="c1"># Check if long enough for a label</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_label</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locate_label</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">lw</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
                        <span class="n">lcarg</span> <span class="o">=</span> <span class="n">lc</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lcarg</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">rotation</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_label_rot_and_inline</span><span class="p">(</span>
                        <span class="n">slc0</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lcarg</span><span class="p">,</span>
                        <span class="n">inline_spacing</span><span class="p">)</span>

                    <span class="c1"># Actually add the label</span>
                    <span class="n">add_label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span>

                    <span class="c1"># If inline, add new contours</span>
                    <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                            <span class="c1"># Add path if not empty or single point</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">additions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If not adding label, keep old path</span>
                    <span class="n">additions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linepath</span><span class="p">)</span>

            <span class="c1"># After looping over all segments on a contour, remove old</span>
            <span class="c1"># paths and add new ones if inlining</span>
            <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">paths</span><span class="p">[:]</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">additions</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_find_closest_point_on_leg</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p0</span><span class="p">):</span>
    <span class="sd">"""find closest point to p0 on line segment connecting p1 and p2"""</span>

    <span class="c1"># handle degenerate case</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p2</span> <span class="o">==</span> <span class="n">p1</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">p0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">p1</span>

    <span class="n">d21</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
    <span class="n">d01</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">-</span> <span class="n">p1</span>

    <span class="c1"># project on to line segment to find closest point</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d01</span><span class="p">,</span> <span class="n">d21</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d21</span><span class="p">,</span> <span class="n">d21</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">proj</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">proj</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">proj</span> <span class="o">*</span> <span class="n">d21</span>

    <span class="c1"># find squared distance</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pc</span><span class="o">-</span><span class="n">p0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">pc</span>


<span class="k">def</span> <span class="nf">_is_closed_polygon</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Tests whether first and last object in a sequence are the same.  These are</span>
<span class="sd">    presumably coordinates on a polygonal curve, in which case this function</span>
<span class="sd">    tests if that curve is closed.</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_find_closest_point_on_path</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    lc: coordinates of vertices</span>
<span class="sd">    point: coordinates of test point</span>
<span class="sd">    """</span>

    <span class="c1"># find index of closest vertex for this segment</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">lc</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">xcmin</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">legmin</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">closed</span> <span class="o">=</span> <span class="n">_is_closed_polygon</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

    <span class="c1"># build list of legs before and after this vertex</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">imin</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">closed</span><span class="p">:</span>
        <span class="n">legs</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">imin</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">),</span> <span class="n">imin</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">imin</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">closed</span><span class="p">:</span>
        <span class="n">legs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">imin</span><span class="p">,</span> <span class="p">(</span><span class="n">imin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">legs</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">xc</span> <span class="o">=</span> <span class="n">_find_closest_point_on_leg</span><span class="p">(</span><span class="n">lc</span><span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">lc</span><span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">xcmin</span> <span class="o">=</span> <span class="n">xc</span>
            <span class="n">legmin</span> <span class="o">=</span> <span class="n">leg</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">xcmin</span><span class="p">,</span> <span class="n">legmin</span><span class="p">)</span>


<div class="viewcode-block" id="ContourSet"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet">[docs]</a><span class="k">class</span> <span class="nc">ContourSet</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">,</span> <span class="n">ContourLabeler</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Store a set of contour lines or filled regions.</span>

<span class="sd">    User-callable method: clabel</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ax:</span>
<span class="sd">        The axes object in which the contours are drawn.</span>

<span class="sd">    collections:</span>
<span class="sd">        A silent_list of LineCollections or PolyCollections.</span>

<span class="sd">    levels:</span>
<span class="sd">        Contour levels.</span>

<span class="sd">    layers:</span>
<span class="sd">        Same as levels for line contours; half-way between</span>
<span class="sd">        levels for filled contours.  See :meth:`_process_colors`.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Draw contour lines or filled regions, depending on</span>
<span class="sd">        whether keyword arg *filled* is ``False`` (default) or ``True``.</span>

<span class="sd">        The first three arguments must be:</span>

<span class="sd">          *ax*: axes object.</span>

<span class="sd">          *levels*: [level0, level1, ..., leveln]</span>
<span class="sd">            A list of floating point numbers indicating the contour</span>
<span class="sd">            levels.</span>

<span class="sd">          *allsegs*: [level0segs, level1segs, ...]</span>
<span class="sd">            List of all the polygon segments for all the *levels*.</span>
<span class="sd">            For contour lines ``len(allsegs) == len(levels)``, and for</span>
<span class="sd">            filled contour regions ``len(allsegs) = len(levels)-1``. The lists</span>
<span class="sd">            should look like::</span>

<span class="sd">                level0segs = [polygon0, polygon1, ...]</span>
<span class="sd">                polygon0 = array_like [[x0,y0], [x1,y1], ...]</span>

<span class="sd">          *allkinds*: *None* or [level0kinds, level1kinds, ...]</span>
<span class="sd">            Optional list of all the polygon vertex kinds (code types), as</span>
<span class="sd">            described and used in Path. This is used to allow multiply-</span>
<span class="sd">            connected paths such as holes within filled polygons.</span>
<span class="sd">            If not ``None``, ``len(allkinds) == len(allsegs)``. The lists</span>
<span class="sd">            should look like::</span>

<span class="sd">                level0kinds = [polygon0kinds, ...]</span>
<span class="sd">                polygon0kinds = [vertexcode0, vertexcode1, ...]</span>

<span class="sd">            If *allkinds* is not ``None``, usually all polygons for a</span>
<span class="sd">            particular contour level are grouped together so that</span>
<span class="sd">            ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.</span>

<span class="sd">        Keyword arguments are as described in the docstring of</span>
<span class="sd">        `~.Axes.contour`.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'levels'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'filled'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'linewidths'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linestyles</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'linestyles'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hatches</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'hatches'</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'alpha'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'origin'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'extent'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'cmap'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'colors'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'norm'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'vmin'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'vmax'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'extend'</span><span class="p">,</span> <span class="s1">'neither'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'antialiased'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># eliminate artifacts; we are not</span>
                                      <span class="c1"># stroking the boundaries.</span>
            <span class="c1"># The default for line contours will be taken from</span>
            <span class="c1"># the LineCollection default, which uses the</span>
            <span class="c1"># rcParams['lines.antialiased']</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nchunk</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'nchunk'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'locator'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span> <span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">'neither'</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'extend kwarg does not work yet with log '</span>
                                 <span class="s1">' scale'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">'lower'</span><span class="p">,</span> <span class="s1">'upper'</span><span class="p">,</span> <span class="s1">'image'</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"If given, *origin* must be one of [ 'lower' |"</span>
                             <span class="s2">" 'upper' | 'image']"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"If given, *extent* must be '[ *None* |"</span>
                             <span class="s2">" (x0,x1,y0,y1) ]'"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Either colors or cmap must be None'</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">'image'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'image.origin'</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'transform'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_levels</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ncolors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">ncolors</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Handle the case where colors are given for the extended</span>
            <span class="c1"># parts of the contour.</span>
            <span class="n">extend_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'min'</span><span class="p">,</span> <span class="s1">'both'</span><span class="p">]</span>
            <span class="n">extend_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'max'</span><span class="p">,</span> <span class="s1">'both'</span><span class="p">]</span>
            <span class="n">use_set_under_over</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># if we are extending the lower end, and we've been given enough</span>
            <span class="c1"># colors then skip the first color in the resulting cmap. For the</span>
            <span class="c1"># extend_max case we don't need to worry about passing more colors</span>
            <span class="c1"># than ncolors as ListedColormap will clip.</span>
            <span class="n">total_levels</span> <span class="o">=</span> <span class="n">ncolors</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">extend_min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">extend_max</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="n">total_levels</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">([</span><span class="n">extend_min</span><span class="p">,</span> <span class="n">extend_max</span><span class="p">])):</span>
                <span class="n">use_set_under_over</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">extend_min</span><span class="p">:</span>
                    <span class="n">i0</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">cmap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="kc">None</span><span class="p">],</span> <span class="n">N</span><span class="o">=</span><span class="n">ncolors</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_set_under_over</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">extend_min</span><span class="p">:</span>
                    <span class="n">cmap</span><span class="o">.</span><span class="n">set_under</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">extend_max</span><span class="p">:</span>
                    <span class="n">cmap</span><span class="o">.</span><span class="n">set_over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">'mcoll.PathCollection'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">'mcoll.LineCollection'</span><span class="p">)</span>
        <span class="c1"># label lists must be initialized here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cmap'</span><span class="p">:</span> <span class="n">cmap</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">'norm'</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="c1"># sets self.cmap, norm if needed;</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_colors</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_allsegs_and_allkinds</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'linewidths is ignored by contourf'</span><span class="p">)</span>

            <span class="c1"># Lower and upper contour levels.</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>

            <span class="c1"># Ensure allkinds can be zipped below.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span>

            <span class="c1"># Default zorder taken from Collection</span>
            <span class="n">zorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'zorder'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span> <span class="ow">in</span> \
                    <span class="nb">zip</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span><span class="p">):</span>
                <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_paths</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">)</span>

                <span class="n">col</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PathCollection</span><span class="p">(</span>
                    <span class="n">paths</span><span class="p">,</span>
                    <span class="n">antialiaseds</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span><span class="p">,),</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(),</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tlinewidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_linewidths</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tlinewidths</span> <span class="o">=</span> <span class="n">tlinewidths</span>
            <span class="n">tlinestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_linestyles</span><span class="p">()</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span>
            <span class="k">if</span> <span class="n">aa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aa</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span><span class="p">,)</span>
            <span class="c1"># Default zorder taken from LineCollection</span>
            <span class="n">zorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'zorder'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lstyle</span><span class="p">,</span> <span class="n">segs</span> <span class="ow">in</span> \
                    <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="n">tlinewidths</span><span class="p">,</span> <span class="n">tlinestyles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span>
                    <span class="n">segs</span><span class="p">,</span>
                    <span class="n">antialiaseds</span><span class="o">=</span><span class="n">aa</span><span class="p">,</span>
                    <span class="n">linewidths</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                    <span class="n">linestyles</span><span class="o">=</span><span class="p">[</span><span class="n">lstyle</span><span class="p">],</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(),</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">)</span>
                <span class="n">col</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">'_nolegend_'</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">col</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_mins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>  <span class="c1"># set the colors</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'The following kwargs were not used by contour: '</span> <span class="o">+</span>
                          <span class="n">s</span><span class="p">)</span>

<div class="viewcode-block" id="ContourSet.get_transform"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.get_transform">[docs]</a>    <span class="k">def</span> <span class="nf">get_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the :class:`~matplotlib.transforms.Transform`</span>
<span class="sd">        instance used by this ContourSet.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span>
              <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="s1">'_as_mpl_transform'</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># the C object _contour_generator cannot currently be pickled. This</span>
        <span class="c1"># isn't a big issue as it is not actually used once the contour has</span>
        <span class="c1"># been calculated.</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">'_contour_generator'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">state</span>

<div class="viewcode-block" id="ContourSet.legend_elements"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.legend_elements">[docs]</a>    <span class="k">def</span> <span class="nf">legend_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s1">'x'</span><span class="p">,</span> <span class="n">str_format</span><span class="o">=</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a list of artist and labels suitable for passing through</span>
<span class="sd">        to :func:`plt.legend` which represent this ContourSet.</span>

<span class="sd">        Args:</span>

<span class="sd">            *variable_name*: the string used inside the inequality used</span>
<span class="sd">              on the labels</span>

<span class="sd">            *str_format*: function used to format the numbers in the labels</span>
<span class="sd">        """</span>
        <span class="n">artists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>
            <span class="n">n_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">,</span> <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">)):</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">facecolor</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">hatch</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_hatch</span><span class="p">(),</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">())</span>
                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>

                <span class="n">lower</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'min'</span><span class="p">,</span> <span class="s1">'both'</span><span class="p">):</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s1">'$</span><span class="si">%s</span><span class="s1"> \leq </span><span class="si">%s</span><span class="s1">$'</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable_name</span><span class="p">,</span>
                                                     <span class="n">lower</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n_levels</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'max'</span><span class="p">,</span> <span class="s1">'both'</span><span class="p">):</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s1">'$</span><span class="si">%s</span><span class="s1"> &gt; </span><span class="si">%s</span><span class="s1">$'</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable_name</span><span class="p">,</span>
                                                  <span class="n">upper</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s1">'$</span><span class="si">%s</span><span class="s1"> &lt; </span><span class="si">%s</span><span class="s1"> \leq </span><span class="si">%s</span><span class="s1">$'</span> <span class="o">%</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span>
                                                          <span class="n">variable_name</span><span class="p">,</span>
                                                          <span class="n">upper</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">collection</span><span class="p">,</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>

                <span class="n">patch</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">patch</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>

                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="c1"># format the level for insertion into the labels</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s1">'$</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">$'</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable_name</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">artists</span><span class="p">,</span> <span class="n">labels</span></div>

    <span class="k">def</span> <span class="nf">_process_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Process *args* and *kwargs*; override in derived classes.</span>

<span class="sd">        Must set self.levels, self.zmin and self.zmax, and update axes</span>
<span class="sd">        limits.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check lengths of levels and allsegs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'must be one less number of segments as '</span>
                                 <span class="s1">'levels'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'must be same number of segments as levels'</span><span class="p">)</span>

        <span class="c1"># Check length of allkinds.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'allkinds has different length to allsegs'</span><span class="p">)</span>

        <span class="c1"># Determine x,y bounds and update axes data limits.</span>
        <span class="n">flatseglist</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seg</span><span class="p">]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">flatseglist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mins</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_get_allsegs_and_allkinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Override in derived classes to create and return allsegs and allkinds.</span>
<span class="sd">        allkinds can be None.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span>

    <span class="k">def</span> <span class="nf">_get_lowers_and_uppers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return (lowers,uppers) for filled contours.</span>
<span class="sd">        """</span>
        <span class="n">lowers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">==</span> <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Include minimum values in lowest interval</span>
            <span class="n">lowers</span> <span class="o">=</span> <span class="n">lowers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># so we don't change self._levels</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span><span class="p">:</span>
                <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kinds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">codes</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">]</span>

<div class="viewcode-block" id="ContourSet.changed"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.changed">[docs]</a>    <span class="k">def</span> <span class="nf">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tcolors</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">rgba</span><span class="p">),)</span>
                   <span class="k">for</span> <span class="n">rgba</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tcolors</span> <span class="o">=</span> <span class="n">tcolors</span>
        <span class="n">hatches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hatches</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tcolors</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">hatch</span><span class="p">,</span> <span class="n">collection</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tcolors</span><span class="p">,</span> <span class="n">hatches</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                <span class="c1"># update the collection's hatch (may be None)</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_hatch</span><span class="p">(</span><span class="n">hatch</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="p">):</span>
            <span class="n">label</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">cv</span><span class="p">))</span>
        <span class="c1"># add label colors</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="n">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_autolev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Select contour levels to span the data.</span>

<span class="sd">        We need two more levels for filled contours than for</span>
<span class="sd">        line contours, because for the latter we need to specify</span>
<span class="sd">        the lower and upper boundary of each range. For example,</span>
<span class="sd">        a single contour boundary, say at z = 0, requires only</span>
<span class="sd">        one contour line, but two filled regions, and therefore</span>
<span class="sd">        three levels to provide boundaries for both regions.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">min_n_ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">lev</span>

    <span class="k">def</span> <span class="nf">_contour_level_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Determine the contour levels and store in self.levels.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">'contourf'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">'contour'</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autolev</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">level_arg</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                        <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autolev</span><span class="p">(</span><span class="n">level_arg</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">level_arg</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">"Last </span><span class="si">{0}</span><span class="s2"> arg must give levels; see help(</span><span class="si">{0}</span><span class="s2">)"</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">lev</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">inside</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">]</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"No contour levels were found"</span>
                              <span class="s2">" within the data range."</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Filled contours require at least 2 levels."</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Contour levels must be increasing"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Assign values to :attr:`layers` based on :attr:`levels`,</span>
<span class="sd">        adding extended layers as needed if contours are filled.</span>

<span class="sd">        For line contours, layers simply coincide with levels;</span>
<span class="sd">        a line is a thin layer.  No extended levels are needed</span>
<span class="sd">        with line contours.</span>
<span class="sd">        """</span>
        <span class="c1"># Make a private _levels to include extended regions; we</span>
        <span class="c1"># want to leave the original levels attribute unchanged.</span>
        <span class="c1"># (Colorbar needs this even for line contours.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'both'</span><span class="p">,</span> <span class="s1">'min'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'both'</span><span class="p">,</span> <span class="s1">'max'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span>
            <span class="k">return</span>

        <span class="c1"># layer values are mid-way between levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1"># ...except that extended layers must be outside the</span>
        <span class="c1"># normed range:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'both'</span><span class="p">,</span> <span class="s1">'min'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e150</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'both'</span><span class="p">,</span> <span class="s1">'max'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e150</span>

    <span class="k">def</span> <span class="nf">_process_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Color argument processing for contouring.</span>

<span class="sd">        Note that we base the color mapping on the contour levels</span>
<span class="sd">        and layers, not on the actual range of the Z values.  This</span>
<span class="sd">        means we don't have to worry about bad values in Z, and we</span>
<span class="sd">        always have the full dynamic range available for the selected</span>
<span class="sd">        levels.</span>

<span class="sd">        The color is based on the midpoint of the layer, except for</span>
<span class="sd">        extended end layers.  By default, the norm vmin and vmax</span>
<span class="sd">        are the extreme values of the non-extended levels.  Hence,</span>
<span class="sd">        the layer color extremes are not the extreme values of</span>
<span class="sd">        the colormap itself, but approach those values as the number</span>
<span class="sd">        of levels increases.  An advantage of this scheme is that</span>
<span class="sd">        line contours, when added to filled contours, take on</span>
<span class="sd">        colors that are consistent with those of the filled regions;</span>
<span class="sd">        for example, a contour line on the boundary between two</span>
<span class="sd">        regions will have a color intermediate between those</span>
<span class="sd">        of the regions.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monochrome</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span><span class="o">.</span><span class="n">monochrome</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Generate integers for direct indexing.</span>
            <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">i1</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="c1"># Out of range indices for over and under:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'both'</span><span class="p">,</span> <span class="s1">'min'</span><span class="p">):</span>
                    <span class="n">i0</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'both'</span><span class="p">,</span> <span class="s1">'max'</span><span class="p">):</span>
                    <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">colors</span><span class="o">.</span><span class="n">NoNorm</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'both'</span><span class="p">,</span> <span class="s1">'max'</span><span class="p">,</span> <span class="s1">'min'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># self.tcolors are set by the "changed" method</span>

    <span class="k">def</span> <span class="nf">_process_linewidths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span>
        <span class="n">Nlev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tlinewidths</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'lines.linewidth'</span><span class="p">],)]</span> <span class="o">*</span> <span class="n">Nlev</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
                <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linewidths</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linewidths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">nreps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nlev</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)))</span>
                    <span class="n">linewidths</span> <span class="o">=</span> <span class="n">linewidths</span> <span class="o">*</span> <span class="n">nreps</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">linewidths</span> <span class="o">=</span> <span class="n">linewidths</span><span class="p">[:</span><span class="n">Nlev</span><span class="p">]</span>
            <span class="n">tlinewidths</span> <span class="o">=</span> <span class="p">[(</span><span class="n">w</span><span class="p">,)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">linewidths</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tlinewidths</span>

    <span class="k">def</span> <span class="nf">_process_linestyles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">linestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linestyles</span>
        <span class="n">Nlev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linestyles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tlinestyles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'solid'</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monochrome</span><span class="p">:</span>
                <span class="n">neg_ls</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'contour.negative_linestyle'</span><span class="p">]</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-15</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">lev</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                        <span class="n">tlinestyles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_ls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">tlinestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">elif</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linestyles</span><span class="p">):</span>
                <span class="n">tlinestyles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlinestyles</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">nreps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nlev</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)))</span>
                    <span class="n">tlinestyles</span> <span class="o">=</span> <span class="n">tlinestyles</span> <span class="o">*</span> <span class="n">nreps</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlinestyles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">tlinestyles</span> <span class="o">=</span> <span class="n">tlinestyles</span><span class="p">[:</span><span class="n">Nlev</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Unrecognized type for linestyles kwarg"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tlinestyles</span>

<div class="viewcode-block" id="ContourSet.get_alpha"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.get_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""returns alpha to be applied to all ContourSet artists"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span></div>

<div class="viewcode-block" id="ContourSet.set_alpha"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.set_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">"""sets alpha for all ContourSet artists"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span></div>

<div class="viewcode-block" id="ContourSet.find_nearest_contour"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.find_nearest_contour">[docs]</a>    <span class="k">def</span> <span class="nf">find_nearest_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Finds contour that is closest to a point.  Defaults to</span>
<span class="sd">        measuring distance in pixels (screen space - useful for manual</span>
<span class="sd">        contour labeling), but this can be controlled via a keyword</span>
<span class="sd">        argument.</span>

<span class="sd">        Returns a tuple containing the contour, segment, index of</span>
<span class="sd">        segment, x &amp; y of segment point and distance to minimum point.</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">          *indices*:</span>
<span class="sd">            Indexes of contour levels to consider when looking for</span>
<span class="sd">            nearest point.  Defaults to using all levels.</span>

<span class="sd">          *pixel*:</span>
<span class="sd">            If *True*, measure distance in pixel space, if not, measure</span>
<span class="sd">            distance in axes space.  Defaults to *True*.</span>

<span class="sd">        """</span>

        <span class="c1"># This function uses a method that is probably quite</span>
        <span class="c1"># inefficient based on converting each contour segment to</span>
        <span class="c1"># pixel coordinates and then comparing the given point to</span>
        <span class="c1"># those coordinates for each contour.  This will probably be</span>
        <span class="c1"># quite slow for complex contours, but for normal use it works</span>
        <span class="c1"># sufficiently well that the time is not noticeable.</span>
        <span class="c1"># Nonetheless, improvements could probably be made.</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)))</span>

        <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">conmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">segmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">icon</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">icon</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">segNum</span><span class="p">,</span> <span class="n">linepath</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">linepath</span><span class="o">.</span><span class="n">vertices</span>
                <span class="c1"># transfer all data points to screen coordinates if desired</span>
                <span class="k">if</span> <span class="n">pixel</span><span class="p">:</span>
                    <span class="n">lc</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

                <span class="n">d</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">leg</span> <span class="o">=</span> <span class="n">_find_closest_point_on_path</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
                    <span class="n">dmin</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">conmin</span> <span class="o">=</span> <span class="n">icon</span>
                    <span class="n">segmin</span> <span class="o">=</span> <span class="n">segNum</span>
                    <span class="n">imin</span> <span class="o">=</span> <span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">xmin</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ymin</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">conmin</span><span class="p">,</span> <span class="n">segmin</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="QuadContourSet"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.QuadContourSet">[docs]</a><span class="k">class</span> <span class="nc">QuadContourSet</span><span class="p">(</span><span class="n">ContourSet</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Create and store a set of contour lines or filled regions.</span>

<span class="sd">    User-callable method: :meth:`clabel`</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ax:</span>
<span class="sd">        The axes object in which the contours are drawn.</span>

<span class="sd">    collections:</span>
<span class="sd">        A silent_list of LineCollections or PolyCollections.</span>

<span class="sd">    levels:</span>
<span class="sd">        Contour levels.</span>

<span class="sd">    layers:</span>
<span class="sd">        Same as levels for line contours; half-way between</span>
<span class="sd">        levels for filled contours. See :meth:`_process_colors` method.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">_process_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Process args and kwargs.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QuadContourSet</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">levels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zmax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_corner_mask</span>
            <span class="n">contour_generator</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_contour_generator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mins</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_mins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_maxs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'corner_mask'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">'contour.corner_mask'</span><span class="p">]</span>

            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contour_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

            <span class="n">_mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">ma</span><span class="o">.</span><span class="n">nomask</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">contour_generator</span> <span class="o">=</span> <span class="n">_contour</span><span class="o">.</span><span class="n">QuadContourGenerator</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">filled</span><span class="p">(),</span> <span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunk</span><span class="p">)</span>

            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>

            <span class="c1"># if the transform is not trans data, and some part of it</span>
            <span class="c1"># contains transData, transform the xs and ys to data coordinates</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">))):</span>
                <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">flat</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_mins</span> <span class="o">=</span> <span class="p">[</span><span class="n">ma</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ma</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ma</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ma</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span> <span class="o">=</span> <span class="n">contour_generator</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_get_allsegs_and_allkinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Compute ``allsegs`` and ``allkinds`` using C extension."""</span>
        <span class="n">allsegs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>
            <span class="n">allkinds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">):</span>
                <span class="n">vertices</span><span class="p">,</span> <span class="n">kinds</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span><span class="o">.</span><span class="n">create_filled_contour</span><span class="p">(</span>
                        <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span><span class="p">)</span>
                <span class="n">allsegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                <span class="n">allkinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kinds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allkinds</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">:</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span><span class="o">.</span><span class="n">create_contour</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="n">allsegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">allsegs</span><span class="p">,</span> <span class="n">allkinds</span>

    <span class="k">def</span> <span class="nf">_contour_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">'contourf'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">'contour'</span>
        <span class="n">Nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nargs</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_x_y</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">Nargs</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_xyz</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Too many arguments to </span><span class="si">%s</span><span class="s2">; see help(</span><span class="si">%s</span><span class="s2">)"</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Log scale: values of z &lt;= 0 have been masked'</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_contour_level_args</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        For functions like contour, check that the dimensions</span>
<span class="sd">        of the input arrays match; if x and y are 1D, convert</span>
<span class="sd">        them to 2D using meshgrid.</span>

<span class="sd">        Possible change: I think we should make and use an ArgumentError</span>
<span class="sd">        Exception class (here and elsewhere).</span>
<span class="sd">        """</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Input z must be a 2D array."</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Input z must be at least a 2x2 array."</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Number of dimensions of x and y should match."</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">nx</span><span class="p">,</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">ny</span><span class="p">,</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">if</span> <span class="n">nx</span> <span class="o">!=</span> <span class="n">Nx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Length of x must be number of columns in z."</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ny</span> <span class="o">!=</span> <span class="n">Ny</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Length of y must be number of rows in z."</span><span class="p">)</span>

            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Shape of x does not match that of z: found "</span>
                                <span class="s2">"</span><span class="si">{0}</span><span class="s2"> instead of </span><span class="si">{1}</span><span class="s2">."</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Shape of y does not match that of z: found "</span>
                                <span class="s2">"</span><span class="si">{0}</span><span class="s2"> instead of </span><span class="si">{1}</span><span class="s2">."</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Inputs x and y must be 1D or 2D."</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>

    <span class="k">def</span> <span class="nf">_initialize_x_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return X, Y arrays such that contour(Z) will match imshow(Z)</span>
<span class="sd">        if origin is not None.</span>
<span class="sd">        The center of pixel Z[i,j] depends on origin:</span>
<span class="sd">        if origin is None, x = j, y = i;</span>
<span class="sd">        if origin is 'lower', x = j + 0.5, y = i + 0.5;</span>
<span class="sd">        if origin is 'upper', x = j + 0.5, y = Nrows - i - 0.5</span>
<span class="sd">        If extent is not None, x and y will be scaled to match,</span>
<span class="sd">        as in imshow.</span>
<span class="sd">        If origin is None and extent is not None, then extent</span>
<span class="sd">        will give the minimum and maximum values of x and y.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Input must be a 2D array."</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Input z must be at least a 2x2 array."</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Not for image-matching.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Ny</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># Match image behavior:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">Nx</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="n">Ny</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Ny</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">'upper'</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">_contour_doc</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">        Plot contours.</span>

<span class="s2">        :func:`~matplotlib.pyplot.contour` and</span>
<span class="s2">        :func:`~matplotlib.pyplot.contourf` draw contour lines and</span>
<span class="s2">        filled contours, respectively.  Except as noted, function</span>
<span class="s2">        signatures and return values are the same for both versions.</span>

<span class="s2">        :func:`~matplotlib.pyplot.contourf` differs from the MATLAB</span>
<span class="s2">        version in that it does not draw the polygon edges.</span>
<span class="s2">        To draw edges, add line contours with</span>
<span class="s2">        calls to :func:`~matplotlib.pyplot.contour`.</span>


<span class="s2">        Call signatures::</span>

<span class="s2">          contour(Z)</span>

<span class="s2">        make a contour plot of an array *Z*. The level values are chosen</span>
<span class="s2">        automatically.</span>

<span class="s2">        ::</span>

<span class="s2">          contour(X,Y,Z)</span>

<span class="s2">        *X*, *Y* specify the (x, y) coordinates of the surface</span>

<span class="s2">        ::</span>

<span class="s2">          contour(Z,N)</span>
<span class="s2">          contour(X,Y,Z,N)</span>

<span class="s2">        contour up to *N+1* automatically chosen contour levels</span>
<span class="s2">        (*N* intervals).</span>

<span class="s2">        ::</span>

<span class="s2">          contour(Z,V)</span>
<span class="s2">          contour(X,Y,Z,V)</span>

<span class="s2">        draw contour lines at the values specified in sequence *V*,</span>
<span class="s2">        which must be in increasing order.</span>

<span class="s2">        ::</span>

<span class="s2">          contourf(..., V)</span>

<span class="s2">        fill the ``len(V)-1`` regions between the values in *V*,</span>
<span class="s2">        which must be in increasing order.</span>

<span class="s2">        ::</span>

<span class="s2">          contour(Z, **kwargs)</span>

<span class="s2">        Use keyword args to control colors, linewidth, origin, cmap ... see</span>
<span class="s2">        below for more details.</span>

<span class="s2">        *X* and *Y* must both be 2-D with the same shape as *Z*, or they</span>
<span class="s2">        must both be 1-D such that ``len(X)`` is the number of columns in</span>
<span class="s2">        *Z* and ``len(Y)`` is the number of rows in *Z*.</span>

<span class="s2">        ``C = contour(...)`` returns a</span>
<span class="s2">        :class:`~matplotlib.contour.QuadContourSet` object.</span>

<span class="s2">        Optional keyword arguments:</span>

<span class="s2">          *corner_mask*: bool, optional</span>
<span class="s2">            Enable/disable corner masking, which only has an effect if *Z* is</span>
<span class="s2">            a masked array.  If ``False``, any quad touching a masked point is</span>
<span class="s2">            masked out.  If ``True``, only the triangular corners of quads</span>
<span class="s2">            nearest those points are always masked out, other triangular</span>
<span class="s2">            corners comprising three unmasked points are contoured as usual.</span>

<span class="s2">            Defaults to ``rcParams['contour.corner_mask']``, which defaults to</span>
<span class="s2">            ``True``.</span>

<span class="s2">          *colors*: [ *None* | string | (mpl_colors) ]</span>
<span class="s2">            If *None*, the colormap specified by cmap will be used.</span>

<span class="s2">            If a string, like 'r' or 'red', all levels will be plotted in this</span>
<span class="s2">            color.</span>

<span class="s2">            If a tuple of matplotlib color args (string, float, rgb, etc),</span>
<span class="s2">            different levels will be plotted in different colors in the order</span>
<span class="s2">            specified.</span>

<span class="s2">          *alpha*: float</span>
<span class="s2">            The alpha blending value</span>

<span class="s2">          *cmap*: [ *None* | Colormap ]</span>
<span class="s2">            A cm :class:`~matplotlib.colors.Colormap` instance or</span>
<span class="s2">            *None*. If *cmap* is *None* and *colors* is *None*, a</span>
<span class="s2">            default Colormap is used.</span>

<span class="s2">          *norm*: [ *None* | Normalize ]</span>
<span class="s2">            A :class:`matplotlib.colors.Normalize` instance for</span>
<span class="s2">            scaling data values to colors. If *norm* is *None* and</span>
<span class="s2">            *colors* is *None*, the default linear scaling is used.</span>

<span class="s2">          *vmin*, *vmax*: [ *None* | scalar ]</span>
<span class="s2">            If not *None*, either or both of these values will be</span>
<span class="s2">            supplied to the :class:`matplotlib.colors.Normalize`</span>
<span class="s2">            instance, overriding the default color scaling based on</span>
<span class="s2">            *levels*.</span>

<span class="s2">          *levels*: [level0, level1, ..., leveln]</span>
<span class="s2">            A list of floating point numbers indicating the level</span>
<span class="s2">            curves to draw, in increasing order; e.g., to draw just</span>
<span class="s2">            the zero contour pass ``levels=[0]``</span>

<span class="s2">          *origin*: [ *None* | 'upper' | 'lower' | 'image' ]</span>
<span class="s2">            If *None*, the first value of *Z* will correspond to the</span>
<span class="s2">            lower left corner, location (0,0). If 'image', the rc</span>
<span class="s2">            value for ``image.origin`` will be used.</span>

<span class="s2">            This keyword is not active if *X* and *Y* are specified in</span>
<span class="s2">            the call to contour.</span>

<span class="s2">          *extent*: [ *None* | (x0,x1,y0,y1) ]</span>

<span class="s2">            If *origin* is not *None*, then *extent* is interpreted as</span>
<span class="s2">            in :func:`matplotlib.pyplot.imshow`: it gives the outer</span>
<span class="s2">            pixel boundaries. In this case, the position of Z[0,0]</span>
<span class="s2">            is the center of the pixel, not a corner. If *origin* is</span>
<span class="s2">            *None*, then (*x0*, *y0*) is the position of Z[0,0], and</span>
<span class="s2">            (*x1*, *y1*) is the position of Z[-1,-1].</span>

<span class="s2">            This keyword is not active if *X* and *Y* are specified in</span>
<span class="s2">            the call to contour.</span>

<span class="s2">          *locator*: [ *None* | ticker.Locator subclass ]</span>
<span class="s2">            If *locator* is *None*, the default</span>
<span class="s2">            :class:`~matplotlib.ticker.MaxNLocator` is used. The</span>
<span class="s2">            locator is used to determine the contour levels if they</span>
<span class="s2">            are not given explicitly via the *V* argument.</span>

<span class="s2">          *extend*: [ 'neither' | 'both' | 'min' | 'max' ]</span>
<span class="s2">            Unless this is 'neither', contour levels are automatically</span>
<span class="s2">            added to one or both ends of the range so that all data</span>
<span class="s2">            are included. These added ranges are then mapped to the</span>
<span class="s2">            special colormap values which default to the ends of the</span>
<span class="s2">            colormap range, but can be set via</span>
<span class="s2">            :meth:`matplotlib.colors.Colormap.set_under` and</span>
<span class="s2">            :meth:`matplotlib.colors.Colormap.set_over` methods.</span>

<span class="s2">          *xunits*, *yunits*: [ *None* | registered units ]</span>
<span class="s2">            Override axis units by specifying an instance of a</span>
<span class="s2">            :class:`matplotlib.units.ConversionInterface`.</span>

<span class="s2">          *antialiased*: bool</span>
<span class="s2">            enable antialiasing, overriding the defaults.  For</span>
<span class="s2">            filled contours, the default is *True*.  For line contours,</span>
<span class="s2">            it is taken from rcParams['lines.antialiased'].</span>

<span class="s2">          *nchunk*: [ 0 | integer ]</span>
<span class="s2">            If 0, no subdivision of the domain.  Specify a positive integer to</span>
<span class="s2">            divide the domain into subdomains of *nchunk* by *nchunk* quads.</span>
<span class="s2">            Chunking reduces the maximum length of polygons generated by the</span>
<span class="s2">            contouring algorithm which reduces the rendering workload passed</span>
<span class="s2">            on to the backend and also requires slightly less RAM.  It can</span>
<span class="s2">            however introduce rendering artifacts at chunk boundaries depending</span>
<span class="s2">            on the backend, the *antialiased* flag and value of *alpha*.</span>

<span class="s2">        contour-only keyword arguments:</span>

<span class="s2">          *linewidths*: [ *None* | number | tuple of numbers ]</span>
<span class="s2">            If *linewidths* is *None*, the default width in</span>
<span class="s2">            ``lines.linewidth`` in ``matplotlibrc`` is used.</span>

<span class="s2">            If a number, all levels will be plotted with this linewidth.</span>

<span class="s2">            If a tuple, different levels will be plotted with different</span>
<span class="s2">            linewidths in the order specified.</span>

<span class="s2">          *linestyles*: [ *None* | 'solid' | 'dashed' | 'dashdot' | 'dotted' ]</span>
<span class="s2">            If *linestyles* is *None*, the default is 'solid' unless</span>
<span class="s2">            the lines are monochrome.  In that case, negative</span>
<span class="s2">            contours will take their linestyle from the ``matplotlibrc``</span>
<span class="s2">            ``contour.negative_linestyle`` setting.</span>

<span class="s2">            *linestyles* can also be an iterable of the above strings</span>
<span class="s2">            specifying a set of linestyles to be used. If this</span>
<span class="s2">            iterable is shorter than the number of contour levels</span>
<span class="s2">            it will be repeated as necessary.</span>

<span class="s2">        contourf-only keyword arguments:</span>

<span class="s2">          *hatches*:</span>
<span class="s2">            A list of cross hatch patterns to use on the filled areas.</span>
<span class="s2">            If None, no hatching will be added to the contour.</span>
<span class="s2">            Hatching is supported in the PostScript, PDF, SVG and Agg</span>
<span class="s2">            backends only.</span>


<span class="s2">        Note: contourf fills intervals that are closed at the top; that</span>
<span class="s2">        is, for boundaries *z1* and *z2*, the filled region is::</span>

<span class="s2">            z1 &lt; z &lt;= z2</span>

<span class="s2">        There is one exception: if the lowest boundary coincides with</span>
<span class="s2">        the minimum value of the *z* array, then that minimum value</span>
<span class="s2">        will be included in the lowest interval.</span>
<span class="s2">        """</span></div>
</pre></div>
</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="footer">
        © Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br/>
      Last updated on Jun 28, 2018.
	Created using
	<ahref>Sphinx 1.7.5.
	Doc version v2.2.2-101-g15e1eadd0.
    </ahref></div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
<!--Flipcause Integration v3.0// Flipcause Integration Instructions:
Install the following code block once in the website Header (after <head> tag) -->
<style>

.fc-black_overlay{
display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;
background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;
}

.fc-white_content {
opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;
position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;
}

.fc-main-box{
opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;
}

.fc-widget_close{
opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);
position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;
}

.floating_button{
display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;
position:fixed; z-index:999999; overflow: auto;
}

@keyframes backfadesin {
   from { opacity:0; }
   to {opacity:.5;}
}

@-moz-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-webkit-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-o-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}


@-ms-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; transform: translateY(20px);}
   100% {opacity: 1; transform: translateY(0);}
}

@-moz-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -moz-transform: translateY(20px);}
   100% {opacity: 1; -moz-transform: translateY(0);}
}

@-webkit-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -webkit-transform: translateY(20px);}
   100% {opacity: 1; -webkit-transform: translateY(0);}
}

@-o-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -o-transform: translateY(20px);}
   100% {opacity: 1; -o-transform: translateY(0);}
}

@-ms-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -ms-transform: translateY(20px);}
   100% {opacity: 1; -ms-transform: translateY(0);}
}

</style>
<div class="fc-black_overlay" id="fc-fade" onclick="close_window()"></div>
<div class="fc-white_content" id="fc-light">
<div class="fc-main-box" id="fc-main">
<div class="fc-widget_close" id="fc-close" onclick="close_window()">
</div><iframe height="580" id="fc-myFrame" iframe="" scrolling="no" src="" style="border: 0;
border-radius:5px 5px 5px 5px; box-shadow:0 0 8px rgba(0, 0, 0, 0.5);" width="925"></iframe></div>
</div>
<!--END Flipcause Main Integration Code-->
</footer>
</html>